<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花田半亩</title>
  
  <subtitle>文顶顶的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weibo.com/u/3800117445/"/>
  <updated>2018-06-23T07:47:27.117Z</updated>
  <id>https://weibo.com/u/3800117445/</id>
  
  <author>
    <name>文顶顶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript系列 [05]-TypeScript语言特性(四)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/23/TypeScript%E7%B3%BB%E5%88%97%20%5B05%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E5%9B%9B)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/23/TypeScript系列 [05]-typeScript语言特性(四)/</id>
    <published>2018-06-23T10:05:13.000Z</published>
    <updated>2018-06-23T07:47:27.117Z</updated>
    
    <content type="html"><![CDATA[<h5 id="TypeScript系列-05-TypeScript语言特性-四"><a href="#TypeScript系列-05-TypeScript语言特性-四" class="headerlink" title="TypeScript系列 [05]-TypeScript语言特性(四)"></a>TypeScript系列 [05]-TypeScript语言特性(四)</h5><blockquote><p>说明：本文主要对TypeScript中的函数进行展开介绍。主要包括以下内容</p><p>❏  函数的创建和类型<br>❏  函数的参数情况说明<br>❏  函数的重载<br>❏  函数的作用域<br>❏  泛型</p></blockquote><h3 id="函数的创建和类型"><a href="#函数的创建和类型" class="headerlink" title="函数的创建和类型"></a>函数的创建和类型</h3><p><strong>函数的创建</strong></p><p>函数的创建主要有两种方式：<code>通过函数声明创建</code>和<code>通过函数表达式创建</code>，在形式上函数又可以被划分文<code>命名函数</code>和<code>匿名函数</code>。此外，TypeScript中还提供了箭头函数支持，在声明箭头函数的时候，我们不再使用function关键字转而使用=&gt;标记。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ..07-函数深入讲解/01-函数的创建.ts</span></div><div class="line"></div><div class="line"><span class="comment">//文件路径 ..07-函数深入讲解/01-函数的创建.ts</span></div><div class="line"></div><div class="line"><span class="comment">//测试变量声明提升</span></div><div class="line"><span class="built_in">console</span>.log(getName);   <span class="comment">//函数</span></div><div class="line"><span class="built_in">console</span>.log(getNameT);  <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(f1);        <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 函数声明的方式创建(命名函数)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name:string</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"getName函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] 函数表达式的方式创建(匿名函数)</span></div><div class="line"><span class="keyword">var</span> getNameT = <span class="function"><span class="keyword">function</span> (<span class="params">name:string</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"getNameT函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[003] 箭头函数</span></div><div class="line"><span class="keyword">var</span> f1 = (name:string):<span class="function"><span class="params">string</span>=&gt;</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"f1函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getName(<span class="string">"文顶顶"</span>));            <span class="comment">//getName函数=&gt;姓名 ：文顶顶</span></div><div class="line"><span class="built_in">console</span>.log(getNameT(<span class="string">"wendingding.com"</span>)); <span class="comment">//getNameT函数=&gt;姓名 ：wendingding.com</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="string">"奥特曼"</span>));                 <span class="comment">//f1函数=&gt;姓名 ：奥特曼</span></div></pre></td></tr></table></figure></p><p>因为JavaScript语言中<code>变量声明提升</code>的特性，所以<strong>通过函数声明方式创建的命名函数</strong>和<strong>通过函数表达式方式创建的匿名函数</strong>其使用特征也很不一样。熟悉JavaScript语言中<code>变量提升</code>特性的开发者应该非常清楚，所谓变量声明的提升，指的是在真正执行JavaScript代码前解释器会有个预解析的阶段，在这个阶段中会检查代码中所有的变量声明并把这些声明提升到当前作用域的顶部。</p><div class="tip">需要注意的是，很多人可能并不能够准确的区分清楚代码中哪部分是变量声明，哪部分不属于它，这里进行简单说明。</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//(1)表示声明一个变量a，并未赋值</div><div class="line">var a;   </div><div class="line">//(2)表示声明一个变量b,并把123赋值给变量b</div><div class="line">//这行代码有两部分组成，其结构为 声明 + 赋值</div><div class="line">//等价于 var b; b = 123;两行代码</div><div class="line">var b = 123;</div></pre></td></tr></table></figure><p><code>JavaScript预解析阶段在进行变量声明提升的时候，仅仅会把变量的声明部分进行提升，而赋值操作留在原地</code>。因为函数其实本质上也是变量，所以同样适用上面的规则。</p><p><strong>代码说明</strong>观察第一份示例代码，代码中以函数声明方式创建的命名函数getName，其作为函数(变量)声明在预解析阶段会被整体提升，而匿名函数（赋值给了变量getNameT）因为有赋值操作，所以在预解析阶段只会将变量声明这部分(var getNameT)提升到作用域顶部，赋值操作会被留在原地。</p><p><strong>函数的类型</strong></p><p>我们知道在TypeScript语言中，可以使用可选的类型声明来显示的指定变量的类型，函数其实也算是变量，多以我们可以在声明函数的时候，显示的声明其类型。</p><p>我们先看下面的函数示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1:number,num2:number</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"传入的参数分别为:"</span>+num1+<span class="string">"和 "</span>+ num2 + <span class="string">"add的结果为:"</span> + (num1 + num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码声明了add函数，并指定了该函数需要接受两个number类型的参数（分别为num1和num2），返回值为字符串类型。其实作为特殊的变量，我们也可以给函数也声明类型，在进行函数类型声明的时候，其语法结构同变量可选的类型声明没什么两样，结构均为：<code>声明变量键字 + 变量(函数)名 ：类型</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 声明变量</span></div><div class="line"><span class="keyword">let</span> str:string;</div><div class="line"><span class="comment">//002 声明变量并做初始化赋值操作</span></div><div class="line"><span class="keyword">let</span> sum:number = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//[001]提供函数变量并显示的声明函数的类型（参数和返回值等情况）</span></div><div class="line"><span class="keyword">let</span> f1:<span class="function">(<span class="params">name:string,age:number</span>) =&gt;</span> string;</div><div class="line"><span class="comment">//赋值操作</span></div><div class="line">f1 = <span class="function"><span class="keyword">function</span> (<span class="params">name:string,age:number</span>):<span class="title">string</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名:"</span> +name + <span class="string">"年龄:"</span> + age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数调用</span></div><div class="line">str = f1(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(str);   <span class="comment">//姓名:zs年龄:18</span></div></pre></td></tr></table></figure><p><code>let f1:(name:string,age:number) =&gt; string;</code>这行代码中的<code>(name:string,age:number) =&gt; string</code>用于表示函数的具体类型，我们可以发现函数的类型声明由三部分组成：<code>形参</code> + <code>=&gt;标记</code> +<code>返回值类型</code>。上面的代码中函数的类型声明和赋值操作是分开处理的，你当然也可以像普通变量那样把这两个操作合二为一，下面给出改写后的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 声明函数（函数被指定了类型）</span></div><div class="line"><span class="keyword">let</span> str1:string;</div><div class="line"><span class="keyword">let</span> f2:<span class="function">(<span class="params">name:string,age:number</span>) =&gt;</span> string = <span class="function"><span class="keyword">function</span> (<span class="params">name:string,age:number</span>):<span class="title">string</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名:"</span> +name + <span class="string">"年龄:"</span> + age;</div><div class="line">&#125;  </div><div class="line">str1 = f2(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(str1);    <span class="comment">//姓名:zs年龄:18</span></div></pre></td></tr></table></figure><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;TypeScript系列-05-TypeScript语言特性-四&quot;&gt;&lt;a href=&quot;#TypeScript系列-05-TypeScript语言特性-四&quot; class=&quot;headerlink&quot; title=&quot;TypeScript系列 [05]-TypeScript
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [04]-TypeScript语言特性(三)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/21/TypeScript%E7%B3%BB%E5%88%97%20%5B04%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%89)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/21/TypeScript系列 [04]-typeScript语言特性(三)/</id>
    <published>2018-06-21T10:05:13.000Z</published>
    <updated>2018-06-21T11:50:30.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单介绍TypeScript语言中的以下特性：<br>❏  解构赋值<br>❏  函数介绍<br>❏  命名空间</p></blockquote><h3 id="解构-amp-展开"><a href="#解构-amp-展开" class="headerlink" title="解构&amp;展开"></a>解构&amp;展开</h3><p><span style="color:red">解构赋值语法</span>使得我们可以将值从数组或者将属性从对象中提取对应的变量中。下面我们将简单介绍解构赋值特性在数组、对象以及函数声明中的用法。因为解构特性存在被误用的问题且复杂的表达式常常难以理解，所以<strong><span style="color:red">建议我们在设计代码的时候表达式要尽量保持小而简单</span></strong>。</p><p><strong>解构数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径  ../04-解构和展开/01-解构数组.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构数组简单介绍</span></div><div class="line"><span class="comment">//声明变量arrM(数组)</span></div><div class="line"><span class="keyword">let</span> arrM:number[] = [<span class="number">100</span>,<span class="number">200</span>];</div><div class="line"></div><div class="line"><span class="comment">//解构操作</span></div><div class="line"><span class="comment">//从arrM数组中提取索引为0和1的元素赋值给新声明的变量one和two</span></div><div class="line"><span class="keyword">let</span> [one,two] = arrM;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"one = "</span> + one);    <span class="comment">//one = 100</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"two = "</span> + two);    <span class="comment">//one = 200</span></div></pre></td></tr></table></figure><p>我们通过<code>let [one,two] = arrM</code>这行代码，提取了arrM数组中的前两个元素分别赋值给新声明的变量one和two，这行代码等价于<code>var one = arrM[0], two = arrM[1];</code>分别取值并赋值操作。</p><p>下面给出代码示例，简单演示了如何解构数组中的部分元素（包括：开头位置、结尾位置、指定位置等情况）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 解构数组中的部分元素</span></div><div class="line"><span class="keyword">let</span> arr:string[] = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>];</div><div class="line"><span class="comment">//开始位置</span></div><div class="line"><span class="keyword">let</span> [first] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"first = "</span> + first); <span class="comment">//first = one</span></div><div class="line"></div><div class="line"><span class="comment">//结尾位置</span></div><div class="line"><span class="keyword">let</span> [,,,last] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"last = "</span> + last); <span class="comment">//last = four</span></div><div class="line"></div><div class="line"><span class="comment">//指定位置（提取数组中第一个元素赋值给a,第三个元素赋值给c）</span></div><div class="line"><span class="keyword">let</span> [a,,c,] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span> + a + <span class="string">" c = "</span> + c); <span class="comment">//a = one c = three</span></div></pre></td></tr></table></figure></p><p><strong>解构对象</strong></p><p>除了解构数组外，我们还能够以同样的方式来提取对象中的属性值赋值给声明的同名变量，下面给出代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/02-解构对象.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构对象简单介绍</span></div><div class="line"><span class="keyword">let</span> objM:any = &#123;<span class="attr">author</span>:<span class="string">"文顶顶"</span>,<span class="attr">address</span>:<span class="string">"wendingding.com"</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">color</span>:<span class="string">"red"</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;author,age,address&#125; = objM;</div><div class="line"></div><div class="line"><span class="comment">//解构的顺序并不重要</span></div><div class="line"><span class="comment">//let &#123;author,address,age&#125; = objM;  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"author = "</span>+author);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"age = "</span>+age);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"address = "</span>+address);</div><div class="line"></div><div class="line"><span class="comment">//解构对象的操作说白就就是通过指定的key到对象中取值</span></div><div class="line"><span class="comment">//let &#123;author,age,address&#125; = objM;代码和下面的代码等价</span></div><div class="line"><span class="keyword">var</span> author = objM.author, age = objM.age, address = objM.address;</div></pre></td></tr></table></figure></p><div class="tip"><strong>注意:</strong> 因为对象和数组组织数据的方式不太一样，对象在存储数据的时候是以键值对（key-value）的方式处理，所以<span style="color:#195">我们在解构对象的时候，声明的变量需要和对象中待提取的键值对同名,顺序关系并不重要</span>。</div><p>对象在解构的时候要求声明的变量和提取的对象属性同名，但是在业务场景中我们可能希望声明新的变量（即不使用属性的同名变量），这种情况需要在解构的时候进行重命名操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 对象解构属性重命名</span></div><div class="line"><span class="keyword">let</span> obj:any = &#123;<span class="attr">className</span>:<span class="string">"软件工程"</span>,<span class="attr">classNumber</span>:<span class="string">"软件工程_02"</span>,<span class="attr">date</span>:<span class="string">"2016-09-01"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//在解构对象的时候，支持重命名的方式</span></div><div class="line"><span class="keyword">let</span> &#123;className,<span class="attr">classNumber</span>:classNO,<span class="attr">date</span>:classDate&#125; = obj;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"班级名称 className = "</span> + className); <span class="comment">//班级名称 className = 软件工程</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"班级编号 classNO = "</span> + classNo);     <span class="comment">//班级编号 classNO = 软件工程_02</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"开学日期 classDate = "</span> + classDate); <span class="comment">//开学日期 classDate = 2016-09-01</span></div></pre></td></tr></table></figure></p><p>上面的代码中，在解构对象obj的时候，classNumber被重命名为classNO，date被重命名为classDate，需要注意的是重命名后，classNumber和date均不能使用。此外，对象解构的时候还支持对没使用关键字声明的变量解构以及静态类型声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[003] 支持使用字面量对象来解构赋值</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a:string;</div><div class="line"><span class="keyword">let</span> b:string;</div><div class="line">(&#123;a , b &#125; = &#123;<span class="attr">a</span>:<span class="string">"我是A"</span>,<span class="attr">b</span>:<span class="string">"我是B"</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span> + a);  <span class="comment">//a = 我是A</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"b = "</span> + b);  <span class="comment">//b = 我是B</span></div><div class="line"></div><div class="line"><span class="comment">//[004]支持对变量进行类型声明</span></div><div class="line"><span class="keyword">let</span> o = &#123;<span class="string">"des"</span>:<span class="string">"描述信息"</span>,<span class="string">"num"</span>:<span class="number">20</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;des, num&#125;: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = o;</div><div class="line"><span class="built_in">console</span>.log(des);   <span class="comment">//描述信息</span></div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//20</span></div></pre></td></tr></table></figure><div class="tip"><strong>注意:</strong><code>({a , b } = {a:&quot;我是A&quot;,b:&quot;我是B&quot;})</code>外层必须要加上（），因为JavaScript在解析的时候通常把 { 起始的语句解析为一个块。</div><p><strong>交换变量和设置默认值</strong></p><p>TypeScript中的解构特性为我们提供了一种方便的交换两个变量值的机制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[001] 交换变量</span></div><div class="line"><span class="keyword">let</span> first:string = <span class="string">"我是第一个_first"</span>;</div><div class="line"><span class="keyword">let</span> last:string = <span class="string">"我是最后一个_last"</span>;</div><div class="line"></div><div class="line">[first , last] = [last,first];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"first =&gt;"</span> + first);  <span class="comment">//first =&gt;我是最后一个_last</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"last  =&gt;"</span> + last);   <span class="comment">//last  =&gt;我是第一个_first</span></div></pre></td></tr></table></figure></p><p><strong>说明</strong>：交换变量在具体处理的时候，会生成一个内部的临时变量(请参考编译成JavaScript后的代码)。</p><p>为了有效防止从数组或对象中取出一个值为undefined的数据，我们可以在解构的时候为它们设置默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 解构数组或对象的时候设置默认值</span></div><div class="line"><span class="keyword">let</span> [a,b = <span class="number">20</span>,c] = [<span class="number">10</span>];  <span class="comment">//解构操作</span></div><div class="line"><span class="built_in">console</span>.log(a,b,c);       <span class="comment">//10 20 undefined</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> color,age;</div><div class="line">(&#123;color = <span class="string">"yellow"</span>,age&#125; = &#123;<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">color</span>:<span class="literal">undefined</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(color);   <span class="comment">//yellow</span></div><div class="line"><span class="built_in">console</span>.log(age);     <span class="comment">//18</span></div><div class="line"></div><div class="line"><span class="comment">//解构对象的时候重命名属性并设置默认值</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">one</span>:_one = <span class="string">"哈哈哈"</span>, <span class="attr">two</span>:_two = <span class="string">"嘿嘿"</span>&#125; = &#123;<span class="attr">one</span>:<span class="string">"我是one"</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(_one);    <span class="comment">// 我是one</span></div><div class="line"><span class="built_in">console</span>.log(_two);    <span class="comment">// 嘿嘿</span></div></pre></td></tr></table></figure><p>观察上面的代码，数组中只有一个元素，对象中的color属性对应的值为undefined，我们可以通过在解构的代码中为变量设置默认值的方式来避免取出的值为undefined，其逻辑是：<span style="color:#195">如果解构提取的值非undefined那么就使用，如果是undefined，则检查该变量是否设置默认值，若有则使用</span>。</p><p><strong>解构用于函数参数</strong></p><p>解构除用于对象和数组外，还能作用于函数参数，如果函数调用时候可能缺省部分参数，那么还可以设置默认值增加函数的健壮性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/03-解构用于函数参数.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构用于函数参数(数组)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">[first, second]: [number, number]</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first);   <span class="comment">//1</span></div><div class="line">    <span class="built_in">console</span>.log(second);  <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line">x([<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="comment">//[002] 解构用于函数参数(对象)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b &#125;: &#123; a: string, b?: number &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行函数"</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"a的值为: "</span> + a,<span class="string">"b的值为: "</span> + b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(&#123;<span class="attr">a</span>:<span class="string">"AAAA"</span>,<span class="attr">b</span>:<span class="number">20</span>&#125;);   <span class="comment">//a的值为: AAAA b的值为: 20</span></div><div class="line"></div><div class="line"><span class="comment">/*****=======================******/</span></div><div class="line"><span class="comment">//[003]解构用于函数参数并设置默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">&#123; color, age = <span class="number">99</span> &#125;: &#123; color: string, age?: number &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"color的值为: "</span> + color,<span class="string">"age的值为: "</span> + age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">t(&#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;);  <span class="comment">//color的值为: red age的值为: 20</span></div><div class="line">t(&#123;<span class="attr">color</span>:<span class="string">"red"</span>&#125;);         <span class="comment">//color的值为: red age的值为: 99</span></div></pre></td></tr></table></figure><p><strong>剩余模式(…语法)</strong></p><p>解构特性支持剩余模式也就是<code>...语法</code>，这种模式能够帮助我们将剩余的数组元素或者是对象内容赋值给一个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/04-剩余模式.ts</span></div><div class="line"></div><div class="line"><span class="comment">//将数组中除了前两个之外的元素（剩余的元素）赋值给c</span></div><div class="line"><span class="keyword">let</span> [a,b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>];</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(c); <span class="comment">// [3,4,8]</span></div><div class="line"></div><div class="line"><span class="comment">//剩余模式用于对象解构</span></div><div class="line"><span class="keyword">let</span> o = &#123;<span class="attr">testA</span>:<span class="string">"我是A"</span>,<span class="attr">testB</span>:<span class="string">"我是B"</span>,<span class="attr">testC</span>:<span class="string">"我是C"</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123; testA, ...passthrough &#125; = o;</div><div class="line"><span class="built_in">console</span>.log(testA);       <span class="comment">// 我是A</span></div><div class="line"><span class="built_in">console</span>.log(passthrough); <span class="comment">// &#123;testB:"我是B",testC:"我是C"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">//报错: A rest parameter or binding pattern may not have a trailing comma.</span></div><div class="line"><span class="comment">//let &#123; testB, ...Other,&#125; = o;  //错误的演示</span></div></pre></td></tr></table></figure></p><div class="tip"><strong>特别注意</strong>：剩余元素必须是数组的最后一个元素，如果剩余元素右侧有一个逗号，则会抛出SyntaxError错误。</div><p><strong>数组和对象的展开操作</strong></p><p>展开操作与解构操作刚好相反。<span style="color:red">展开操作它允许我们将数组展开为另一个数组，或将对象展开为另一个对象。</span></p><p>在操作数组的时候展开操作会对指定的数组执行浅拷贝，它们本身并不会因展开操作被修改。对象的展开操作和数组相比略显不同，虽然它和数组展开操作一样也是从左至右进行处理的，但因为其处理的结果仍然是对象，而对象中要求所有的key都具有唯一性，所以这也就意味着在<span style="color:#195">对象的展开操作可能存在属性覆盖的问题</span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/06-数组和对象的展开操作.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 数组的展开操作</span></div><div class="line"><span class="keyword">let</span> one:number[] = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> two:number[] = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> resultArrM = [<span class="number">0</span>, ...one, ...two, <span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.log(one);   <span class="comment">//[1,2]</span></div><div class="line"><span class="built_in">console</span>.log(two);   <span class="comment">//[3,4]</span></div><div class="line"><span class="built_in">console</span>.log(resultArrM);  <span class="comment">//[0,1,2,3,4,5]</span></div><div class="line"></div><div class="line"><span class="comment">//[002] 对象的展开操作</span></div><div class="line"><span class="keyword">let</span> defaultObj = &#123; <span class="attr">name</span>: <span class="string">"zhangsan"</span>, <span class="attr">age</span>: <span class="number">18</span>,<span class="attr">color</span>: <span class="string">"yellow"</span> &#125;;</div><div class="line"><span class="keyword">let</span> targetObj = &#123; ...defaultObj, <span class="attr">des</span>:<span class="string">"描述信息"</span>,<span class="attr">name</span>: <span class="string">"文顶顶"</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(defaultObj);  <span class="comment">//&#123; name: "zhangsan", age: 18,color: "yellow" &#125;;</span></div><div class="line"><span class="built_in">console</span>.log(targetObj);   <span class="comment">//&#123; name: "文顶顶", age: 18,color: "yellow",des:"描述信息"&#125;;</span></div></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 对象的展开操作存在限制情况</p><p>首先，它仅包含对象自身的可枚举属性（不包括原型成员）。<br>其次，TypeScript编译器不允许展开泛型函数上的类型参数。</p></blockquote><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>TypeScript语言中的函数在JavaScript函数基础上增加了参数类型声明、返回值类型指定、箭头函数等特征，这里简单介绍。</p><p><strong>指定参数和返回值类型</strong></p><p>同JavaScript一样，我们可以用函数声明的方式或函数表达式的方式来创建得到一个函数对象，<span style="color:#195">在定义（声明）函数的时候，我们可以选择性的给函数的参数加上类型，也可以指定函数返回值的类型</span>。如果指定了类型，那么TypeScript会进行类型检查。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../05-函数说明/01-函数简单说明.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] javaScript风格的函数（声明函数）</span></div><div class="line"><span class="comment">//下面的代码以“函数声明”的方式创建了add函数</span></div><div class="line"><span class="comment">//add函数拥有两个参数，形参a和形参b</span></div><div class="line"><span class="comment">//add函数的作用为对传入的两个参数进行+运算符计算，并返回结果</span></div><div class="line"><span class="comment">//如果设计的该函数只能接收number类型的两个参数，那么函数体中还应该对参数类型进行校验</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] TypeScript中的函数（声明函数）</span></div><div class="line"><span class="comment">//f1函数接收两个参数，并指定了参数的类型均为number</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a:number,b:number</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="keyword">let</span> result = f1(<span class="number">10</span>,<span class="number">20</span>);    <span class="comment">//返回结果为30</span></div><div class="line"></div><div class="line"><span class="comment">//报错：Argument of type '"字符串"' is not assignable to parameter of type 'number'.</span></div><div class="line"><span class="comment">//result = f1(10,"字符串");  错误的演示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[003] TypeScript中的函数（匿名函数|函数表达式）</span></div><div class="line"><span class="comment">//f2函数的指定了返回值类型为number</span></div><div class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a:number,b:number</span>) : <span class="title">number</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f2(<span class="number">100</span>,<span class="number">200</span>);    <span class="comment">//300</span></div></pre></td></tr></table></figure><p><strong>箭头函数</strong></p><p>TypeScript遵循ES6的规范，提供了表示函数的另外一种方式即<code>箭头函数</code>。箭头函数最典型的特征是在创建函数的时候<code>在函数返回值类型的后面加上箭头(=&gt;)操作符</code>而并不使用function关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../05-函数说明/02-箭头函数.ts</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 这是TypeScript中典型的普通函数，下面提供等价的箭头函数代码</span></div><div class="line"><span class="comment">let add = function (a:number,b:number) : number&#123;</span></div><div class="line"><span class="comment">  return a + b;</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> add = (a:number,<span class="attr">b</span>:number) :<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">10</span>,<span class="number">200</span>);  <span class="comment">//210</span></div></pre></td></tr></table></figure><p>接下来我们给出一个高阶函数的例子，所谓高阶函数指的是参数或返回值也是函数的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sume = <span class="function">(<span class="params">a:number,b:number,callBack:(result:number</span>) =&gt;</span> <span class="keyword">void</span>) : <span class="function"><span class="params">void</span> =&gt;</span>&#123;</div><div class="line">  callBack(a +b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sume(<span class="number">10</span>,<span class="number">20</span>,(result:number) : <span class="function"><span class="params">void</span> =&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result)；</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//输出结果为：result = 30</span></div></pre></td></tr></table></figure><p>代码稍微有点复杂，简单来说，<span style="color:#195">我们声明了两个函数，其中一个是sume匿名函数，另外一个是调用sume时作为参数传递给sume的匿名函数，这两个函数均使用箭头函数表示法</span>。</p><p>作为参数传递给sume的匿名函数需要接受一个number类型的参数（形参为result），没有返回值。而sume这个函数需要接受三个参数，其中前两个参数是number类型的值（形参a和b）, 第三个参数为函数（形参为callBack）。</p><p>需要注意的是<code>(result:number) =&gt; void</code>为<strong>作为参数的匿名函数</strong>的类型。</p><p>通过下面的图示，可以加深大家对箭头函数的理解。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/typeScript_00.png?raw=true"><br>（函数声明图示）<br><img src="https://github.com/flowerField/Source/blob/master/Blog/typeScript_02.png?raw=true"><br>（函数调用图示）</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间</strong>，在以前也称为内部模块。命名空间主要用来把一些存在内在联系的变量、类、接口以及对象等代码组织起来。使用命名空间来组织代码，可以让代码的整体结构更清晰，而且通过把某些相关联的代码包裹起来放在一个命名空间内，而不是暴露在全局命名空间中可以避免命名冲突。</p><p>在TypeScript中，可以通过namespace关键字来声明命名空间，其语法格式为<code>namespace 命名空间的名称{ //.......被包裹的代码块}</code>。命名空间中的代码无法被外界直接访问，如果外界需要访问可以通过<code>export</code>关键字来暴露接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a:string = <span class="string">"全局作用域中的变量"</span>;</div><div class="line"></div><div class="line">namespace WenDemo&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> a:string = <span class="string">"命名空间WenDemo中的变量a"</span>;</div><div class="line"></div><div class="line">  <span class="comment">//接口</span></div><div class="line">  interface PersonInterface &#123;</div><div class="line">      name: string;</div><div class="line">      getInfo();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//实现了PersonInterface接口的Person类</span></div><div class="line">  <span class="comment">//通过export关键字暴露接口</span></div><div class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">PersonInterface</span></span>&#123;</div><div class="line">    name:string;</div><div class="line">    <span class="keyword">constructor</span>(name:string)&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">      <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//let p = new Person("wendingding.com");</span></div><div class="line"></div><div class="line"><span class="comment">//如果把相关代码包裹到指定命名空间中，那么需要通过包裹的命名空间来访问暴露的接口</span></div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> WenDemo.Person(<span class="string">"wendingding.com"</span>);</div><div class="line"><span class="built_in">console</span>.log(p);   <span class="comment">//&#123;name:"wendingding.com"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//全局作用域中的变量</span></div></pre></td></tr></table></figure><p> 把上面TypeScript代码编译为JavaScript的代码，我们可以发现<span style="color:red">命名空间实现的机制非常简单，只是使用了立即调用函数（闭包）包裹代码</span>而已，下面贴出JavaScript对应的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"全局作用域中的变量"</span>;</div><div class="line"><span class="keyword">var</span> WenDemo;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">WenDemo</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="string">"命名空间WenDemo中的变量a"</span>;</div><div class="line">    <span class="comment">//实现了PersonInterface接口的Person类</span></div><div class="line">    <span class="comment">//通过export关键字暴露接口</span></div><div class="line">    <span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line">        Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> Person;</div><div class="line">    &#125;());</div><div class="line">    WenDemo.Person = Person;</div><div class="line">&#125;)(WenDemo || (WenDemo = &#123;&#125;));</div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//let p = new Person("wendingding.com");</span></div><div class="line"><span class="comment">//如果把相关代码包裹到指定命名空间中，那么需要通过包裹的命名空间来访问暴露的接口</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> WenDemo.Person(<span class="string">"wendingding.com"</span>);</div><div class="line"><span class="built_in">console</span>.log(p); <span class="comment">//&#123;name:"wendingding.com"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//全局作用域中的变量</span></div></pre></td></tr></table></figure></p><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单介绍TypeScript语言中的以下特性：&lt;br&gt;❏  解构赋值&lt;br&gt;❏  函数介绍&lt;br&gt;❏  命名空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解构-amp-展开&quot;&gt;&lt;a href=&quot;#解构-amp-展开&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [03]-TypeScript语言特性(二)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/20/TypeScript%E7%B3%BB%E5%88%97%20%5B03%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%BA%8C)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/20/TypeScript系列 [03]-typeScript语言特性(二)/</id>
    <published>2018-06-20T10:05:13.000Z</published>
    <updated>2018-06-20T10:07:58.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">TypeScript简单介绍</a>和<a href="http://wendingding.com/2018/06/19/TypeScript%E7%B3%BB%E5%88%97%20[02]-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%80" target="_blank" rel="external">TypeScript语言特性(一)</a>)这两篇文章中我们对TypeScript进行了简短的介绍并罗列了部分语言特性，这篇文章中我们将继续在语言特性方面展开探讨，主要介绍了TypeScript中流程控制结构、类以及接口等方面的内容，需要说明的是这篇文章中并不会就相关特性的细节深入展开，你能得到的将只有对它们进行的浅尝辄止介绍。</p></blockquote><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>我们知道世界上所有的程序都可以简单划分为<code>顺序、分支和循环</code>这三种结构，使用这三种基本结构组合能够表示所有复杂的结构。<strong>顺序结构</strong>就是按固定的顺序来执行特定的代码（通常是自上而下执行），<strong>分支结构</strong>根据条件判断结果来确定执行那条路径，而<strong>循环结构</strong>用于处理需要重复执行的任务，通常循环结构由<code>初始条件、循环检测条件、循环体以及退出机制</code>组成。TypeScript语言中的流程控制结构和JavaScript保持一致。</p><p><strong>循环结构</strong></p><p>TypeScript语言中的循环结构主要有：<strong><code>while循环</code></strong>、<strong><code>do..while循环</code></strong>、<strong><code>for..in循环</code></strong>以及常用的<strong><code>for循环</code></strong>，下面分别介绍并给出示例代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../02-流程控制结构/01-循环结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] while循环结构</span></div><div class="line"><span class="comment">//说明：while语句用来在满足判断条件的情况下重复执行一段代码,代码在执行的时候会先检查判断条件是否满足，</span></div><div class="line"><span class="comment">//如果条件满足则执行循环体（更新条件变量）,否则就结束当前循环执行后面的代码，重复这个过程</span></div><div class="line"><span class="keyword">let</span> i:number = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)</div><div class="line">&#123;</div><div class="line">  i++;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] do..while循环结构</span></div><div class="line"><span class="comment">//说明：do...while循环结构能够保证循环体至少会被执行一次,当循环体执行完后，代码会检查判断条件是否满足,</span></div><div class="line"><span class="comment">//如果满足条件则继续执行循环体，否则就结束当前循环执行后面的代码，重复这个过程</span></div><div class="line"><span class="keyword">let</span> j:number = <span class="number">5</span>;</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">  j--;</div><div class="line">  <span class="built_in">console</span>.log(j);</div><div class="line">&#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[003] for循环</span></div><div class="line"><span class="comment">//说明:执行for循环的时候的执行顺序为</span></div><div class="line"><span class="comment">//(1) 执行初始化语句，初始化变量n</span></div><div class="line"><span class="comment">//(2) 检查是否满足循环条件</span></div><div class="line"><span class="comment">//    A: 如果满足循环条件，那么就执行循环体,并跳转到（3）</span></div><div class="line"><span class="comment">//    B: 如果不满足循环条件，那么就结束当前循环，继续执行后面的任务</span></div><div class="line"><span class="comment">//(3) 更新循环变量，这里为n++操作</span></div><div class="line"><span class="comment">//(4) 跳转到（2）</span></div><div class="line"></div><div class="line"><span class="comment">//关于break、continue和return</span></div><div class="line"><span class="comment">//在循环体中，如果遇到break和return则表示结束循环(循环本身以及循环内后面的代码不再执行)，执行循环后面的任务</span></div><div class="line"><span class="comment">//如果遇到continue则表示结束当前循环，继续执行后面的循环任务</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> n:number = <span class="number">0</span> ; n &lt; <span class="number">5</span>; n++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(n === <span class="number">3</span>) <span class="keyword">continue</span>;</div><div class="line">    <span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[004] for..in循环</span></div><div class="line"><span class="comment">//说明:for..in循环主要用于遍历代码中的对象</span></div><div class="line"><span class="comment">//注意：不推荐使用for..in循环来遍历数组或伪数组对象，因为它会把原型成员迭代出来。</span></div><div class="line"><span class="keyword">let</span> obj:any = &#123;<span class="attr">name</span>:<span class="string">"zs"</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="string">"des"</span>:<span class="string">"描述信息"</span>&#125;;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"当前循环的key: "</span>+key+<span class="string">" value:"</span>+obj[key]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>分支结构</strong></p><p>TypeScript语言中的分钟结构主要有<code>if..else语句</code>和<code>switch语句</code>，同JavaScript语言保持一致。下面还是贴出简短的代码示例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件目录 ../02-流程控制结构/02-分支结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//分支结构其实就是林中路在某个节点分叉为多条，而只能选择其中一条路继续走下去</span></div><div class="line"><span class="comment">//具体走哪条路就像是人生抉择，得出结选择论的部分被称为判断条件，是布尔类型的值（true/fasle）</span></div><div class="line"></div><div class="line"><span class="comment">//[01] if条件语句结构</span></div><div class="line"><span class="comment">//当条件满足的时候，执行&#123;&#125;中的代码，否则就忽略</span></div><div class="line"><span class="keyword">let</span> temp:boolean = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(temp)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为true"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//.....</span></div><div class="line"></div><div class="line"><span class="comment">//[02] if...else语句结构</span></div><div class="line"><span class="comment">//给定两条路，只能也必须走某一条</span></div><div class="line"><span class="keyword">if</span>(temp)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为true"</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为false"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[03] if...else if...语句结构</span></div><div class="line"><span class="comment">//给定多条路，根据条件进行选择其中的一条</span></div><div class="line"><span class="keyword">let</span> i:number = <span class="number">85</span>;</div><div class="line"><span class="keyword">if</span>(i &gt;= <span class="number">90</span>)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"优秀"</span>)</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">80</span>)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"良好"</span>)</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">60</span>)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"及格"</span>)</div><div class="line">&#125;<span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"不及格"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出结果为:良好</span></div><div class="line"></div><div class="line"><span class="comment">//[04] switch结构</span></div><div class="line"><span class="comment">//switch语句接受一个表达式，会将表达式的值和case语句进行匹配，然后执行关联的语句块。</span></div><div class="line"><span class="comment">//为提高代码的可读性，避免魔法数字等出现，常结合枚举类型组织代码结构</span></div><div class="line">enum Animal&#123;</div><div class="line">  Dog,</div><div class="line">  Cat,</div><div class="line">  Pig</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> animalType:any = Animal.Dog;</div><div class="line"><span class="keyword">switch</span>(animalType)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">case</span> Animal.Dog:</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Dog: 汪汪汪!!!"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Animal.Cat:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Cat: 喵喵喵!!!"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Animal.Pig:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Pig: 呵呵呵!!!"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"其他动物..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><p>我们知道JavaScript本身支持面向对象编程，但实现的方式和其它典型面向对象编程语言截然不同，JavaScript中没有Class的概念，其多态、继承等特性主要依靠函数和原型机制来实现，这种实现机制让很多java/C++型开发者困惑不已。</p><p><span style="color:#0b0">从ES6开始，JavaScript将支持基于类的面向对象实现。</span><span style="color:red"> 在TypeScript中，允许开发者现在就使用Class特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。<span></span></span></p><p>下面给出TypeScript中类的典型结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/01-Class的典型结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//类的定义</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  age:number;       <span class="comment">//age属性</span></div><div class="line">  name:string;      <span class="comment">//name属性</span></div><div class="line">  <span class="keyword">constructor</span>(name:string,age:number)&#123;    <span class="comment">//调用时内部自动执行该代码段</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">  &#125;</div><div class="line">  getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>上面的代码中，我们定义了一个名为Person的类，这个类拥有四个成员为：<code>name属性、 age属性、getInfo方法和constructor构造函数</code>。在Class的内部，我们可以通过 this来引用类中的成员。</p><p>当类被定义之后，我们可以使用 new来调用这个Class。 具体执行的时候，它会先调用Class中定义的构造函数执行初始化操作，并创建出一个当前类的实例对象返回。</p><p>下面贴出上面代码编译为JavaScript代码后的结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding"</span>, <span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>通过观察可以发现，<strong><code>类其本质上是依靠闭包函数和原型对象来实现的</code></strong>。</p><div class="tip"><strong>注意</strong>：当我们在TypeScript语言中定义类的时候，该类中所有的属性和方法默认都是公开的。对于Class的其它细节，这里我们不做展开。</div><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>TypeScript提供了接口机制。其实，TypeScript其核心原则之一就是<code>能够对值所具有的结构进行类型检查</code>,这种处理方式被称为“鸭式辨型法”。我们可以利用接口来为代码定义契约。</p><p>如果在设计某个函数的时候，我们希望该函数接受的参数对象（即函数的参数是一个对象）必须包含某个指定的属性，且类型固定。假设函数名为logNameAndOtherInfo，传递给该函数的对象参数必须要拥有name这个属性，且类型必须为string，我们可以尝试给出如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndOtherInfo</span>(<span class="params">obj:any</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name："</span>+obj.name);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Other：默认的其它信息，这里不做处理"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1:any = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">let</span> obj2:any = &#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line">logNameAndOtherInfo(obj1);  <span class="comment">//name：文顶顶 //Other：默认的其它信息，这里不做处理</span></div><div class="line">logNameAndOtherInfo(obj2);  <span class="comment">//undefined   //Other：默认的其它信息，这里不做处理</span></div></pre></td></tr></table></figure></p><p>观察上面的代码，我们会发现logNameAndOtherInfo函数无力在展示函数参数对象内部属性和类型方面有所作为。这种场景下，接口就可以派上用场。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/03-接口简单示例02.ts</span></div><div class="line"></div><div class="line">interface ObjWithNameValue &#123;</div><div class="line">  name: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndOtherInfo</span>(<span class="params">obj:ObjWithNameValue</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name："</span> + obj.name);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Other：默认的其它信息，这里不做处理"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1:any = &#123;<span class="attr">name</span>:<span class="number">234</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">let</span> obj2:any = &#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line">logNameAndOtherInfo(obj1);  <span class="comment">//name：文顶顶 //Other：默认的其它信息，这里不做处理</span></div><div class="line">logNameAndOtherInfo(obj2);  <span class="comment">//undefined   //Other：默认的其它信息，这里不做处理</span></div></pre></td></tr></table></figure><p>除此之外，TypeScript中的接口与C#或Java里的基本作用一样，也能够用它来明确的强制一个类去符合某种契约。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/03-接口简单示例03.ts</span></div><div class="line"></div><div class="line">interface PersonInterface &#123;</div><div class="line">    name: string;</div><div class="line">    getInfo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类的定义,需要遵循接口的约定</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">PersonInterface</span></span>&#123;</div><div class="line">  <span class="comment">//报错：Property 'name' in type 'Person' is not assignable to the same property in base type 'PersonInterface'.</span></div><div class="line">  <span class="comment">//name:number;      错误的演示（类型和接口不一致）</span></div><div class="line">  name:string;</div><div class="line">  <span class="keyword">constructor</span>(name:string)&#123;    <span class="comment">//调用时内部自动执行该代码段</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">  &#125;</div><div class="line">  getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding.com"</span>);</div></pre></td></tr></table></figure></p><p><strong>代码说明：</strong>在上面的代码中，我们定义了一个名为PersonInterface的接口，和一个实现了该接口的Person类，它能够确保实现了接口的类一定拥有指定的结构。</p><div class="tip"><code>注意</code>：类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型匹配即可。</div><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [02]-TypeScript语言特性(一)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/19/TypeScript%E7%B3%BB%E5%88%97%20%5B02%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%80)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/19/TypeScript系列 [02]-typeScript语言特性(一)/</id>
    <published>2018-06-19T10:05:13.000Z</published>
    <updated>2018-06-19T09:49:19.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">TypeScript简单介绍</a>这篇文章中对TypeScript进行了简短的介绍，这篇文章我们开始来探讨TypeScript的语言特性，主要介绍数据类型方面的内容。</p></blockquote><h3 id="var、let和const关键字"><a href="#var、let和const关键字" class="headerlink" title="var、let和const关键字"></a>var、let和const关键字</h3><p>在ES6前，JavaScript中只能通过var关键字来声明变量，且没有块级作用域。<br>在TypeScript中，我们声明变量的时候可以使用<code>var、let或者是const</code>关键字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径  ../01-数据类型/00-声明变量的关键字</span></div><div class="line"></div><div class="line"><span class="comment">//[01] var 关键字声明变量</span></div><div class="line"><span class="built_in">console</span>.log(var_zero);      <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> var_zero:number = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(var_zero);      <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">//全局作用域</span></div><div class="line"><span class="keyword">var</span> var_one:string = <span class="string">'我是字符串_wendingding'</span>;</div><div class="line"> <span class="comment">//函数作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> var_two:string = <span class="string">'我是函数内的字符串'</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"><span class="built_in">console</span>.log(var_one);         <span class="comment">//输出:我是字符串_wendingding</span></div><div class="line"></div><div class="line"><span class="comment">//报错： Cannot find name 'var_two'.</span></div><div class="line"><span class="comment">//console.log(var_two);    错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> var_i = <span class="number">0</span>; var_i &lt; <span class="number">3</span>; var_i++) &#123;</div><div class="line">    <span class="comment">//循环三次，输出的结果均为3</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(var_i); &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(var_i);   <span class="comment">//打印结果为：3</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****························****/</span></div><div class="line"><span class="comment">//[02] let关键字声明变量</span></div><div class="line"></div><div class="line"><span class="comment">//注意点：let关键字使用的时候必须先声明然后才能使用</span></div><div class="line"><span class="comment">//报错：Block-scoped variable 'let_zero' used before its declaration.</span></div><div class="line"><span class="comment">//console.log(let_zero);        //错误的演示</span></div><div class="line"><span class="comment">//let let_zero:number = 1;</span></div><div class="line"></div><div class="line"><span class="comment">//全局作用域</span></div><div class="line"><span class="keyword">let</span> let_one:string = <span class="string">"wendingding"</span>;</div><div class="line"></div><div class="line"><span class="comment">//函数作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> let_two:string = <span class="string">'我是函数内的字符串'</span>;</div><div class="line">&#125;</div><div class="line">bar();</div><div class="line"><span class="built_in">console</span>.log(let_one);</div><div class="line"></div><div class="line"><span class="comment">//报错：Cannot find name 'let_two'.</span></div><div class="line"><span class="comment">//console.log(let_two); //错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> let_i = <span class="number">0</span>; let_i &lt; <span class="number">3</span>; let_i++) &#123;</div><div class="line">    <span class="comment">//循环3次，输出的结果为0，1，2</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(let_i); &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//报错：Cannot find name 'let_i' 因为let_i的作用域为块级作用域</span></div><div class="line"><span class="comment">//console.log(let_i);   //错误的演示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****························****/</span></div><div class="line"><span class="comment">//[03] const关键字声明变量</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> T1:number = <span class="number">12345</span>;</div><div class="line"><span class="keyword">const</span> T2:string = <span class="string">"建议那些不希望不修改的变量均使用const声明"</span>;</div><div class="line"></div><div class="line"><span class="comment">//报错  Cannot assign to 'T1' because it is a constant or a read-only property.</span></div><div class="line"><span class="comment">//T1 = 234;   错误的演示</span></div><div class="line"></div><div class="line"><span class="comment">//报错： 'const' declarations must be initialized.</span></div><div class="line"><span class="comment">//const T3:boolean; 错误的演示</span></div></pre></td></tr></table></figure></p><p>let关键字声明变量的主要特点有<code>块级作用域</code>、<code>变量先声明后使用</code>以及不能重复定义等。const关键字和let在声明变量的时候基本一致，只是const声明的变量被赋值后不能再改变（注意：对于const来说，只声明不赋值会报错），作用域同let。</p><p><strong>关于变量的作用域说明</strong></p><p><code>var声明的变量</code> 保存在最近的函数作用域中，如果不在任何函数中则在全局作用域中。<br><code>let和const声明的变量</code>保存在最近的比函数作用域小的块级作用域中，如果不在任何代码块中，则在全局作用域中。</p><h3 id="可选的静态类型声明"><a href="#可选的静态类型声明" class="headerlink" title="可选的静态类型声明"></a>可选的静态类型声明</h3><p>TypeScript通过向JavaScript增加<strong>可选的静态类型声明</strong>(<code>Optional static type notation</code>)来把JavaScript编程强类型的程序语言。可选的静态类型声明可以用来约束变量、函数等实体，这样编译器和开发工具就可以在开发过程中提供更好的正确性验证。另外，这种强类型的语言特性也能为代码提供更直观的表达，便于构建大型的程序架构。</p><p>需要注意的是，强类型的语言特性因为增加了类型检测机制所以需要额外的性能开销，但对于TypeScript来说，这些开销是在代码的编译过程中发生的，所以其实<strong>TypeScript并没有额外的运行时性能开销。</strong></p><p><span style="color:#195">TypeScript能够对变量进行类型推导，但是在有些特殊情况下还无法准确的自动侦测出某些对象和变量的类型。在这些情况下，TypeScript允许我们对变量的类型进行明确的声明。这种允许声明变量类型的特性就被称为<strong>可选的静态类型声明</strong>(<code>Optional static type notation</code>)。</span></p><p>选的静态类型的声明方式为<code>关键字 变量名:类型</code>，这种风格源于类型理论，而且更加强调类型的声明时可选的，如果类型声明没有提供，那么TypeScript会通过检查赋给当前变量的值的类型来推导出变量类型，这个过程被称为<strong><code>类型推导(Type inference)</code></strong>，当变量的类型无法被推测出来时（比如变量并没有被赋值），那么TypeScript会把该变量的类型设置为any，any类型可以表示任意的JavaScript值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01.可选的静态类型声明.ts</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> num0;                   <span class="comment">//未知的数据类型(any)</span></div><div class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>;               <span class="comment">//number类型(类型推导)</span></div><div class="line"><span class="keyword">let</span> num2:number;            <span class="comment">//number类型(声明)</span></div><div class="line"><span class="keyword">let</span> num3:number = <span class="number">123</span>;      <span class="comment">//number类型(声明)</span></div><div class="line"><span class="keyword">let</span> num4:number = <span class="string">"string"</span>; <span class="comment">//报错:Type '"string"' is not assignable to type 'number'.</span></div></pre></td></tr></table></figure><p><strong>代码说明</strong>：上面代码中变量num2和num3通过类型声明的方式确定了它们是number类型的，num1因为没有提供类型声明，所以TypeScript尝试检测0的数据类型，然后推导出num1为number类型，num0因为既没有提供类型声明也没有任何赋值操作，所以TypeScript无法推导出其真实类型，因此设置其类型为any。</p><h3 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h3><p>JavaScript语言中数据类型可以分为<code>基本数据类型</code>（Primitive data types）和<code>对象类型</code>（Object types）两种。其中，基本数据类型包括：<code>布尔值、数值、字符串、null、undefined以及Symbol</code>，而对象类型主要有：<code>对象、数组、函数</code>等。</p><p>TypeScript中的数据类型和JavaScript稍有不同，下面主要介绍TypeScript中的基本数据类型，主要有<strong><span style="color:#195">布尔类型(boolean)、数值类型(number)、字符串类型(string)、数组类型(array)、void类型以及枚举类型</span></strong>。</p><p><strong>数值(number)</strong><br>数值类型等同于JavaScript中的number类型，在TypeScript中所有的数字都是浮点数，它们全部都是number类型的。</p><p><strong>字符串(string)</strong><br>连续的一个或多个字符，在代码中需要使用单引号或双引号包住，可以交叉。</p><p><strong>布尔类型(boolean)</strong><br>布尔类型有两个可选的值，true或false。</p><p><strong>数组类型(array)</strong><br>TypeScript中的数组类型和JavaScript不太一样。数组类型在声明的时候比较特殊，通常有两种声明方式：<code>关键字 数组名:类型[]</code>或者<code>关键字 数组名:Array&lt;类型&gt;</code>后一种格式被称为泛型，后面会专门介绍。</p><p><strong>枚举类型(enum)</strong><br>枚举类型和其他面向对象语言中保持一致。我们可以通过<code>enum 类型名{选项1，选项2，选项3,···}</code>的方式来定义，枚举类型中的成员默认从0开始依次递增。</p><p><strong>void类型</strong><br>void类型在所有类型都不存在的时候使用，是any类型的反面。</p><p><strong>any类型</strong><br>any类型可以表示任何类型，即能够表示任意的JavaScript数据。如果变量被声明为某个特定的基本类型，那么在赋值过程中改变其原本的类型是不被允许的，但如果该变量被声明为 any 类型，则允许接受任意类型的值。</p><p>any类型的值支持所有在JavaScript中对变量的操作，且在对any类型的值进行操作时仅仅进行最小静态检查，下面给出基本类型的代码示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../01-数据类型/02-基本数据类型.ts</span></div><div class="line"></div><div class="line"><span class="comment">//01 布尔类型的值</span></div><div class="line"><span class="comment">//类型关键字(boolean)</span></div><div class="line"><span class="comment">//说明 true或者false</span></div><div class="line"><span class="keyword">let</span> bool1:boolean = <span class="literal">true</span>;</div><div class="line"><span class="keyword">let</span> bool2:boolean = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">//02 字符串类型的值</span></div><div class="line"><span class="comment">//类型关键字(string)</span></div><div class="line"><span class="comment">//说明 用双引号或单引号括住一个或多个字符</span></div><div class="line"><span class="keyword">let</span> str1:string = <span class="string">"文顶顶"</span>;</div><div class="line"><span class="keyword">let</span> str2:string = <span class="string">'wen_dingd_ding'</span>;</div><div class="line"><span class="keyword">let</span> str3:string = <span class="string">"Hi '王二!' 你好，我是老实人。"</span></div><div class="line"></div><div class="line"><span class="comment">//03 数值类型</span></div><div class="line"><span class="comment">//类型关键字(number)</span></div><div class="line"><span class="comment">//说明 同JavaScript中的number类型</span></div><div class="line"><span class="keyword">let</span> num1:number = <span class="number">123</span>;</div><div class="line"><span class="keyword">let</span> num2:number = <span class="number">123.321</span>;</div><div class="line"></div><div class="line"><span class="comment">//04 数组类型</span></div><div class="line"><span class="comment">//类型关键字(array)</span></div><div class="line"><span class="comment">//数组类型声明方式(一) 关键字 数组名:类型[]</span></div><div class="line"><span class="keyword">let</span> arr1:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="comment">//let arr2:number[] = [1,3,5,'T',6];            //错误的演示，仅仅允许数字作为数组的元素</span></div><div class="line"><span class="comment">//let arr2:(string | number)[] = [1,3,5,'T',6]; //正确的处理方式</span></div><div class="line"></div><div class="line"><span class="comment">//数组类型声明方式(二) 关键字 数组名:array&lt;类型&gt;</span></div><div class="line"><span class="keyword">let</span> arr3:<span class="built_in">Array</span>&lt;number&gt; = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> arr4:<span class="built_in">Array</span>&lt;any&gt; = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="string">"T"</span>,<span class="literal">false</span>];</div><div class="line"></div><div class="line"><span class="comment">//05 any类型的值</span></div><div class="line"><span class="keyword">let</span> any1 ;    <span class="comment">//声明变量的时候没有进行初始化操作，无法通过类型推导得出真实类型，通常总是设置为any类型</span></div><div class="line"><span class="keyword">let</span> any2:any = <span class="string">"我现在是字符串"</span>;   <span class="comment">//如果某个变量其类型可能会变化，建议使用any类型</span></div><div class="line">any2 = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//报错：Type '123' is not assignable to type 'string'.</span></div><div class="line"><span class="keyword">let</span> test:string = <span class="string">"字符串类型的值"</span>;</div><div class="line"><span class="comment">//test = 123;     //把数值赋值给test变量</span></div><div class="line"></div><div class="line"><span class="comment">//06 枚举类型</span></div><div class="line">enum Color &#123;Red , Green , Yellow , Blue&#125;;</div><div class="line"><span class="keyword">let</span> a:Color = Color.Yellow;</div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//打印的结果为2，每个选项从0开始依次递增</span></div><div class="line"></div><div class="line"><span class="comment">//void类型</span></div><div class="line"><span class="comment">//声明一个返回值为void类型（没有返回值）的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"这是一个没有返回值的函数，返回值的类型为void"</span>);</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">//关于null和undefined</span></div><div class="line"><span class="keyword">let</span> test1:<span class="literal">null</span> = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> test2:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</div></pre></td></tr></table></figure><div class="tip">在JavaScript 语言中存在null和undefined这两种基本的数据类型，它们都只有一个值，分别为null和undefined。在JavaScript语言中，<code>null表示变量的值赋值为空（主动设置变量的值为null外，变量的值不可能自动为空），而undefined表示变量未定义</code>，如果声明了变量但是没有进行初始化赋值操作，那么其值为undefined。需要说明的是，null和undefined它们在TypeScript中作为类型来使用似乎毫无意义。</div><h3 id="联合类型和类型别名"><a href="#联合类型和类型别名" class="headerlink" title="联合类型和类型别名"></a>联合类型和类型别名</h3><p>联合类型用来声明那些可以存储多种类型值的变量。想象以下，如果您在设计变量的时候，希望该变量可以存储字符串类型或者数字类型的值，不能存储除此之外的其它类型数据，那么这个时候就可以使用联合类型来声明了。</p><p>联合类型声明变量的语法格式=&gt; <code>声明变量的关键字 变量名：（类型1 | 类型2）= 值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径: ../01-数据类型/03-联合类型.ts</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> test0 :number = <span class="number">1</span>;</div><div class="line"><span class="comment">//报错：Type 'false' is not assignable to type 'number'.</span></div><div class="line"><span class="comment">//test0 = false;    //错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> test1:(number | boolean) = <span class="number">123</span>;</div><div class="line">test1 = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(test1);</div><div class="line"></div><div class="line"><span class="keyword">let</span> test2:(number[] | string) = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">test2 = <span class="string">"我是字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(test2);</div></pre></td></tr></table></figure><p>TypeScript中允许我们使用type关键字来给类型设置别名。类型别名这种特性可以提高代码的可阅读性，缩短代码，但需要有节制的使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件目录：../01-数据类型/04-类型别名.ts</span></div><div class="line"></div><div class="line">type MyType = (string | boolean | number);</div><div class="line"><span class="keyword">let</span> value1:MyType = <span class="string">"我是字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line">value1 = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line">value1 = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line"><span class="comment">//报错： Type 'number[]' is not assignable to type 'false'.</span></div><div class="line"><span class="comment">//value1 = [1,2,3];  错误的演示</span></div></pre></td></tr></table></figure></p><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[07] Yeoman-generator的创建</title>
    <link href="https://weibo.com/u/3800117445/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B07%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/"/>
    <id>https://weibo.com/u/3800117445/2018/06/14/前端工程化系列[07] Yeoman脚手架generator创建/</id>
    <published>2018-06-14T10:42:13.000Z</published>
    <updated>2018-06-15T04:03:30.179Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：在<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">Yeoman脚手架使用入门</a>和<a href="http://wendingding.com/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[06]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Yeoman脚手架核心机制</a>这两篇文章中已经对Yeoman脚手架工具的基本使用以及去核心运转机制进行了深入的介绍，这篇文章将以实例的方式来教会如何从零开始创建属于我们自己的generator。</div><p><a href="https://github.com/flowerField/generator-wendingding" target="_blank" rel="external">点击获取本文示例的generator</a></p><h3 id="generator创建准备"><a href="#generator创建准备" class="headerlink" title="generator创建准备"></a>generator创建准备</h3><p>这里我们一切从零开始，在创建自己的generator之前需要做一些准备工作，比如准备好yo命令行工具，比如对生成器生成的项目结构和目录文件有清晰的规划等。</p><p><strong>yo命令行工具</strong></p><p>在安装了NodeJS和npm的前提下，可以通过下面的命令来安装yo命令行工具，并检查安装是否成功。</p><p><code>$ npm install -g yo</code><br><code>$ yo --version</code></p><p><strong>generator-generator的安装</strong></p><p>创建generator可以完全从零开始，也可以使用Yeoman官方提供的generator引导，这里我们选择使用Yeoman官方推荐的方式来处理。<br><code>$ mkdir YeomanTest &amp;&amp; cd YeomanTest/</code> 创建新的目录并进入<br><code>$ npm install -g generator-generator</code> 安装Yeoman引导generator</p><p>列出具体的执行情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">wendingding$ mkdir YeomanTest</div><div class="line">wendingding$ <span class="built_in">cd</span> YeomanTest/</div><div class="line">wendingding$ <span class="built_in">pwd</span></div><div class="line">/Users/文顶顶/Desktop/Yeoman/YeomanTest</div><div class="line">wendingding$ npm install -g generator-generator + generator-generator@4.0.2</div><div class="line"></div><div class="line">updated 1 package <span class="keyword">in</span> 117.639s</div><div class="line"></div><div class="line">   ╭─────────────────────────────────────╮</div><div class="line">   │                                     │</div><div class="line">   │   Update available 5.5.1 → 6.1.0    │</div><div class="line">   │     Run npm i -g npm to update      │</div><div class="line">   │                                     │</div><div class="line">   ╰─────────────────────────────────────╯</div></pre></td></tr></table></figure></p><p>执行Yeoman官方的引导generator，并处理交互式配置部分，下面列出具体的执行情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">wendingding$ yo generator</div><div class="line">? Your generator name generator-wendingding</div><div class="line">Your generator must be inside a folder named generator-wendingding</div><div class="line">I<span class="string">'ll automatically create this folder.</span></div><div class="line"><span class="string">? Description 博客文章测试创建生成器</span></div><div class="line"><span class="string">? Project homepage url http://www.wendingding.com</span></div><div class="line"><span class="string">? Author'</span>s Name 文顶顶</div><div class="line">? Author<span class="string">'s Email 18681537032@163.com</span></div><div class="line"><span class="string">? Author'</span>s Homepage http://www.wendingding.com</div><div class="line">? Package keywords (comma to split) wendingding</div><div class="line">? Send coverage reports to coveralls Yes</div><div class="line">? GitHub username or organization flowerField</div><div class="line">? Which license <span class="keyword">do</span> you want to use? Apache 2.0</div><div class="line">   create package.json</div><div class="line">   create README.md</div><div class="line">   create .editorconfig</div><div class="line">   create .gitattributes</div><div class="line">   create .gitignore</div><div class="line">   create generators/app/index.js</div><div class="line">   create generators/app/templates/dummyfile.txt</div><div class="line">   create __tests__/app.js</div><div class="line">   create .travis.yml</div><div class="line">   create .eslintignore</div><div class="line">   create LICENSE</div><div class="line">I<span class="string">'m all done. Running npm install for you to install the required dependencies.</span></div><div class="line"><span class="string">If this fails, try running the command yourself.</span></div></pre></td></tr></table></figure><p>在执行generator-generator这个生成器的过程中，会询问项目名称、作者、使用协议、主页地址等等信息，依次选择填空即可。</p><div class="tip">注意：按照约定，Yeoman generator的名字必须以“generator-”的前缀开头，这是因为所有的generator其实都是全局安装的node模块，所以Yeoman其实是完全依靠文件系统来对这些生成器进行查找操作的。</div><p>当上面的命令执行完毕后，会发现在当前的路径下面生成了<code>generator-wendingding</code>目录，进入到<code>generator-wendingding</code>目录，使用tree命令查看当前目录结构，显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── __tests__</div><div class="line">├── generators</div><div class="line">├── app</div><div class="line">│    ├── index.js</div><div class="line">│    └── templates</div><div class="line">│        └── dummyfile.txt</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">└── package.json</div></pre></td></tr></table></figure></p><p>上面目录结构中虽然有很多文件，但我们<span style="color:red">真正需要关注的应该是generators路径下面的app/index.js文件以及templates目录，其中index文件对应是generators的组装指令部分，templates路径用于存放项目所有的模板文件。</span></p><h3 id="项目模板文件准备"><a href="#项目模板文件准备" class="headerlink" title="项目模板文件准备"></a>项目模板文件准备</h3><p>上面这些准备工作完成之后，接下来我们开始着手分析目标项目的文件结构，即我们使用自己创建的这个脚手架来搭建项目，其结构目录应该是怎样的？需要包含哪些文件等等。任何时候，明确知道你的目标，知道自己正在做什么至关重要。</p><p>下面试着给出目标项目的文件结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── build</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div></pre></td></tr></table></figure></p><p>我们可以看到该项目应该包含<code>bulid</code>、<code>src</code>以及<code>dist</code>三个目录，其中src目录中需要创建名为<code>css</code>、<code>js</code>、<code>libs</code>和<code>template</code>的文件夹，分别用来保存样式文件、脚本文件、依赖的框架以及模板文件等。</p><p>除了这些必要的文件外，假设目标项目需要使用bower来进行依赖管理，使用Grunt来进行自动化构建，所以自然还应该拥有Gruntfile.js、bower.json以及package.json文件。</p><p>假设目标项目中一定会使用到jQuery框架，可能会使用到bootstrap框架。</p><p>现在我们可以开始分析生成器中应该包含项目模板文件了，也就是在generators/templates路径中应该包含哪些文件。</p><p><strong>固定文件</strong></p><p><code>index.js</code>和 <code>style.css</code>创建空文件即可。<br><code>Gruntfile.js文件</code>因为内容固定不变，所以选择直接从旧项目中拷贝。<br><code>.jshintrc文件</code>用于js文件语法检查，内容也是固定不变的。<br><code>.bowerrc文件</code>用于重置Bower下载包的安装路径，内容为{“directory”: “src/libs/“}</p><p><strong>灵活文件</strong></p><p><code>package.json文件</code>中项目名称、作者以及开源协议等需要用户配置<br><code>bower.json文件</code>的项目名称、作者、开源协议以及依赖框架等需要用户配置</p><p><strong>可选文件</strong></p><p><code>bootstrap框架相关的部分</code>为可选文件，需要根据用户配置进行处理。</p><p><strong>依赖文件</strong></p><p><code>jQuery框架相关的部分</code>为依赖文件，在组装指令部分通过在代码中调用方法来下载和安装。</p><p>根据上面的分析，我们在generators/templates准备了多个模板文件，下面列出文件结构以及主要文件的具体内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">└── app</div><div class="line">    ├── index.js</div><div class="line">    └── templates</div><div class="line">        ├── Gruntfile.js</div><div class="line">        ├── bower.json</div><div class="line">        ├── css</div><div class="line">        │   └── style.css</div><div class="line">        ├── index.html</div><div class="line">        ├── js</div><div class="line">        │   └── index.js</div><div class="line">        └── package.json</div></pre></td></tr></table></figure></p><p>package.json文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"&lt;%= appName %&gt;"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"&lt;%= appAuthor %&gt;"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"&lt;%= appLicense %&gt;"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"grunt"</span>: <span class="string">"^1.0.2"</span>,</div><div class="line">    <span class="string">"grunt-contrib-concat"</span>: <span class="string">"^1.0.1"</span>,</div><div class="line">    <span class="string">"grunt-contrib-cssmin"</span>: <span class="string">"^2.2.1"</span>,</div><div class="line">    <span class="string">"grunt-contrib-jshint"</span>: <span class="string">"^1.1.0"</span>,</div><div class="line">    <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"^3.3.0"</span>,</div><div class="line">    <span class="string">"grunt-contrib-watch"</span>: <span class="string">"^1.0.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>bower.json文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"&lt;%= appName %&gt;"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">"\"测试使用\""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"js/index.js"</span>,</div><div class="line">  <span class="string">"authors"</span>: [</div><div class="line">    <span class="string">"&lt;%= appAuthor %&gt;"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"license"</span>: <span class="string">"&lt;%= appLicense %&gt;"</span>,</div><div class="line">  <span class="string">"keywords"</span>: [</div><div class="line">    <span class="string">"generator-wendingding"</span>,</div><div class="line">    <span class="string">"yeoman-generator"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"https://github.com/flowerField/generator-wen"</span>,</div><div class="line">  <span class="string">"ignore"</span>: [</div><div class="line">    <span class="string">"**/.*"</span>,</div><div class="line">    <span class="string">"node_modules"</span>,</div><div class="line">    <span class="string">"bower_components"</span>,</div><div class="line">    <span class="string">"test"</span>,</div><div class="line">    <span class="string">"tests"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"jquery"</span>: <span class="string">"^3.3.1"</span>&lt;% <span class="keyword">if</span>(isIncludeBootstrap) &#123; %&gt;,</div><div class="line">    <span class="string">"bootstrap"</span>: <span class="string">"^4.1.1"</span> &lt;% &#125; %&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>index.html文件内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">appName</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Gruntfile.js文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">// 项目配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//代码合并</span></div><div class="line">        concat:&#123;</div><div class="line">            options:&#123;</div><div class="line">                stripBanners:<span class="literal">true</span>,</div><div class="line">             banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt; 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">            &#125;,</div><div class="line">            target:&#123;</div><div class="line">                src:[<span class="string">"src/js/*.js"</span>],</div><div class="line">                dest:<span class="string">'build/js/index.js'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js代码压缩</span></div><div class="line">        uglify:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"build/js/index.js"</span>,</div><div class="line">                dest:<span class="string">"build/js/index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//css代码压缩</span></div><div class="line">        cssmin:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"src/css/style.css"</span>,</div><div class="line">                dest:<span class="string">"build/css/style.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js语法检查</span></div><div class="line">        jshint:&#123;</div><div class="line">            target:[<span class="string">'Gruntfile.js'</span>,<span class="string">"dist/js/index.js"</span>],</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//监听 自动构建</span></div><div class="line">        watch:&#123;</div><div class="line">            target:&#123;</div><div class="line">                files:[<span class="string">"src/js/*.js"</span>,<span class="string">"src/css/*.css"</span>],</div><div class="line">                <span class="comment">//只要指定路径的文件(js和css)发生了变化，就自动执行tasks中列出的任务</span></div><div class="line">                tasks:[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//通过命令行安装插件（省略...）</span></div><div class="line">    <span class="comment">//从node_modules路径加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-jshint"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-watch"</span>);</div><div class="line">    <span class="comment">//注册任务：在执行$ grunt命令的时候依次执行代码的合并|检查|压缩等任务并开启监听</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>,<span class="string">"watch"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><div class="tip">注意：上面部分文件中很多地方使用模板语法来传递参数，Yeoman所用的模板语言是EJS，具体用法请参考<a href="http://www.embeddedjs.com/" target="_blank" rel="external">EJS官网</a></div></p><h3 id="组装指令"><a href="#组装指令" class="headerlink" title="组装指令"></a>组装指令</h3><p>处理完上面这些工作之后，接下来就是最最核心的部分了，我们需要在<code>app/index.js文件</code>中编写组装指令，这部分代码控制着这个生成器应该怎么执行，包括交互式配置的具体内容、如何复制文件以及框架依赖和Node模块下载等内容。</p><p>下面列出该示例中的index.js文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">'yeoman-generator'</span>);</div><div class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</div><div class="line"><span class="keyword">const</span> yosay = <span class="built_in">require</span>(<span class="string">'yosay'</span>);</div><div class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</div><div class="line">  prompting() &#123;</div><div class="line">    <span class="keyword">this</span>.log(</div><div class="line">      <span class="comment">// yosay(`Welcome to the transcendent $&#123;chalk.red('generator-wen')&#125; generator!`)</span></div><div class="line">      yosay(<span class="string">`欢迎使用\n<span class="subst">$&#123;chalk.red(<span class="string">'generator-wen'</span>)&#125;</span> !\n Author：文顶顶`</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> prompts = [</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'input'</span>,</div><div class="line">        name    : <span class="string">'appName'</span>,</div><div class="line">        message : <span class="string">'请输入项目名称:'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="keyword">this</span>.appname        <span class="comment">//appname是内置对象，代表工程名，这里就是ys</span></div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">       type    : <span class="string">'input'</span>,</div><div class="line">       name    : <span class="string">'appAuthor'</span>,</div><div class="line">       message : <span class="string">'请输入作者姓名:'</span>,</div><div class="line">       <span class="keyword">default</span> : <span class="string">'文顶顶'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'list'</span>,</div><div class="line">        name: <span class="string">'appLicense'</span>,</div><div class="line">        message: <span class="string">'请选择使用的license:'</span>,</div><div class="line">        choices: [<span class="string">'MIT'</span>, <span class="string">'ISC'</span>, <span class="string">'Apache-2.0'</span>, <span class="string">'AGPL-3.0'</span>]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'confirm'</span>,</div><div class="line">        name    : <span class="string">'isIncludeBootstrap'</span>,</div><div class="line">        message : <span class="string">'是否需要使用bootStrap框架？'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="literal">false</span></div><div class="line">     &#125;,</div><div class="line"></div><div class="line">    ];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></div><div class="line">      <span class="keyword">this</span>.props = props;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  writing() &#123;</div><div class="line">    mkdirp(<span class="string">"build"</span>);</div><div class="line">    mkdirp(<span class="string">"dist"</span>);</div><div class="line">    mkdirp(<span class="string">"src/template"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'index.html'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/index.html'</span>),</div><div class="line">      &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName&#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'css/style.css'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/css/style.css'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'js/index.js'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/js/index.js'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'.bowerrc'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'.bowerrc'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'Gruntfile.js'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'Gruntfile.js'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'.jshintrc'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'.jshintrc'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'package.json'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'package.json'</span>),</div><div class="line">       &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName,<span class="attr">appAuthor</span>:<span class="keyword">this</span>.props.appAuthor,<span class="attr">appLicense</span>:<span class="keyword">this</span>.props.appLicense&#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'bower.json'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'bower.json'</span>),</div><div class="line">       &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName,<span class="attr">appAuthor</span>:<span class="keyword">this</span>.props.appAuthor,<span class="attr">appLicense</span>:<span class="keyword">this</span>.props.appLicense,<span class="attr">isIncludeBootstrap</span>:<span class="keyword">this</span>.props.isIncludeBootstrap&#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  install() &#123;</div><div class="line">    <span class="comment">//this.installDependencies();</span></div><div class="line">    <span class="keyword">this</span>.bowerInstall();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码大概由三部分组成，<span style="color:red">第一部分为prompting函数用来处理安装提示，第二部分为writing函数用来设置模板文件的复制操作，第三部分为install函数用来处理框架依赖和node包的安装。</span></p><h3 id="generator的发布和测试"><a href="#generator的发布和测试" class="headerlink" title="generator的发布和测试"></a>generator的发布和测试</h3><p>项目模板文件和组装指令都准备好了后，我们就可以发布自己的generator了，可以先通过<code>$ npm link</code>命令以软连接的方式生成一个全局的npm包，测试使用。<br>具体的执行细节如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wendingding:generator-wendingding wendingding$ npm link</div><div class="line">up to date <span class="keyword">in</span> 3.897s</div><div class="line">/usr/<span class="built_in">local</span>/lib/node_modules/generator-wendingding -&gt; /Users/文顶顶/Desktop/Yeoman/YeomanTest/generator-wendingding</div><div class="line">wendingding:generator-wendingding wendingding$</div></pre></td></tr></table></figure></p><p><strong>测试·使用自己创建的generator来生成初始化项目</strong></p><p>随便找个目录新建文件夹，使用<code>$ yo wendingding</code>命令即可完成项目的初始化工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">wendingding:YeomanTest wendingding$ mkdir Demo</div><div class="line">wendingding:YeomanTest wendingding$ <span class="built_in">cd</span> Demo/</div><div class="line">wendingding:Demo wendingding$ yo wendingding</div><div class="line"></div><div class="line">     _-----_     ╭──────────────────────────╮</div><div class="line">    |       |    │         欢迎使用           │</div><div class="line">    |--(o)--|    │      generator-wen !      │</div><div class="line">   `---------´   │      Author：文顶顶        │</div><div class="line">    ( _´U`_ )    ╰──────────────────────────╯</div><div class="line">    /___A___\   /</div><div class="line">     |  ~  |     </div><div class="line">   __<span class="string">'.___.'</span>__   </div><div class="line"> ´   `  |° ´ Y `</div><div class="line"></div><div class="line">? 请输入项目名称: Demo</div><div class="line">? 请输入作者姓名: 文顶顶</div><div class="line">? 请选择使用的license: Apache-2.0</div><div class="line">? 是否需要使用bootStrap框架？ Yes</div><div class="line">   create bower.json</div><div class="line">   create package.json</div><div class="line">   create src/index.html</div><div class="line">   create src/css/style.css</div><div class="line">   create src/js/index.js</div><div class="line">   create .bowerrc</div><div class="line">   create Gruntfile.js</div><div class="line">   create .jshintrc</div><div class="line">bower invalid-meta  <span class="keyword">for</span>:/Users/文顶顶/Desktop/Yeoman/YeomanTest/Demo/bower.json</div><div class="line">bower invalid-meta  The <span class="string">"name"</span> is recommended to be lowercase, can contain digits, dots, dashes</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git<span class="comment">#3.3.1</span></div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git<span class="comment">#^3.3.1</span></div><div class="line">bower cached        https://github.com/twbs/bootstrap.git<span class="comment">#4.1.1</span></div><div class="line">bower validate      4.1.1 against https://github.com/twbs/bootstrap.git<span class="comment">#^4.1.1</span></div><div class="line">bower install       jquery<span class="comment">#3.3.1</span></div><div class="line">bower install       bootstrap<span class="comment">#4.1.1</span></div><div class="line"></div><div class="line">jquery<span class="comment">#3.3.1 src/libs/jquery</span></div><div class="line"></div><div class="line">bootstrap<span class="comment">#4.1.1 src/libs/bootstrap</span></div><div class="line">wendingding:Demo wendingding$ tree -L 3</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── build</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   ├── bootstrap</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div><div class="line"></div><div class="line">9 directories, 6 files</div></pre></td></tr></table></figure><p>如果需要把这个生成器发布到社区，可以参考官网的说明。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：在&lt;a href=&quot;http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[06] Yeoman脚手架核心机制</title>
    <link href="https://weibo.com/u/3800117445/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B06%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/06/14/前端工程化系列[06] Yeoman脚手架工具核心机制/</id>
    <published>2018-06-14T04:42:13.000Z</published>
    <updated>2018-06-14T13:03:34.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman02.png?raw=true"></p><div class="tip">在<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">前端工程化系列[05] Yeoman脚手架使用入门</a>这边文章中，对Yeoman的使用做了简单的入门介绍，这篇文章我们将接着探讨Yeoman这个脚手架工具内部的核心机制，主要包括以下内容</div><blockquote><p>❏  Yeoman脚手架工具的价值讨论<br>❏  generator[<code>生成器</code>]的内部结构<br>❏  generator[<code>生成器</code>]的项目模板<br>❏  Yeoman脚手架工具的核心运转机制<br>❏  Yeoman 的主要组装流程</p></blockquote><h3 id="Yeoman这样的脚手架工具解决了什么问题？"><a href="#Yeoman这样的脚手架工具解决了什么问题？" class="headerlink" title="Yeoman这样的脚手架工具解决了什么问题？"></a>Yeoman这样的脚手架工具解决了什么问题？</h3><p>所有新事物都不是凭空产生的，它们的出现总有某些内在的驱动力。一项新技术，一个新工具的出现更是如此。不知道从什么时候开始起，我接触新事物新技术以及某些工具的时候，总愿意多花点时间想一想它出现的原因是什么？因为时间、精力等等这些东西都很宝贵，IT从业人员对这些资源尤其敏感，所以新技术或者新工具的出现我认为有几种情况：</p><ul><li>已有的技术或工具存在缺陷，作者们靠自己的才学推出<strong><code>更完美的替代方案</code></strong></li><li>已有的技术或工具无法解决既定的需求，作者们探索出<strong><code>解决问题的技术方案</code></strong></li><li>纯粹闲的蛋疼（这种情况一般比较少见）</li></ul><p>现在，我们来研究下Yeoman的价值，或者说<span style="color:#195">Yeoman出现的意义是什么？Yeoman的出现解决了什么样的问题？</span></p><p>我们假设有这样的开发场景：公司的开发团队，基于某些特定的技术栈已经完成了项目A的开发和上线等工作，项目A的基本情况如下</p><blockquote><p>技术栈：JavaScript + HTML + CSS + Bootstrap + jQuery<br>工作流：npm（包管理工具） + bower（下载器） +  grunt<br>版本管理工具：Git</p></blockquote><p>项目整体目录结构（简化后）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── node_modules</div><div class="line">│   ├── abbrev</div><div class="line">···</div><div class="line">│   └── xtend</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">├── build</div><div class="line">│   ├── css</div><div class="line">│   │   └── style.min.css</div><div class="line">│   └── js</div><div class="line">│       ├── index.js</div><div class="line">│       └── index.min.js</div><div class="line">├── dist</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   ├── bootstrap</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div></pre></td></tr></table></figure></p><div class="tip">说明：上面的目录中src为代码的工作目录，bulid为构建后目录，dist为发布目录。</div><p>因为项目A已经上线发布，现在公司要求着手开展新的项目B，经过需求评审和技术选型后，新项目B采用的工作流和项目A保持一致，技术栈在原有的基础上尝试使用TypeScript来处理脚本部分引入Vue框架，其它部分保持不变。我们发现项目A和项目B它们的结构基本上是一致的（比如项目的目录就够，都需要拥有Gruntfile.js和package.json等文件），但是有些部分又不太一样，比如package.json文件中的项目名称、开发依赖等。</p><p>这个时候，我们在对项目B进行初始化的方式可以尝试以下操作方式：</p><ul><li><span style="color:red">方案①</span> <strong>从0开始创建目录结构，集成工作流配置开发环境</strong></li><li><span style="color:red">方案②</span> <strong>从项目A中拷贝目录结构和固定文件，对于不同的部分一个个修改</strong></li></ul><p>如果我们采用方案① 你会发现这个过程你在初始化项目A的时候就已经做过了，是重复性的工作，毫无技术含量但是又费时费力。<br>如果我们采用方案② 你会发现要修改的文件有些多，每个文件要改的字段也比较多，而且容易遗漏总是调不通会出现各种问题，心烦意乱。</p><p>如果你会使用Yeoman脚手架工具的话，那么对于上面的开发场景你就会多一个方案③，在使用方案③来初始化项目B的时候，你只需要动动手指在终端中输入<code>$ yo 生成器名称</code>再使用交互方式简单配置某些特定值，初始化的工作就完成了。这就是Yeoman的价值所在，初始化项目的时候你不必再把自己沉入到琐碎重复无技术成长的费力工作中，也不必总是像个机器人般进入到拷贝-粘贴-修改这样无止境的循环中。<span style="color:#0b0">脚手架工具是那么的简单直接和高效，你甚至可以省出点加班的时间来看世界杯了 : ) </span></p><p>我知道有一些杠精要出来喷了。<code>“解决这种初始化问题不用搞的这么复杂，我完全可以把项目结构和固定不变的部分抽取出来托管到gitHub仓库，要初始化项目的时候 $ git clone一下不就好了吗？”</code></p><p>说的很有道理，但是clone下来的仓库虽然结构和必要文件已经准备好了，但很多文件是不是还得修改？那你会顶回来<code>“难道使用Yeoman初始化就不需要修改了吗？”</code>当然也要修改，不过就算是修改那改起来也很有趣味还So快！<div class="tip">Yeoman使用交互式的方式来对项目文件中需要灵活处理的部分进行配置，这部分内容我们称为组装指令，具体再文章的后面会进行讲解。</div>另外，如果新项目的整体结构以及技术选型和已有的项目很不一样，那你抽取后交由git管理的仓库就没用了，因为八字不合啊。使用Yeoman就没用这样的顾虑，在<a href="http://yeoman.io/generators/" target="_blank" rel="external">Yeoman-generator列表</a>有好几千现成的generator供你选择，总有一款适合你！！！</p><p> 我要求太太…太高，实在谁也看不上？没关系，generator这家伙还可以私人订制，你完全可以根据自己的需求来定制需要的generator，你一高兴甚至还能把它发布到社区造福全人类。</p><h3 id="Yeoman-generator的内部结构"><a href="#Yeoman-generator的内部结构" class="headerlink" title="Yeoman-generator的内部结构"></a>Yeoman-generator的内部结构</h3><p>搞清楚 generator的价值所在和应用场景之后，我们就可以开始谈论generator相关的话题了，前面介绍过Yeoman脚手架工具的作用是帮助我们依据特定的技术栈需求来初始化项目，在安装了yo工具之后，只需要在终端中使用类似<code>$ yo generator--xx</code>的命令先安装对应的generator然后再<code>$ yo xx</code>搭建即可。至于如何找到匹配当前技术选型的generator，可以去官网的generator列表搜索，这些生成器中有很大一部分来自于对应框架的作者或者Yeoman官方团队，质量有保证且更新很及时。当然，我们也可以创建自己的generator并发布。关于如何创建自己的generator，我们放到另一篇文章<a href="http://wendingding.com/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[07]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/" target="_blank" rel="external">Yeoman脚手架生成器创建</a>来解决。</p><p>简单说Yeoman做的工作其实就是根据当前的生成器（generator）来复制固定的项目模板文件到新项目中，而新项目中的某些文件需要配置，这部分工作由安装时候的交互式指令来完成（相当于传递参数给模板文件）。</p><div class="tip">需要注意的是，Yeoman的设计仅仅只提供了一小部分核心的API，而真正繁重的初始化工作是交给每个具体的generator来完成的。</div><p>generator主要由<strong><code>组装指令</code></strong>和<strong><code>项目模板</code></strong>两部分组成。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman03.png?raw=true" width="600px"></p><p><strong>组装指令</strong></p><p>Yeoman generator中的generators/app/index.js文件是整个生成器的核心部分，该文件用于告知Yeoman该如何来组织并搭建项目，我们可以在该文件中设置初始化项目时必要的安装提示和选项来让用户选择，以及每个文件应该如何复制和修改，是否需要加载依赖和Node包等内容。</p><p><strong>项目模板</strong></p><p>项目模板包括初始化项目需要的所有必须文件。这些文件又可以简单的划分为<strong><code>固定文件</code></strong>、<strong><code>灵活文件</code></strong>、<strong><code>可选文件</code></strong>和<strong><code>依赖文件</code></strong>。所谓<code>固定文件</code>就是在每个初始项目中都一模一样的文件，譬如index.js、style.css等文件，在具体处理的时候这些文件只需要简单复制即可。<code>灵活文件</code>指的是那些需要根据用户选择来做简单修改然后才能复制的文件，譬如index.html文件（title等信息需根据用户输入来指定）。对于<code>可选文件</code>来说，它们并不是必须的，譬如某些基础框架有的项目中需要，有的项目中也许并不需要，这部分文件的处理方式需要<strong>交给用户来决定</strong>。</p><h3 id="项目模板文件的类别"><a href="#项目模板文件的类别" class="headerlink" title="项目模板文件的类别"></a>项目模板文件的类别</h3><p>前面已经介绍过了Yeoman生成器的组成部分主要是组装指令和项目模板。对于整个Yeman脚手架工具来说，项目模板这部分就相当于是搭建脚手架需要用到的原材料，而组装指令用来决定和控制所有的具体行动是什么。</p><p>现在我们开始深入的来讨论项目模板这部分内容，需要先明白的是<code>“能够满足所有需求的万能的项目模板是不存在的”</code>。因为这世界上每个项目组，每个产品甚至每个人的需求(要求)都各有不同。所以，在实践中你必须要对当前项目的需求和采用的技术栈有深入的理解，这样你才能知道目标项目的目录结构会是什么样的? 哪些文件是必不可少的。</p><p>如果你的项目和采用的技术栈比较大众化，那么搜索一个合适的generator基本就能满足需求，拿来主义即可。如果你的项目不管结构还是所采用的技术看上去都那么的非凡和特别，那么就多花一点点时间创建个自己的generator吧，如果你需要处理多个这样的项目，那就更应该了。在创建或者理解generator的时候，我们可以根据前面对项目模板文件的划分情况来区别对待不同的文件。</p><p><strong>固定文件</strong></p><p><span style="color:#195">固定文件是在每个项目中初始内容都一样的必要文件。</span></p><p>比如我们可能总是会把代码的结构划分为<code>src</code>、<code>build</code>和<code>dist</code>三个目录，在src目录下面拥有js、css和lib文件目录，index.js和style.css等文件。这些文件都是必要的，刚开始的时候可能是空的或者只有几行简单的代码。这些文件的特点是，在使用组装指令操作(通常是复制-移动)这些文件的时候，不需要对它们进行任何的修改。</p><p><strong>灵活文件</strong></p><p><span style="color:#195">灵活文件和固定文件差不多，也是初始化项目所必须的，但不同的项目中这些文件的内容也会稍有不同</span>，这些不同之处可能很细微(比如仅仅是名字、协议这些)，也可能差异巨大。比如，我们常用的构建工作流中的<code>bower.json</code>和<code>package.json</code>文件，它们是必不可少的，但是它们都需要当前项目的项目名称和协议等信息才能正常工作。像这样的灵活文件还有index.html，在这个文件中的title标签中应该使用当前项目的名称。</p><p>灵活文件中的部分内容需要在安装该生成器的时候，由用户交互式配置输入的信息来进行设定。</p><p><strong>可选文件</strong></p><p><span style="color:#195">可选文件并不是搭建初始化项目时所必须的文件，如果没有那么没关系，如果有那似乎更好。</span>这些一般在用户交互式配置的时候，以是否题的方式交由用户决定，譬如是否使用less 是否安装Bootstrap等。</p><p><strong>依赖文件</strong></p><p><span style="color:#195">依赖文件指的是某些常用的框架、插件或者是Node模块</span>，这些文件并不需要你在项目模板文件中提供，然后通过组装指令去一个个复制。因为基本上成熟的项目中都会使用既定的工作流(主要包括依赖和包的下载、项目的自动化构建等)，所以我们完全只需要在<code>package.json</code>或者<code>bower.json</code>等文件中设置好依赖即可，然后在组装指令的相关代码中通过<code>this.installDependencies（）</code>类似的代码来调用npm或者是bower执行install命令即可。</p><h3 id="Yeoman脚手架运转的核心机制"><a href="#Yeoman脚手架运转的核心机制" class="headerlink" title="Yeoman脚手架运转的核心机制"></a>Yeoman脚手架运转的核心机制</h3><p>当您为项目准备好(搜索或自己创建)合适的generator之后，就可以用它们来搭建项目了。generator的执行需要在终端中使用yo命令来操作。yo是Yeoman的核心命令，主要用来连接生成器和项目结构。<span style="color:#f25">我们可以把yo命令理解为generator的执行器，它知道怎么找到对应的generator，也知道该如何执行它们。</span></p><div class="tip">注意：yo基于NodeJS且需要在任何文件目录中使用，所以在安装yo命令的时候应该使用-g来进行全局安装。安装过程请参考：<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">Yeoman脚手架使用入门</a>。</div><p>在使用yo命令行工具和生成器来初始化项目之前，需要先把指定的生成器(generator)下载安装到本地（如果是自己创建的生成器，那么可以通过<code>$ npm link</code>命令以软连接的方式生成一个全局的npm包，我的是mac OSX系统，生成的npm包会保存在/usr/local/lib/node_modules/路径，如果使用的是别人发布的generator，那么请使用<code>$ npm install -g generator-xxx</code>的方式来安装）。</p><p>这里需要注意的是<code>yo命令行工具主要负责前期工作，在使用的时候它主要检查当前安装的generator有哪些，指定的generator是否能够正常工作，如果能，那么它就会调用generator的组装指令，把剩下部分的工作交接给generator来完成。generator接管项目的组装流程之后，会按app/index.js中的要求来处理文件的复制等工作</code>。</p><p>下面给出脚手架工具初始化项目时的核心流程。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman04.png?raw=true"></p><p>这里对yo的主要命令进行简单说明</p><p><code>$ yo</code> 执行该命令的时候，yo会搜索并列出所有本地可用的生成器<br><code>$ yo 生成器名称</code> 比如对于<code>generator-typescript</code>生成器，那么执行的命令就是<code>$ yo typescript</code>。该命令会先检查<code>enerator-typescript</code>生成器是否可用。如果可用，那么就接着以 ①交互式配置 ② 写入文件 ③ 下载安装依赖的顺序来执行组装指令。</p><h3 id="Yeoman的主要组装流程"><a href="#Yeoman的主要组装流程" class="headerlink" title="Yeoman的主要组装流程"></a>Yeoman的主要组装流程</h3><p>组装指令是用来让Yeoman创建项目所需文件的一系列具体的命令(代码)。典型的组装流程分为三个步骤：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman05.png?raw=true"></p><blockquote><p><strong>① 交互式配置</strong>。这个步骤通过向用户提问或直接输入配置信息来完成模板传参。<br><strong>② 写入文件</strong>。把项目模板中的指定文件复制到新项目的指定目录中。<br><strong>③ 安装依赖</strong>。下载并安装所有保存在bower.json和package.json文件中的依赖和Node模块。</p></blockquote><p><strong>① 交互式配置</strong></p><p>Yeoman在执行生成器的时候，首先会执行安装提示以交互式的方式来询问用户，目的是为了获取生成器所需要的一些参数，比如项目的名称、作者、使用的开原协议以及是否安装和使用某些组件等。</p><p>这部分功能，需要使用到inquirer包，这个包的作用是生成选项来让用户选择。下面给出代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">prompting() &#123;</div><div class="line"><span class="keyword">const</span> prompts = [</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'input'</span>,</div><div class="line">        name    : <span class="string">'appName'</span>,</div><div class="line">        message : <span class="string">'请输入项目名称:'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="keyword">this</span>.appname        <span class="comment">//appname是内置对象，代表工程名，这里就是ys</span></div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">       type    : <span class="string">'input'</span>,</div><div class="line">       name    : <span class="string">'appAuthor'</span>,</div><div class="line">       message : <span class="string">'请输入作者姓名:'</span>,</div><div class="line">       <span class="keyword">default</span> : <span class="string">'文顶顶'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'list'</span>,</div><div class="line">        name: <span class="string">'appLicense'</span>,</div><div class="line">        message: <span class="string">'请选择使用的license:'</span>,</div><div class="line">        choices: [<span class="string">'MIT'</span>, <span class="string">'ISC'</span>, <span class="string">'Apache-2.0'</span>, <span class="string">'AGPL-3.0'</span>]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'confirm'</span>,</div><div class="line">        name    : <span class="string">'isIncludeBootstrap'</span>,</div><div class="line">        message : <span class="string">'是否需要使用bootStrap框架？'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="literal">false</span></div><div class="line">     &#125;,</div><div class="line"></div><div class="line">    ];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></div><div class="line">      <span class="keyword">this</span>.props = props;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p><p>我们可以看到在代码中，这些交互式配置都由prompts来进行维护，prompts是一个对象数组，数组中的每个元素对象就代表着一个具体的安装提示，在使用yo命令运行该生成器的时候，它的执行情况如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     _-----_     ╭──────────────────────────╮</div><div class="line">    |       |    │         欢迎使用            │</div><div class="line">    |--(o)--|    │      generator-wen!        │</div><div class="line">   `---------´   │      Author：文顶顶         │</div><div class="line">    ( _´U`_ )    ╰──────────────────────────╯</div><div class="line">    /___A___\   /</div><div class="line">     |  ~  |     </div><div class="line">   __'.___.'__   </div><div class="line"> ´   `  |° ´ Y `</div><div class="line"></div><div class="line">? 请输入项目名称: wendingdingTest</div><div class="line">? 请输入作者姓名: 文顶顶</div><div class="line">? 请选择使用的license: Apache-2.0</div><div class="line">? 是否需要使用bootStrap框架？ (y/N) yes</div></pre></td></tr></table></figure></p><p>prompts中的每个对象元素就代表着一个安装提示，上面代码一共提供了四个安装提示。每个对象中的type属性用于表明交互的类型，其中输入项目名称和作者姓名是<code>input型的</code>,表示接收用户的输入，相当于填空题。选择使用的license是<code>list</code>型的，它提供了多个选项供用户选择，您可以认为这种类型是单选题。是否需要使用bootStrap框架是<code>confirm</code>型的，默认为false，如果需要安装那么需要输入YES，这相当于是非题。</p><div class="tip">交互式配置这部分可以根据项目的实际情况来设置prompts中的对象元素，除上面介绍的这些类型外，您还可以通过查看<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="external">inquirer.js的文档</a>来获取更多内容。</div><p>交互式配置过程中用户做出的所有选择和输入都会被保存到this.props对象中，可以通过访问this.props.isIncludeBootstrap属性来确定是否需要安装Bootstrap。</p><p><code>message属性</code>保存是每一条安装提示的提示信息。<br><code>name属性</code>是最重要的属性之一，它作为key用来访问用户的选择结果。<br><code>default属性</code>保存的是默认值，即当用户跳过当前安装提示的时候，name对应的value值将使用default中保存的默认值来设置。</p><p><strong>② 写入文件</strong></p><p>写入文件这个过程会把项目模板复制到指定的目录中，如果是固定文件那么就直接拷贝，如果是灵活文件那么还需要把某些参数传递给指定的模板文件。这个过程在代码中由writing() 函数体现，另外系统还提供了两个函数（<code>fs.copyTpl和fs.copy</code>）用来执行具体的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">writing() &#123;</div><div class="line">    mkdirp(<span class="string">"build"</span>);          <span class="comment">//创建build文件目录</span></div><div class="line">    mkdirp(<span class="string">"dist"</span>);           <span class="comment">//创建dist文件目录</span></div><div class="line">    mkdirp(<span class="string">"src/template"</span>);   <span class="comment">//创建src/template文件目录</span></div><div class="line"></div><div class="line"><span class="comment">//传递参数this.props.appName渲染index.html文件</span></div><div class="line"><span class="comment">//把项目模板中的index.html文件复制到新项目的src路径下</span></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'index.html'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/index.html'</span>),</div><div class="line">      &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName&#125;</div><div class="line">    );</div><div class="line"></div><div class="line"><span class="comment">//把项目模板中的style.css文件复制到新项目的src/css路径下</span></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'css/style.css'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/css/style.css'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><span style="color:#195">fs.copy方法会把指定文件复制到目标路径。</span><br><span style="color:#195">fs.copyTpl方法会先传递参数给模板文件，经过模板引擎处理后再进行复制。</span></p><p><strong>③ 下载和安装依赖</strong></p><p>这个阶段做的事情非常简单，就是调用npm或者是bower来下载并安装依赖和相关的node模块。Yeoman提供了几个对应的方法来处理这个过程。</p><p><strong><code>this.npmInstall()</code></strong><br> 使用Npm来安装package.json中的依赖和模块，相当于在终端中输入<code>$ npm install</code>指令。</p><p><strong><code>this.bowerInstall()</code></strong><br>使用Bower来安装bower.json中的依赖和模块，相当于在终端中输入<code>$ bower install</code>指令。</p><p><strong><code>this.installDependencies()</code></strong><br>调用Bower和Npm并且安装package.json和bower.json中依赖的所有模块，相当于先后调用了npmInstall和bowerInstall方法。</p><p>最后，为了帮助更好的理解Yeoman组装流程的三个阶段，给出下面的示意图。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman06.png?raw=true"></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/yeoman02.png?raw=true&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;在&lt;a href=&quot;http://wendingdin
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[05] Yeoman脚手架使用入门</title>
    <link href="https://weibo.com/u/3800117445/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B05%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/06/12/前端工程化系列[05] Yeoman脚手架工具使用入门/</id>
    <published>2018-06-12T13:42:13.000Z</published>
    <updated>2018-06-12T14:28:00.259Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman.png?raw=true"></p><p><code>Yeoman</code>是一款流行的前端的脚手架工具。</p><p><span style="color:red">脚手架工具可以用来快速的自动生成项目的必要文件和基础文件结构。Yeoman使用的内建命令为yo，同时它自己也是一个包管理工具和自动化任务工具，它基于特定的模板来初始化项目。</span></p><p>考虑这样的开发场景：现在我们需要开始一个全新的前端项目，通常需要先处理项目的文件结构，创建包括img、JavaScript、CSS 等静态资源的文件夹，如果团队开发，可能还需要添加 .gitignore忽略文件以及<code>.editorconfig</code>、<code>.eslintrc</code>、<code>package.json</code>、<code>Gruntfile.js</code>以及README.md等配置文件。</p><p>如果你进行的多个前端项目，它们的技术选型差不多(比如都是：<span style="color:#0b0">jQuery + grunt + Vue + Bootstrap</span>)，你会发现这些项目的整体文件结构是相同的。我们在初始化项目的时候，当然可以从0开始搭建，也可以直接把旧项目的结构和相关文件拷贝过来，这其实都是些重复性没有技术含量的工作，而Yeoman 的作用就是减少这些重复性的工作，通过调用 Yeoman 生态圈中的现成的生成器(<code>generator</code>)即可自动生成项目初始化所需要的文件结构、配置文件等。所以简单来说，<strong><code>Yeoman 是一个用于初始化项目的模版工具，用完就可以扔在一边了</code></strong>。</p><p>关于Yeoman的更多信息可以参考<a href="http://yeoman.io" target="_blank" rel="external">Yeoman官网</a>和<a href="https://github.com/yeoman" target="_blank" rel="external">Github托管仓库</a>。</p><h3 id="Yeoman的安装和使用"><a href="#Yeoman的安装和使用" class="headerlink" title="Yeoman的安装和使用"></a>Yeoman的安装和使用</h3><p>用于初始化项目的模板被称为生成器（<code>generator</code>）, 在开源社区中已经有众多现成的generator可以供我们使用（可以在<a href="http://yeoman.io/generators/" target="_blank" rel="external">生成器列表页</a>使用关键字搜索）。在开始项目的时候，我们可以先搜寻是否有匹配当前项目技术栈的生成器，如果有的话直接用就好了，如果找不到合适的generator，那么可以考虑自己来写一个Yeoman生成器，甚至通过很简单的方式我们就可以把自己写的生成器发布出来造福社区。</p><div class="tip">这篇文章并不包含自己创建Yeoman生成器的内容，我只是想简单介绍下Yeoman的特征，以及如何使用Yeoman的生成器来初始化项目这个部分。</div><p><strong>环境准备</strong></p><p>安装yeoman之前，你需要先安装以下环境</p><ul><li>Node.js 6或更高版本</li><li>npm 3或更高版本（通常安装Node的时候默认安装）</li><li>Git版本控制工具</li></ul><p>点击<a href="https://nodejs.org/en/" target="_blank" rel="external">NodeJS官网</a>选择对应系统和版本根据提示完成NodeJS的安装，我们可以通过在终端输入下面的命令来检查Node和npm的安装是否成功。</p><p><code>$ node --version &amp;&amp; npm --version</code></p><p>有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令来更新npm</p><p><code>$ npm install -g npm@latest</code></p><p>Git的安装过程请自行百度(OSX 默认安装)，您可以通过以下命名来检查Git</p><p><code>$ git --version</code></p><p><strong>安装Yeoman</strong></p><p>通过下面的命令来安装Yeoman并检查是否安装成功，当前最新版本为<code>2.0.1</code>，<code>-g</code>表示全局安装。</p><p><code>$ npm install -g yo</code><br><code>$ yo --version</code></p><p><strong>generator-typeScript初始化项目示例</strong></p><p> 接下来我们将选择一个生成器(<code>这里以typescript为例</code>)来演示初始化项目的操作，Yeoman将会根据对应的生成器替我们创建好package.json和bower.json等文件，然后自动安装依赖。</p><p><span style="color:#195">① 新建 mytodo 文件夹，生成器生成的脚手架文件会放在这个文件夹中。</span></p><p><code>$ mkdir mytodo &amp;&amp; cd mytodo</code></p><p><span style="color:#195">② 根据项目技术栈需求到官网列表搜索合适的生成器。</span><br><span style="color:#195">③ 通过npm来安装指定的generator。</span></p><p><code>$ npm install -g generator-typescript</code></p><p><span style="color:#195">④ typescript生成器安装完成后，使用yo命令来开始。</span></p><p><code>$ yo typescript</code></p><p>下面给出终端处理的具体细节：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">wendingding:Blog wendingding$ mkdir mytodo &amp;&amp; <span class="built_in">cd</span> mytodo</div><div class="line">wendingding:mytodo wendingding$ npm install -g generator-typescript</div><div class="line">npm WARN deprecated npmconf@2.1.3: this package has been reintegrated into npm and is now out of date with respect to npm</div><div class="line"></div><div class="line">&gt; spawn-sync@1.0.15 postinstall /usr/<span class="built_in">local</span>/lib/node_modules/generator-typescript/node_modules/spawn-sync</div><div class="line">&gt; node postinstall</div><div class="line"></div><div class="line">&gt; yo@1.8.5 postinstall /usr/<span class="built_in">local</span>/lib/node_modules/generator-typescript/node_modules/yo</div><div class="line">&gt; yodoctor</div><div class="line"></div><div class="line">Yeoman Doctor</div><div class="line">Running sanity checks on your system</div><div class="line"></div><div class="line">✔ Global configuration file is valid</div><div class="line">✔ NODE_PATH matches the npm root</div><div class="line">✔ Node.js version</div><div class="line">✔ No .bowerrc file <span class="keyword">in</span> home directory</div><div class="line">✔ No .yo-rc.json file <span class="keyword">in</span> home directory</div><div class="line">✔ npm version</div><div class="line"></div><div class="line">Everything looks all right!</div><div class="line">+ generator-typescript@0.3.0</div><div class="line">added 608 packages <span class="keyword">in</span> 138.302s</div><div class="line">wendingding:mytodo wendingding$ yo typescript</div><div class="line"></div><div class="line">     _-----_</div><div class="line">    |       |    ╭──────────────────────────╮</div><div class="line">    |--(o)--|    │  Let<span class="string">'s make some awesome │</span></div><div class="line"><span class="string">   `---------´   │    typescript project!   │</span></div><div class="line"><span class="string">    ( _´U`_ )    ╰──────────────────────────╯</span></div><div class="line"><span class="string">    /___A___\   /</span></div><div class="line"><span class="string">     |  ~  |</span></div><div class="line"><span class="string">   __'</span>.___.<span class="string">'__</span></div><div class="line"><span class="string"> ´   `  |° ´ Y `</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I will include JSHint and Editorconfig by default.</span></div><div class="line"><span class="string">? First off, how would you like to name this project? wendingdingDemo</span></div><div class="line"><span class="string">? Where should it be compiled to? app/build</span></div><div class="line"><span class="string">? Where should your typescript go? app/src</span></div><div class="line"><span class="string">   create package.json</span></div><div class="line"><span class="string">   create app/src/index.ts</span></div><div class="line"><span class="string">   create app/src/app.ts</span></div><div class="line"><span class="string">   create tslint.json</span></div><div class="line"><span class="string">   create gulpfile.js</span></div><div class="line"><span class="string">   create test/test-greeting.js</span></div><div class="line"><span class="string">   create test/test-load.js</span></div><div class="line"><span class="string">   create README.md</span></div><div class="line"><span class="string">   create .editorconfig</span></div><div class="line"><span class="string">   create .jshintrc</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I'</span>m all <span class="keyword">done</span>. Running npm install &amp;&amp; bower install <span class="keyword">for</span> you to install the required dependencies. If this fails, try running the <span class="built_in">command</span> yourself.</div></pre></td></tr></table></figure></p><p>按上面的步骤在终端中执行对应命令，我们就可以得到一个基于基于typescript模板生成的初始化项目了，下面列出该项目的目录结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">wendingding:mytodo wendingding$ tree</div><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── app</div><div class="line">│   ├── build</div><div class="line">│   └── src</div><div class="line">│       ├── app.ts</div><div class="line">│       └── index.ts</div><div class="line">├── gulpfile.js</div><div class="line">├── package.json</div><div class="line">├── <span class="built_in">test</span></div><div class="line">│   ├── <span class="built_in">test</span>-greeting.js</div><div class="line">│   └── <span class="built_in">test</span>-load.js</div><div class="line">└── tslint.json</div><div class="line"></div><div class="line">4 directories, 8 files</div></pre></td></tr></table></figure></p><p>最后，根据Yeoman终端中的提示通过<code>$ npm install &amp;&amp; bower install</code>命令来安装必要的依赖即可。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/yeoman.png?raw=true&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Yeoman&lt;/code&gt;是一款流行的前端的脚手架工具。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [01]-TypeScript简单介绍</title>
    <link href="https://weibo.com/u/3800117445/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20%5B01%5D-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://weibo.com/u/3800117445/2018/06/12/TypeScript系列 [01]-typeScript简单介绍/</id>
    <published>2018-06-12T10:05:13.000Z</published>
    <updated>2018-06-15T09:33:10.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-0-TypeScript语言简单说明"><a href="#1-0-TypeScript语言简单说明" class="headerlink" title="1.0 TypeScript语言简单说明"></a>1.0 TypeScript语言简单说明</h3><p><strong>简单说明</strong></p><p><code>TypeScript</code>是微软2012年推出的一种编程语言，属于 JavaScript 的超集，可以编译为 JavaScript 执行。它最大特点是强大的类型系统和对ES6的支持，TypeScript托管于<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">GitHub上面</a>。</p><p>TypeScript代码，通过编译可以转换为纯正的 JavaScript代码，且编译出来的 JavaScript代码能够运行在任何浏览器上。TypeScript 的编译工具也可以运行在任何服务器和任何系统上。</p><p><strong>设计目标</strong></p><p>TypeScript从一开始就提出了自己的设计目标，主要如下：</p><ul><li><code>遵循当前以及未来出现的ECMAScript规范</code>。</li><li>为大型项目提供构建机制（通过Class 、接口和模块等支撑）。</li><li>兼容现存的JavaScript代码，即任何合法的JavaScript程序都是合法的typeScript程序。</li><li>对于发行版本的代码没有运行开销。（使用过程可以简单划分为程序设计阶段和执行阶段）。</li><li>成为跨平台的开发工具，TypeScript使用Apache作为开源协议，且能够在所有主流的操作系统上安装和执行。</li></ul><p><strong>TypeScript的优势</strong></p><blockquote><p>❏ 拥有活跃的社区支持和生态<br>❏ 增加了代码的可读性和可维护性<br>❏ 拥抱 ES6 规范，也支持ES7 草案的规范<br>❏ TypeScript本身非常包容，兼容所有现行的JavaScript代码</p></blockquote><p><strong>TypeScript的劣势</strong></p><blockquote><p>❏ 短期投入到工作可能增加开发成本<br>❏ 集成到自动构建流程中需要额外的工作量<br>❏ 学习需要成本，需要理解接口、Class、泛型等知识</p></blockquote><p><strong>关于TypeScript更多信息，请参考</strong><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript官网</a>和<a href="https://www.tslang.cn/" target="_blank" rel="external">TypeScript中文网站</a>或<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="external">TypeScript Github托管仓库</a>。</p><h3 id="2-0-开发环境和工具支持"><a href="#2-0-开发环境和工具支持" class="headerlink" title="2.0 开发环境和工具支持"></a>2.0 开发环境和工具支持</h3><p><strong>命令行工具</strong></p><p>安装命令：<code>$ npm install -g typescript</code></p><p>-g表示全局安装，上面的命令执行后会在全局环境下安装 tsc 命令。</p><p>查看版本信息命令：<code>$ tsc --version</code></p><p>可以通过<code>$ tsc --help</code>来查看tsc使用帮助，通过<code>$ tsc --version</code>命令来查看tsc版本验证是否安装成功，当前最新的版本为<code>Version 2.9.1</code>，安装成功后我们就可以在任何地方来执行 tsc 命令了。</p><div class="tip">typeScript文件的后缀为.ts。</div><p>我们可以通过在命令行中输入<code>$ tsc xxx.ts</code>命令来把文件编译为JavaScript文件，上述命令中xxx为对应文件的名称，编译完成后将得到xxx.js文件。</p><p><strong>编辑器使用</strong></p><p><code>主流的编辑器都支持 TypeScript</code>。下面列出推荐的编辑器（点击获取编辑器或IDE对TypeScript的支持）</p><blockquote><p><a href="https://atom.io/" target="_blank" rel="external">Atom</a> 21世纪黑客文本编辑器（拥有众多强大插件）<br><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm</a> 强大的前端开发编辑器<br><a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code</a> 内置了TypeScript支持，且本身也由TypeScript实现。</p></blockquote><h3 id="3-0-TypeScript组件"><a href="#3-0-TypeScript组件" class="headerlink" title="3.0 TypeScript组件"></a>3.0 TypeScript组件</h3><p>TypeScript语言内部被划分为三层，每层又被一次划分为子层或者是组件。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/typeScript.png?raw=true"></p><p><code>TypeScript语言内部的每一层都有自己不同的用途。</code></p><blockquote><p><strong>语言层</strong>：实现所有TypeScript的语言特性。<br><strong>编译层</strong>：执行编译和类型检查操作，并把代码转换为JavaScript。<br><strong>语言服务层</strong>：生成信息以帮助编辑器或其它开发工具提供更好的辅助特性。</p></blockquote><div class="tip">VS是Microsoft’s Visual Studio的缩写，意所有微软产品的官方一体化开发工具。</div><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-0-TypeScript语言简单说明&quot;&gt;&lt;a href=&quot;#1-0-TypeScript语言简单说明&quot; class=&quot;headerlink&quot; title=&quot;1.0 TypeScript语言简单说明&quot;&gt;&lt;/a&gt;1.0 TypeScript语言简单说明&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 HTML页面渲染的基本过程</title>
    <link href="https://weibo.com/u/3800117445/2018/06/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20HTML%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/06/11/网络编程系列 HTML页面渲染的基本过程/</id>
    <published>2018-06-11T04:10:13.000Z</published>
    <updated>2018-06-11T10:35:32.717Z</updated>
    
    <content type="html"><![CDATA[<p>本文描述了HTML页面渲染的基本（一般）过程，需要说明的是该文并不包含关于HTML解释器、CSS解释器、JavaScript引擎等相关部分内部的具体处理细节。该文旨在简单介绍网页从加载到被我们看到过程中，由浏览器引擎处理部分（URL网络请求相关细节可以参考<a href="http://www.ituring.com.cn/book/1758" target="_blank" rel="external">网络是怎么连接的</a>）的大概框架，主要包括以下内容</p><blockquote><p>① HTML页面的基本渲染过程<br>② WebKit的网页渲染过程(加载和渲染)</p></blockquote><h3 id="1-0-基本渲染过程"><a href="#1-0-基本渲染过程" class="headerlink" title="1.0 基本渲染过程"></a>1.0 基本渲染过程</h3><p>在<a href="http://wendingding.com/2018/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20DOM%E5%92%8CDOM%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/" target="_blank" rel="external">DOM和DOM操作基础</a>和<a href="http://wendingding.com/2018/06/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81HTML%E5%92%8C%E5%86%85%E6%A0%B8(%E5%BC%95%E6%93%8E" target="_blank" rel="external">浏览器、HTML和内核(引擎)</a>)这两篇文章中，已经对浏览器、浏览器内核、HTML页面以及DOM等术语有了专基本的介绍，现在先简单回顾下渲染引擎的基本渲染流程：</p><blockquote><p>① 解析HTML并构造DOM树(<code>DOM Tree</code>)<br>② 构建渲染树(<code>Render Tree</code>)<br>③ 布局渲染树<br>④ 绘制渲染树</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader03.png?raw=true"></p><p>接下来我们开始讨论<span style="color:#f66">从浏览器地址栏输入URL地址敲下回车键到我们能够看到网页内容的这个过程</span>。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader01.png?raw=true"></p><p>把用户输入的URL转换为可视化的视图，这本身就是浏览器最最主要的功能，这个过程基本上可以划分为网页的加载和显示(渲染)两个部分。所谓网页的加载，指的主要是从用户输入URL到DOM树构建完成的过程，而网页渲染的过程，主要处理根据DOM树来生成可视化视图的部分。</p><p><span style="color:#0b0">当我们在浏览器的地址栏里输入了指定的URL之后，浏览器会先调用网络相关模块向指定的服务器发送网络请求，服务器接收到合法的请求后把网页文件以响应的方式返回给客户端（浏览器）。</span><br><span style="color:#0b0"><br>当浏览器接收到对应的网页内容后，会先把网页内容作为输入交给HTML解释器处理，HTML解释器会将网页内容最终解释为一棵DOM树(DOM Tree)，这期间如果遇到JavaScript代码，则转交给JavaScript引擎处理，如果遇到CSS内容，则转交给CSS解释器处理。当DOM树构建完成的时候，渲染引擎将接收CSS解释器输出的样式信息，并作用于DOM树构建出一个新的内部绘图模型（也称为渲染树，即Render Tree）。在构建出渲染树之后，再由布局模块计算出各个元素的位置和大小等信息，最后交给绘图模块画出最终的视图。</span></p><p>为了更好的理解这个过程，这里给出基本的渲染过程图示，除必要过程外，图中还列出了该过程中需要依赖的主要模块，需要注意的是<code>有的过程是单向的（单箭头）有的过程是双向的（双向箭头</code>。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader02.png?raw=true"></p><h3 id="2-0-WebKit的渲染过程"><a href="#2-0-WebKit的渲染过程" class="headerlink" title="2.0 WebKit的渲染过程"></a>2.0 WebKit的渲染过程</h3><p>虽然主流内核对HTML网页的渲染过程大同小异，但不同的渲染引擎其内部的处理细节差别还是比较大的，这种差别主要体现在<strong><code>渲染流程</code></strong>和<strong><code>专业术语</code></strong>等方面，考虑到WebKit内核当前的主导地位，这里专门挑出WebKit内核，并深入其内部的具体渲染细节。</p><p>我们把整个过程初步的划分为<strong><code>根据URL加载并解析网页构建DOM树</code></strong>和<strong><code>渲染布局并绘制</code></strong>这两个阶段。</p><p><strong> ↪ ︎通过URL加载并解析网页构建DOM树阶段 </strong><br><img src="https://github.com/flowerField/Source/blob/master/Blog/reader04.png?raw=true"></p><p><strong><span style="color:red">解析网页构建DOM树具体的处理细节</span></strong></p><p> ① 当用户在浏览器中输入URL的时候，WebKit内核会调用资源加载器来加载指定路径对应的网页资源（发送请求-接收响应模型）。</p><p> ② 资源加载器依赖网络模块和服务器端建立连接发送请求并接收响应。</p><p> ③ 接收服务器返回的响应数据，是HTML/CSS/JavaScript网页和资源文件。</p><p> ④ 网页内容被交给HTML解释器处理，被转变为一系列的<code>Token</code>。</p><p> ⑤ HTML解释器根据Token来构建Node节点，并最终形成一棵<code>DOM树</code>。</p><p> ⑥ 如果遇到JavaScript代码，那么交给JavaScript引擎解释并执行。</p><p> ⑦ JavaScript代码执行的时候可能会影响到最终DOM树的结构。</p><p> ⑧ HTML解释器在处理网页内容的时候，如果发现当前节点需要依赖于其它的资源，那么将调用资源加载器来加载这些资源（CSS/图片/音频/视频等）。如果异步加载，则和DOM树的构建工作并行执行，如果是同步加载（根据URL加载外部的JavaScript文件），则会暂停DOM树的构建，直到任务处理完毕重复这个过程。</p><div class="tip">小贴士：网页在加载和渲染的处理过程中，会触发DOM的相关事件。在DOM树构建完成后将会触发<code>DOMContentLoaded事件</code>，在DOM树构建完已经所有资源都加载完毕后将会触发<code>onload事件</code>。我们在代码中常常通过把js代码写在window.onload方法中的方式来等DOM加载完毕再执行代码，其实监听的就是DOM的onload事件，相应的在jQuery框架的使用过程中，我们把相关的js代码写在<code>$(function(){...})</code>或者$().ready(function(){//…})回调函数中，其实监听的是DOM的DOMContentLoaded事件。</div><p><strong> ↪ ︎渲染布局并绘制阶段</strong></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader5.png?raw=true"><br><strong><span style="color:red">渲染布局以及绘制阶段具体的处理细节</span></strong></p><p>① CSS样式相关的部分将被CSS解释器处理为<code>内部表示结构</code>。</p><p>② 将CSS解释器处理完后的样式信息附加在构件好的DOM树上，成为<code>RenderObject树</code>。</p><p>③ 在RenderObject节点创建的同时，WebKit内核会根据网页的层次结构来创建<code>RenderLayer树</code>。</p><p>④ 在RenderLayer树创建的同时，会构建一个虚拟的<code>绘图上下文</code>(这里不涉及具体的处理细节)。</p><p>⑤ WebKit内核处理的绘图上下文是抽象类，其将每个绘图操作都桥接到不同的具体实现类。</p><p>⑥ 绘图相关类的具体实现（不同的浏览器实现差别很大，可能涉及GPU等技术）。</p><p>⑦ 绘图实现类会将2D图形库和3D图形库绘制的结果保存并交由浏览器最终显示呈现。</p><p><div class="tip">需要注意的是，图示中的各个阶段对应的DOM树、RenderObject树和RenderLayer树等它们在整个过程中可能是<code>同时存在</code>的，并非RenderObject树建立后DOM树就会销毁，它们会一直并存直到整个网页销毁。另外，网页并非是渲染完成后整个过程就结束了，如果当前网页是动态的，支持动画和用户的交互行为，那么整个渲染过程其实是持续执行的。</div></p><h3 id="3-0-其它说明"><a href="#3-0-其它说明" class="headerlink" title="3.0 其它说明"></a>3.0 其它说明</h3><p><strong>Gecko引擎的渲染过程</strong></p><p>在<a href="http://wendingding.com/2018/06/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81HTML%E5%92%8C%E5%86%85%E6%A0%B8(%E5%BC%95%E6%93%8E" target="_blank" rel="external">浏览器、HTML和内核(引擎)</a>)这篇文章中，我们介绍了浏览器内核相关的信息，目前主流的内核主要有：Trident（IE内核）、Gecko (Firefox内核)、Webkit (Safari内核）、Blink（Chrome内核，基于WebKit）等,这里简单贴张图补充下<code>Gecko内核引擎的渲染过程</code>(注：图片来源于<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="external">How Browsers work</a>)。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader06.jpg?raw=true" height="150"></p><p><strong>DOM的DOMContentLoaded和onload事件</strong></p><p>通过浏览器内置的调试工具，我们点击<code>network网络监听调试</code>选项刷新当前页面可以查看当前网络请求加载的所有资源、资源的大小、类型、处理时间等信息，这里有必要单独谈一谈DOMContentLoaded事件和onload事件，下图中已经标出了触发的时间节点（所以强调是因为很多人不熟悉调试工具往往注意不到这些）。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/reader07.png?raw=true"></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文描述了HTML页面渲染的基本（一般）过程，需要说明的是该文并不包含关于HTML解释器、CSS解释器、JavaScript引擎等相关部分内部的具体处理细节。该文旨在简单介绍网页从加载到被我们看到过程中，由浏览器引擎处理部分（URL网络请求相关细节可以参考&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 DOM和DOM操作基础</title>
    <link href="https://weibo.com/u/3800117445/2018/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20DOM%E5%92%8CDOM%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://weibo.com/u/3800117445/2018/06/06/网络编程系列 DOM和DOM操作基础/</id>
    <published>2018-06-06T05:12:13.000Z</published>
    <updated>2018-06-11T02:04:44.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-0-关于DOM"><a href="#1-0-关于DOM" class="headerlink" title="1.0  关于DOM"></a>1.0  关于DOM</h3><p><strong>简单介绍</strong></p><p>DOM（全称为Document Object Model）即<strong><code>文档对象模型</code></strong>，<span style="color:#195">是用于表示和操作HTML或XML文档内容的一套基础API。</span></p><div class="tip"><br>✧ 有时候我们可能会看到DHTML这个专业术语：<span style="color:#195">DHTML是动画HTML的简称</span>，其并不是一项新的技术，而是描述HTML CSS JavaScript技术组合的术语。它曾被认为是HTML/XHTML CSS和JavaScript相结合的产物，像今天的HTML5，但真正凝聚它们的是DOM。<br></div><p>当网页被加载时，浏览器会内部的引擎会根据DOM模型，将结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点构建出一种树状结构（DOM Tree）。</p><p>下面给出一段简单的HTML示例代码和对应的DOM树结构图。图示中的的方框代表着文档中的一个个节点，每个方框（节点）暨一个Node对象，所有这些节点组成了DOM树。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM树演示代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"className"</span>&gt;</span>Hi! 文顶顶<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wendingding.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/dom1.png?raw=true"></p><p><strong>节点的类型</strong></p><p>HTML页面中拥有众多类型的节点，不同类型的节点其表示和操作的方式有很大的差异，下面分别列出：</p><blockquote><p>❏ Text：标签之间或标签包含的文本内容<br>❏ Comment：HTML或XML中的注释<br>❏ Element：网页的各种HTML标签，如a标签 div标签等<br>❏ Document：整个DOM树的根，代表整个文档<br>❏ Attribute：网页元素的属性节点<br>❏ DocumentType：文档类型（doctype）标签<br>❏ DocumentFragment：文档的片段，如果感觉费解请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="external">MDN-DocumentFragment</a></p></blockquote><p>尽管在HTML页面中存在着如此众多类型的节点，但我们真正需要关注的主要还是：<strong><code>元素节点</code></strong>、<strong><code>属性节点</code></strong>和<strong><code>文本节点</code></strong>。在(HTML|XHTML)文档中，文本节点总是被包含在元素节点的内部，属性节点用来对元素做出更具体的描述。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/dom2.png?raw=true"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在上面的图示中，我们提供了一个div标签，该标签拥有“上坡和下坡不就是同一条路吗”文本内容和两个属性节点。</div><div class="line">① 个div标签由开始标签和结尾标签组成，本身是Element类型的。</div><div class="line">② “上坡和下坡不就是同一条路吗”作为div标签的文本内容，本身是Text类型的。</div><div class="line">③ div标签中的class和title是属性节点(key-value)，本身是Attribute类型的。</div></pre></td></tr></table></figure><p><strong>节点关系</strong></p><p>DOM中节点的关系主要有以下几种情况</p><p><strong><code>子节点</code></strong> <strong><code>父节点</code></strong> <strong><code>后代节点(子孙节点)</code></strong> <strong><code>祖先节点</code></strong> <strong><code>兄弟节点</code></strong></p><h3 id="2-0-Node-amp-amp-Elemet-amp-amp-nodeType"><a href="#2-0-Node-amp-amp-Elemet-amp-amp-nodeType" class="headerlink" title="2.0 Node &amp;&amp; Elemet &amp;&amp; nodeType"></a>2.0 Node &amp;&amp; Elemet &amp;&amp; nodeType</h3><p><span style="color:red">Node（节点）和 Element（元素节点）是严格区分的</span>。也就是说Node和Element不能简单的混为一谈，因为很多人都搞不清楚它们的关系，所以这里单独拿出来讨论。</p><p><strong><code>Node</code></strong> 节点，表示构成DOM树的最小组成部分。换句话来说，在页面中不论是元素节点、文本节点还是注释或者别的东西本质上都是Node节点。</p><p><strong><code>Element</code></strong>元素节点，是Node节点中的一种类型。</p><p>通俗的来讲，node节点就像人一样，是一种基本的类型。（大哲学家柏拉图对人的定义是：人是两腿无毛会直立行走的动物  <span style="color:#0b0">：）</span> 而人这种基本类型中，又存在着小孩、中年人、老年人、学生、教师、司机、男人、女人等种种具体的类型。</p><p>对应到这里的关系，那么Element其实是node的一种更具体的类型。不止Element，像Text、Comment以及Attribute等等这些其实都是特殊的Node，它们拥有自己的类型常量（<span style="color:#f88">TEXT_NODE、COMMENT_NODE以及ATTRIBUTE_NODE</span>）用于区分彼此。</p><p>文档中所有的node节点都拥有nodeType属性，我们可以通过该属性的值来确定节点的具体类型，下面列出对应关系(标红的常量表示在DOM4中被废弃)。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/dom4.png?raw=true"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 可以直接在开发者工具的控制台中像下面这样检测和验证节点的类型</div><div class="line">document.body.nodeType     //输出结果为1</div><div class="line">document.body.ELEMENT_NODE                           //输出结果为1</div><div class="line">document.body.ELEMENT_NODE == document.body.nodeType //输出结果为true</div><div class="line"></div><div class="line"># 需要注意的是ELEMENT_NODE是常量</div></pre></td></tr></table></figure><p><strong>NodeList 和 HTMLCollection类型</strong></p><p>相信很多开发者都有这样的经验，<strong><span style="color:red">“我们通过节点的childNodes属性获取的结果和children属性获取的结果是不一样的”</span></strong>。下面我们通过一段简短的代码来说明它们的不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">&lt;div id=<span class="string">"demoID"</span>&gt;</div><div class="line">    我是测试的文字---A！！</div><div class="line">    &lt;div&gt;div1&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    &lt;div&gt;div2&lt;/</span>div&gt;</div><div class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"className"</span>&gt;div3&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    &lt;!--注释的内容:后面跟span标签--&gt;</span></div><div class="line"><span class="regexp">    &lt;span&gt;我是span&lt;/</span>span&gt;</div><div class="line">    我是测试的文字---B！！</div><div class="line">&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&lt;script&gt;</span></div><div class="line"><span class="regexp">    var oDiv = document.getElementById("demoID");</span></div><div class="line"><span class="regexp">    console.log("元素节点的children属性 == HTMLCollection类型");</span></div><div class="line"><span class="regexp">    console.log(oDiv.children);</span></div><div class="line"><span class="regexp">    console.log(oDiv.children.length);</span></div><div class="line"><span class="regexp">    console.log("元素节点的childNodes属性 ==  NodeList类型");</span></div><div class="line"><span class="regexp">    console.log(oDiv.childNodes);</span></div><div class="line"><span class="regexp">    console.log(oDiv.childNodes.length);</span></div><div class="line"><span class="regexp">&lt;/</span>script&gt;</div><div class="line">...</div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/dom5.png?raw=true"></p><p>通过代码的执行情况可以发现，元素节点(这里为id为demoID的div元素)的children属性得到的是HTMLCollection类型的伪数组，而childNodes属性得到的是NodeList型的伪数组。[<code>注意：它们是伪数组的结构，可以遍历但非真正意义上的数组</code>]。</p><p><span style="color:red">NodeList是Node集合，而HTMLCollection可以认为是Element的集合。</span></p><div class="tip">通常来说<span style="color:#195">Document和HTMLDocument</span>以及<span style="color:#195">Element类型与和HTMLElement类型</span>是严格区分的。Document类型代表一个HTML或XML文档，Element类型代表该文档中的一个元素。而HTMLDocument和HTMLElement通常只针对HTML文档和其元素。</div><h3 id="3-0-DOM操作基础"><a href="#3-0-DOM操作基础" class="headerlink" title="3.0 DOM操作基础"></a>3.0 DOM操作基础</h3><p><strong>Node（节点）的属性和方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">------------------------</div><div class="line">####  Node节点的主要属性</div><div class="line">------------------------</div><div class="line"></div><div class="line">baseURI    <span class="comment">// 当前网页的绝对路径</span></div><div class="line">children  <span class="comment">// 指定节点的所有Element子节点</span></div><div class="line">childNodes           <span class="comment">// 当前节点的所有子节点</span></div><div class="line">childElementCount          <span class="comment">// 当前节点所有Element子节点的数量</span></div><div class="line"></div><div class="line">nodeName   <span class="comment">// 节点名称[只读]</span></div><div class="line">nodeType   <span class="comment">// 节点类型的常数值[只读]</span></div><div class="line">nodeValue  <span class="comment">// Text或Comment节点的文本值[只读]</span></div><div class="line">innerText<span class="comment">// 节点的文本内容</span></div><div class="line">nextSibling          <span class="comment">// 紧跟在当前节点后面的第一个兄弟节点</span></div><div class="line">isConnected<span class="comment">// 布尔类型的值，用于检查当前节点与DOM树是否连接[只读]</span></div><div class="line">textContent          <span class="comment">// 当前节点和它的所有后代节点的文本内容</span></div><div class="line">ownerDocument          <span class="comment">// 当前节点所在的顶层文档对象，即Document</span></div><div class="line"></div><div class="line">previousSibling          <span class="comment">// 当前节点的前一个兄弟节点</span></div><div class="line">parentNode           <span class="comment">// 当前节点的父节点</span></div><div class="line">parentElement          <span class="comment">// 当前节点的父Element节点</span></div><div class="line">firstChild          <span class="comment">// 当前节点的第一个子节点</span></div><div class="line">firstElementChild          <span class="comment">// 当前节点的第一个Element子节点</span></div><div class="line">lastChild           <span class="comment">// 当前节点的最后一个子节点</span></div><div class="line">lastElementChild           <span class="comment">// 当前节点的最后一个Element子节点</span></div><div class="line"></div><div class="line">------------------------</div><div class="line">####  Node节点的主要方法</div><div class="line">------------------------</div><div class="line"></div><div class="line">cloneNode(<span class="keyword">true</span>);  <span class="comment">// 克隆节点，参数传递布尔类型的值（默认为false）</span></div><div class="line">hasChildNodes()   <span class="comment">// 布尔类型的值，表示当前节点是否有子节点</span></div><div class="line">appendChild(node)           <span class="comment">// 追加新的节点到当前节点中（插入后作为最后一个节点）</span></div><div class="line">removeChild(node)  <span class="comment">// 删除指定的子节点</span></div><div class="line">isEqualNode(noe)  <span class="comment">// 布尔类型的值，用于检查两个节点是否（完全）相等</span></div><div class="line">contains(node)  <span class="comment">// 布尔类型的值，用于判断参数节点是否为当前节点的后代节点</span></div><div class="line">normalize()   <span class="comment">// 清理当前节点内的所有Text节点，将去除空的文本节点并合并文本。</span></div><div class="line"></div><div class="line">insertBefore(newNode,oldNode)  <span class="comment">// 在指定子节点之前插入新的子节点</span></div><div class="line">replaceChild(newChild,oldChild) <span class="comment">// 替换节点</span></div><div class="line">compareDocumentPosition(node)   <span class="comment">// 比较当前节点与指定节点的位置关系，返回不同的掩码。</span></div><div class="line"></div><div class="line">------------------------</div><div class="line">####  ChildNode相关的方法</div><div class="line">------------------------</div><div class="line"></div><div class="line">ChildNode.replace()         <span class="comment">// 替换节点</span></div><div class="line">ChildNode.remove()          <span class="comment">// 将ChildNode从其父节点的子节点列表中移除</span></div><div class="line">ChildNode.before()          <span class="comment">// 在当前标签(节点)的前面插入新的节点</span></div><div class="line">ChildNode.after()           <span class="comment">// 在当前标签(节点)的后面插入新的节点</span></div></pre></td></tr></table></figure></p><p><strong>Element（元素节点）的属性和方法</strong></p><p><div class="tip">元素节点继承了Node的所有属性和方法，Element本身也作为通用的基类来使用。</div>下面列出元素节点的主要属性和方法，如果没有特别标注为[读写]的，那么默认为只读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">------------------------</div><div class="line">####  Element主要的属性</div><div class="line">------------------------</div><div class="line"></div><div class="line">id  <span class="comment">// 指定元素的id属性[读写]</span></div><div class="line">attributes          <span class="comment">// 指定元素节点相关的所有属性集合(映射)</span></div><div class="line">tagName  <span class="comment">// 指定元素节点的标签名（大写）</span></div><div class="line">innerHTML           <span class="comment">// 指定元素节点包含的节点内容[读写]，区别于innerText</span></div><div class="line">outerHTML  <span class="comment">// 指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素[读写]</span></div><div class="line">className  <span class="comment">// 元素节点的class属性值[读写]</span></div><div class="line">classList  <span class="comment">// 元素节点所有的class属性。</span></div><div class="line">dataset   <span class="comment">// 元素节点中所有的data-*属性。</span></div><div class="line">localName<span class="comment">// 元素名称本地化的结果</span></div><div class="line">clientTop           <span class="comment">// 元素节点距离它顶部边界的高度</span></div><div class="line">clientLeft           <span class="comment">// 元素节点距离它左边界的宽度</span></div><div class="line">clientHeight           <span class="comment">// 元素节点内部(相对于外层元素)的高度</span></div><div class="line">clientWidth           <span class="comment">// 元素节点内部(相对于外层元素)的宽度</span></div><div class="line"></div><div class="line">style  <span class="comment">// 元素节点的行内样式</span></div><div class="line">scrollHeight          <span class="comment">// 元素节点滚动视图的高度</span></div><div class="line">scrollWidth          <span class="comment">// 元素节点滚动视图的宽度</span></div><div class="line">scrollLeft           <span class="comment">// 元素节点横向滚动条距离左端的位移[读写]</span></div><div class="line">scrollTop           <span class="comment">// 元素节点纵向滚动条距离顶部的位移[读写]</span></div><div class="line">offsetHeight           <span class="comment">// 元素节点相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度</span></div><div class="line">offsetWidth            <span class="comment">// 元素节点相对于版面或由父坐标 offsetParent 属性指定的父坐标的宽度</span></div><div class="line">offsetLeft            <span class="comment">// 元素节点相对于版面或由父坐标 offsetParent 属性指定的父坐标的左侧位置位移</span></div><div class="line">offsetTop           <span class="comment">// 元素节点相对于版面或由父坐标 offsetParent 属性指定的父坐标的顶部位置位移</span></div><div class="line"></div><div class="line">firstElementChild<span class="comment">// 获取元素节点的第一个子元素</span></div><div class="line">lastElementChild <span class="comment">// 获取元素节点的最后一个子元素</span></div><div class="line">nextElementSibling <span class="comment">// 获取元素节点的下一个兄弟节点</span></div><div class="line">previousElementSibling        <span class="comment">// 获取元素节点的上一个兄弟节点</span></div><div class="line"></div><div class="line">------------------------</div><div class="line">####  Element主要的方法</div><div class="line">------------------------</div><div class="line"></div><div class="line">[⦿] 操作属性节点相关的方法</div><div class="line">getAttribute()<span class="comment">// 读取指定属性</span></div><div class="line">setAttribute()<span class="comment">// 设置指定属性</span></div><div class="line">hasAttribute()<span class="comment">// 返回布尔类型的值，检查当前元素节点中是否有指定的属性</span></div><div class="line">removeAttribute()<span class="comment">// 移除指定属性</span></div><div class="line"></div><div class="line">[⦿] 选择器相关方法</div><div class="line">querySelector()  <span class="comment">// 根据参数获取选中的所有标签中的第一个返回</span></div><div class="line">querySelectorAll()          <span class="comment">// 根据参数获取选中的所有标签返回</span></div><div class="line">getElementsByTagName()          <span class="comment">// 根据标签名来获取指定的标签返回</span></div><div class="line">getElementsByClassName()        <span class="comment">// 根据class的名称来获取指定的标签返回</span></div><div class="line"></div><div class="line">[⦿] 事件相关方法</div><div class="line">addEventListener()<span class="comment">// 添加事件监听的回调函数</span></div><div class="line">removeEventListener()        <span class="comment">// 移除事件监听函数</span></div><div class="line">dispatchEvent()<span class="comment">// 触发事件</span></div><div class="line">attachEvent()<span class="comment">// 添加事件监听的回调函数(IE 9-)</span></div><div class="line">detachEvent()                   <span class="comment">// 移除事件监听函数（IE 9-）</span></div><div class="line">insertAdjacentHTML()        <span class="comment">// 指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置</span></div></pre></td></tr></table></figure><p><strong>Document（文档）的属性和方法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">------------------------</div><div class="line">####  Document的主要属性</div><div class="line">------------------------</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body   <span class="comment">// 当前文档的&lt;body&gt;节点</span></div><div class="line"><span class="built_in">document</span>.head   <span class="comment">// 当前文档的&lt;head&gt;节点</span></div><div class="line"><span class="built_in">document</span>.defaultView           <span class="comment">// 当前文档对象所在的window对象</span></div><div class="line"><span class="built_in">document</span>.doctype   <span class="comment">// 当前文档关联的文档类型定义(DTD)</span></div><div class="line"><span class="built_in">document</span>.documentElement                <span class="comment">// 当前文档的根节点</span></div><div class="line"><span class="built_in">document</span>.activeElement          <span class="comment">// 当前文档中获得焦点的那个元素。</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.links  <span class="comment">// 当前文档的所有连接集合</span></div><div class="line"><span class="built_in">document</span>.forms  <span class="comment">// 页面中所有表单元素的集合</span></div><div class="line"><span class="built_in">document</span>.images  <span class="comment">// 页面中所有图片元素的集合</span></div><div class="line"><span class="built_in">document</span>.embeds  <span class="comment">// 网页中所有嵌入对象的集合</span></div><div class="line"><span class="built_in">document</span>.scripts  <span class="comment">// 当前文档的所有脚本的集合</span></div><div class="line"><span class="built_in">document</span>.styleSheets          <span class="comment">// 当前网页的所有样式表的集合</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.URL  <span class="comment">// 当前文档的URL地址</span></div><div class="line"><span class="built_in">document</span>.cookie   <span class="comment">// 用来操作Cookie[读写]</span></div><div class="line"><span class="built_in">document</span>.title    <span class="comment">// 当前文档的标题</span></div><div class="line"><span class="built_in">document</span>.domain  <span class="comment">// 当前文档的域名</span></div><div class="line"><span class="built_in">document</span>.referrer  <span class="comment">// 当前文档的访问来源</span></div><div class="line"><span class="built_in">document</span>.location  <span class="comment">// 获取location对象，提供与UR相关的L信息</span></div><div class="line"><span class="built_in">document</span>.readyState          <span class="comment">// 当前文档的状态</span></div><div class="line"><span class="built_in">document</span>.designMode          <span class="comment">// 控制当前文档是否可编辑[读写]</span></div><div class="line"><span class="built_in">document</span>.compatMode          <span class="comment">// 返回浏览器处理文档的模式</span></div><div class="line"><span class="built_in">document</span>.documentURI          <span class="comment">// 当前文档的URI地址</span></div><div class="line"><span class="built_in">document</span>.lastModified          <span class="comment">// 当前文档最后修改的时间戳</span></div><div class="line"><span class="built_in">document</span>.characterSet                   <span class="comment">// 当前文档的字符集，比如UTF-8等</span></div><div class="line"></div><div class="line">------------------------</div><div class="line">####  Document的主要方法</div><div class="line">------------------------</div><div class="line"></div><div class="line"><span class="built_in">document</span>.open()           <span class="comment">// 用于新建并打开一个文档</span></div><div class="line"><span class="built_in">document</span>.close()           <span class="comment">// 不安比open方法所新建的文档</span></div><div class="line"><span class="built_in">document</span>.write()           <span class="comment">// 用于向当前文档写入内容</span></div><div class="line"><span class="built_in">document</span>.writeIn()                  <span class="comment">// 用于向当前文档写入内容，尾部添加换行符</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.createEvent(type)   <span class="comment">// 创建事件对象</span></div><div class="line"><span class="built_in">document</span>.addEventListener()  <span class="comment">// 注册事件监听</span></div><div class="line"><span class="built_in">document</span>.removeEventListener()  <span class="comment">// 注销事件</span></div><div class="line"><span class="built_in">document</span>.dispatchEvent(event)  <span class="comment">// 触发事件</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.createElement(tagName)   <span class="comment">// 创建元素节点</span></div><div class="line"><span class="built_in">document</span>.createTextNode(text)     <span class="comment">// 创建文本节点</span></div><div class="line"><span class="built_in">document</span>.createAttribute(name)    <span class="comment">// 创建属性节点</span></div><div class="line"><span class="built_in">document</span>.createDocumentFragment()       <span class="comment">// 生成一个DocumentFragment对象</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(id)           <span class="comment">// 根据id值获取指定ID的元素节点返回</span></div><div class="line"><span class="built_in">document</span>.querySelector(selectors)   <span class="comment">// 根据选择器参数获取指定的所有标签中的第一个返回</span></div><div class="line"><span class="built_in">document</span>.querySelectorAll(selectors)    <span class="comment">// 根据选择器参数获取指定的所有标签返回</span></div><div class="line"><span class="built_in">document</span>.getElementsByTagName(tagName)  <span class="comment">// 根据标签名称获取指定的所有标签返回</span></div><div class="line"><span class="built_in">document</span>.getElementsByClassName(className)      <span class="comment">// 根据class名称获取指定的所有标签返回</span></div><div class="line"><span class="built_in">document</span>.getElementsByName(name)           <span class="comment">// 根据name参数获取拥有指定name属性的元素节点返回</span></div><div class="line"><span class="built_in">document</span>.elementFromPoint(x,y)         <span class="comment">// 返回位于页面指定位置最上层的Element子节点</span></div></pre></td></tr></table></figure></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-0-关于DOM&quot;&gt;&lt;a href=&quot;#1-0-关于DOM&quot; class=&quot;headerlink&quot; title=&quot;1.0  关于DOM&quot;&gt;&lt;/a&gt;1.0  关于DOM&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DOM（全称为Docu
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 浏览器、HTML和内核(引擎)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81HTML%E5%92%8C%E5%86%85%E6%A0%B8(%E5%BC%95%E6%93%8E)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/05/网络编程系列 浏览器、HTML和内核(引擎)/</id>
    <published>2018-06-05T03:11:13.000Z</published>
    <updated>2018-06-11T02:04:44.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-0-浏览器的发展和特性"><a href="#1-0-浏览器的发展和特性" class="headerlink" title="1.0 浏览器的发展和特性"></a>1.0 浏览器的发展和特性</h3><p><strong>浏览器的发展</strong></p><blockquote><p>浏览器的历史并不长，即便到今天来算也只有短短的27年，下面列出浏览器历史中的重要节点。</p></blockquote><p><strong>Tim Berners-Lee</strong> 在80年代末期90年代初期发明了世界上第一个浏览器<strong><code>WorldWideWeb(后改名Nexus)</code></strong>，并于1991年公布了源代码。该浏览器支持早期的HTML编辑语言，功能和实现简单但已经能够做到可视化网页内容，于1997年1月7日正式终止开发和支持。</p><p>1993年Marc Andreessen领导的团队开发了真正有影响力的<strong>Mosaic浏览器</strong>，这就是<strong><code>Netscape（网景）浏览器</code></strong>的前身，此时的网景浏览器虽然既没有JavaScript也没有CSS，只能简单的显示静态的HTML元素，但这不影响它在世界范围内取得巨大的成功。</p><p>1995年，受 Mosaic的深刻影响，微软推出了著名的<strong><code>Internet Explorer（IE浏览器）</code></strong>，IE根植于自家的操作系统，逐渐了取代网景的地位，随着网景浏览器的消亡，第一次浏览器大战(微软和网景)宣告结束。</p><p>1995年，Jon和Geir组建了OperaSoftwareASA公司(挪威)，1996年首次公开发布了<strong><code>Opera浏览器</code></strong>。</p><p>1998年，末路的网景公司成立了Mozilla基金会，并主导开发了开源的<strong><code>火狐浏览器(后更名为Firefox)</code></strong>，并于2004年发布1.0版本。因火狐浏览器功能丰富、扩展众多，其市场份额也逐年攀升。</p><p>2003年，苹果发布了<strong><code>Safari浏览器</code></strong>，并于2005年开源了Safari的内核<strong><code>Webkit</code></strong>，加入了第二次浏览器大战（<span style="color:#195">微软-苹果-Mozilla</span>）。</p><p>2008年，谷歌公司以苹果开源的<a href="https://webkit.org/" target="_blank" rel="external">WebKit</a>作为内核，创建了Chromium项目，目标是创建一个快速的、拥有多操作系统(包括桌面和移动端)支持的浏览器。在Chromium的基础上，谷歌发布了自己的浏览器产品<span style="color:#195">Chrome</span>。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/browser_01.png?raw=true"><span style="color:#195"><br>Safari和Chromium使用的都是苹果公司开源的Webkit内核，需要注意的是Chromium本身就是浏览器而不是内核，Chrome浏览器一般选择Chromium的稳定版本作为它的基础来实现。<br></span></p><p>桌面系统中：微软的IE和Mozilla的火狐以及谷歌的Chrome成为三足鼎立之势，它们几乎占据了90%的浏览器市场份额。</p><p>移动系统中：因苹果iOS操作系统和谷歌安卓系统在移动端中的统治地位，移动系统中的浏览器主要是Chrome和Safari二人转。</p><div class="tip">据<a href="https://netmarketshare.com" target="_blank" rel="external">NetMarketShare</a>最新公布的浏览器市场份额数据桌面系统市场份额排名前三的浏览器分别是：<span style="color:red">Chrome(61%)、Internet Explorer(12%) 和Firefox(11%)。</span><br> 移动系统市场份额排名前三的浏览器分别是：<span style="color:red">Chrome(62%)、Safari(27%) 和UC Browser(2.7%)</span>。<br> </div><p><strong>浏览器的特性</strong></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/browser.png?raw=true"></p><p>上图列出了现代浏览器的主要特性，包括网络处理、页面浏览以及多操作系统支持等功能，下面就一些重要的特性做简要说明。</p><p><strong><code>资源管理</code></strong>主要处理各种资源（下载的图片、视频等文件），包括缓存处理、重复下载检查等内容。</p><p><strong><code>开发工具</code></strong>该部分主要面向开发者，主要提供页面HTML元素审查、JavaScript代码调试等内容。</p><p><strong><code>插件扩展</code></strong> 插件和扩展机制是现代浏览器的重要特征，主流浏览器均支持各种形式的插件和功能扩展。</p><p><strong><code>账户同步</code></strong>主要用来同步用户的历史记录、书签等重要信息，为用户提供了多系统下的统一体验。</p><p><strong><code>网络处理</code></strong> 这是浏览器的核心功能，浏览器的账户同步、网页浏览等功能均需要不同程度的依赖于网络模块的处理。</p><p><strong><code>安全机制</code></strong> 该部分旨在提供安全的浏览器环境，包括但不限于显示用户访问网站是否安全、设置网站的安全级别、浏览器证书处理等内容。</p><p><strong><code>网页浏览</code></strong>这是浏览器最重要、最核心也最基本的功能，它通过调用网络模块下载互联网上的资源（网页）并通过资源管理器来获取资源并把它们转化为可视化的内容呈现给用户。</p><p><strong>浏览器的主要组件(结构)</strong></p><p>我们已经简单介绍了浏览器的特性（主要功能），其实作为浏览器来说它最核心的功能是<span style="color:red">通过向服务器发送请求并在得到响应后在浏览器窗口上显示对应的Web资源</span>，而浏览器解释和显示web资源的方式由HTML和CSS规范指定。</p><p><div class="tip"><br>web资源主要包括：<span style="color:#195">html文件 &amp;&amp; CSS文件 &amp;&amp; JS文件 &amp;&amp; 图片、PDF等资源。</span></div><img src="https://github.com/flowerField/Source/blob/master/Blog/html4.png?raw=true"></p><p>上图展示了浏览器的主要组件，下面简单说明。</p><p><strong><code>用户界面</code></strong> 包括地址栏，后退/前进按钮，书签菜单等部分。<br><strong><code>渲染引擎</code></strong> 负责显示网络请求得到的内容。<br><strong><code>网络模块</code></strong> 用于网络请求等处里，与具体的平台无关。<br><strong><code>UI后端</code></strong> 用于绘制组合框和窗口等基本UI部件。<br><strong><code>数据存储</code></strong>用于存储和处理浏览器使用中的必要数据。<br><strong><code>浏览器引擎</code></strong> 浏览器最核心的部分。<br><strong><code>JavaScript解释器</code></strong>用于解析和执行JavaScript代码。</p><p><div class="tip"><br>小贴士：chrome浏览器可以通过在地址栏中输入<span style="color:#195">chrome://version/</span>来查看相关版本信息<br></div>譬如，我所使用的Chrome浏览器相关信息如下<br><img src="https://github.com/flowerField/Source/blob/master/Blog/html9.png?raw=true"></p><h3 id="2-0-HTML的发展和特性"><a href="#2-0-HTML的发展和特性" class="headerlink" title="2.0 HTML的发展和特性"></a>2.0 HTML的发展和特性</h3><p><strong>HTML的发展</strong></p><blockquote><p>HTML（HpperText Markup Language）超文本标记语言，用于网页的创建和显示。现已经发展为HTML5，下面列出HTML发展过程中的关键节点。</p></blockquote><p>1991年，<strong><code>Tim Berners-Lee</code></strong>编写了一份叫做“HTML标签”的文档，里面包含了大约20个用来标记网页的HTML标签，里面直接借用了SGML的标记格式，用于在浏览器中表示文字等信息。</p><p>1993年6月作为IETF（互联网工程工作小组）发布了HTML的草案（并非标准）。后来，<a href="https://www.w3.org/" target="_blank" rel="external">W3C组织,全称World Wide Web Consortium万维网联盟</a>取代IETF的角色，成为HTML的标准组织。</p><p>1997年12月18日，W3C发布<strong><code>HTML 4.0</code></strong>推荐标准。</p><p>1999年12月24日，W3C发布<strong><code>HTML4.0.1</code></strong>推荐标准。</p><p>HTML 4.0.1发布后，HTML到达了一个拐点，这之后很长时间里HTML的发展走向了另外的方向。</p><p>2000年1月26日，W3C发布了<strong><code>XHTML1.0</code></strong>，这是在HTML 4.01之后的第一个修订版本，其中X代表“EXtensible”，扩展的意思。新的标准并没有引入任何新标签或属性，而是要求使用XML般的严格语法，被称为XML风格的HTML。</p><p>XHTML1.0的推出刚好碰上了CSS的崛起，Web开发设计者们开始意识到Web标准问题，基于XHTML的严格语法规范被视为编写 HTML代码的最佳实践。</p><p>2001年5月31日，W3C发布了<strong><code>XHTML1.1</code></strong>。如果说XHTML 1.0是XML风格的HTML，那么XHTML 1.1则是货真价实的XML。这意味着XHTML 1.1无法使用<strong><code>text/html MIMEType</code></strong>直接输出，而如果Web开发者使用<strong><code>XML MIMEType</code></strong>，则当时的主流浏览器压根不支持。看上去，W3C似乎正在与当时的Web脱节。</p><p>2002年8月5日，W3C发布了<strong><code>XHTML 2.0</code></strong>工作草案，XHTML 2不向前兼容，甚至不兼容之前的HTML，它是一种全新的语言。现在来看这实在是一场灾难，这是吃力不讨好的无用功。</p><p>W3C闭门造车的作风导致Opera，苹果以及Mozilla的代表们开始发出反对声音。2004年，Opera的 Ian Hickson提议在HTML基础上进行扩展以适应新的Web应用，该提议遭到W3C的拒绝。于是，他们自发组织成立了超文本应用技术工作组(Web Hypertext Application Technology Working Group)<a href="https://whatwg.org/" target="_blank" rel="external">WHATWG</a>。WHATWG和W3C组织开始在HTML发展的这条路上走向了不同的方向。</p><p>WHATWG组织的主要工作包括两部分，<strong><code>Web Forms 2.0和Web Apps 1.0</code></strong>，它们都是HTML的扩展，后来合并到一起成为现在的HTML 5规范。</p><p>在WHATWG致力于HTML5的同时，W3C继续他们的XHTML 2.0，然而，他们慢慢地陷入困境。2006年10月，<strong><code>Tim Berners-Lee</code></strong>发表了一篇博客文章，表示从HTML走向XML的路是行不通的，几个月后（2007年）W3C组建了一个新的HTML工作组，他们非常明智地选择了WHATWG的成果作为基础来立项HTML 5。也就是说，W3C同时在进行着两套规范，XHTML 2.0 和HTML 5，而WHATWG也在进行着HTML5规范的工作。</p><p><span style="color:red">2012年，HTML 5被两大组织WHATWG和W3C接纳为候选标准。好在经过长达八年的扯皮和博弈之后，2014年10月底W3C宣布HTML5正式定稿。</span></p><p>纵观HTML5的发展史，有用户的需求在推动，有技术开发者的需求在推动，更有巨大的商业利益在推动，关于HTML5发展史中的博弈可以参考<a href="https://www.cnblogs.com/yy-hh/p/4509748.html" target="_blank" rel="external">html5的发展历程和由此引起的政治斗争</a>。下面给出HTML发展的主要节点图示。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html.png?raw=true"></p><p><strong>HTML5的特性</strong></p><p>HTML5包含了一系列的标准，其构建思想和前瞻性意义深远。更重要的是，HTML5不仅仅可以用来构建内容更丰富的网页，更对作为平台来开发提供了能力支持。当前，所能在W3C官网找到的HTML5最新版本为2018年4月26日发布的<a href="https://www.w3.org/TR/2018/WD-html53-20180426/" target="_blank" rel="external">HTML 5.3工作草案</a>,也可以在<a href="https://github.com/w3c/html" target="_blank" rel="external">W3C组织github发布页</a>查看详情。</p><p>HTML5标准大概可以分为10个类别，它们分别是Offline（离线）、Storage（存储）、Connectivity（连接）、File access（文件访问）、audio/video（音频和视频）、3D/graphics（3D和图形）、presentation（展示）、performance（性能）、semantics（语义）和Nuts and bolts（其它）。其中每个类别都由众多的技术和规范组成。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html2.png?raw=true"></p><p>更对关于HTML5规范的说明可以参考<a href="https://www.w3.org/" target="_blank" rel="external">W3C官网</a>或者<a href="http://www.chinaw3c.org/" target="_blank" rel="external">W3C中国</a>或者<a href="http://blog.shaochuancs.com/" target="_blank" rel="external">HTML5标准阅读技术博客</a></p><p><strong>单独说说HTML5</strong></p><p>现在我们都知道2007年的时候，W3C开始从WHATWG接手相关工作，重新开始发展HTML5。W3C为什么突然决定重新发展HTML5，推动新标准呢？我们可以试着从三个方面来试着分析。</p><p><span style="border:1px solid #000">&nbsp;用户需求的推动</span></p><p>在2005年左右的时候，互联网的发展进入到新的时期。随着宽带的普及和电脑硬件的发展和性能增强，消费者不单单通过互联网来浏览网页、收发邮件，流媒体和网页游戏开始进入到用户的视野。</p><p>对于这块需求，由于当时的HTML标准并没有把握住互联网产业的变化及时演进，相关的浏览器产品也没有升级，因此这块新需求就自然被浏览器插件满足了，那就是Flash。这个部署在亿万浏览器里的商业插件俨然成为了事实标准。</p><p><span style="border:1px solid #000">&nbsp;技术需求和商业利益的推动&nbsp;</span></p><p>2005年<a href="http://tech.sina.com.cn/focus/Adobe_Mm/" target="_blank" rel="external">Adobe花费34亿美元巨资收购Macromedia</a>，把Flash收归旗下，紧接着大幅推广FLV流媒体。</p><p>除Flash这个商业产品成为了事实标准外，W3C当时还面临着另外的尴尬，那就是私有扩展协议的制造者IE。IE当时在桌面浏览器占有垄断地位，并且扩展了大量的IE 私有语法，开发者完全不知道这些语言是谁定义的。基于上面的事实，当时的情况是整个web世界，都被微软和Adobe这两家公司捆绑了。于是以苹果和谷歌为代表的很多IT巨头开始行动起来，既然大家都是W3C的主席单位，好吧，那我们就重新开始做HTML5吧。</p><p>HTML5其实就是这么诞生的，所以<span style="color:red">2007年，其实也是IE和Flash由盛转衰的转折点</span>。HTML5的发展大体经历了<span style="color:red">Web增强</span>和<span style="color:red">移动互联网</span>两个阶段，而现今我们看到的是属于HTML5的春天。需要注意的是虽然HTML5意义深远，但目前来说并非所有浏览器都对HTML5提供100%的支持，我们可以通过<a href="http://html5test.com/" target="_blank" rel="external">HTML5TEST</a>网站来查看各浏览器对HTML5特性的支持情况。</p><h3 id="3-0-浏览器内核（渲染引擎）"><a href="#3-0-浏览器内核（渲染引擎）" class="headerlink" title="3.0 浏览器内核（渲染引擎）"></a>3.0 浏览器内核（渲染引擎）</h3><p><strong>浏览器内核简单介绍</strong></p><p>浏览器内核作为浏览器中最重要的模块，其核心作用是将页面转换为可视化的结果。浏览器内核一般分成<code>渲染引擎(layout engineer 或者 Rendering Engine)</code>和<code>JS 引擎</code>两部分，只是通常我们总是把渲染引擎称之为内核，习惯把JS引擎区分开来单独说明。</p><p><strong><code>渲染</code></strong>指的是根据描述或定义构建模型，通过模型生成可视化图像的过程。</p><p><strong><code>渲染引擎</code></strong>指的是浏览器中能够将HTML/CSS文本及其相关的资源文件转换为图像结果的模块。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html6.png?raw=true"></p><p>目前，主流浏览器的渲染引擎主要有Trident（IE内核）、Gecko (Firefox内核)、Webkit (Safari内核）、Blink（Chrome内核）等，其中Blink其实是从WebKit的分支Fork出来的，下表列出了部分浏览器和内核的对应关系。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html5.png?raw=true"></p><p>关于浏览器内核演进和发展的历史比较复杂，这里给出主流内核的发布时间节点和家谱关系图。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html7.png?raw=true"></p><p>浏览器和内核相关的更多信息，请参考<a href="https://liulanmi.com/" target="_blank" rel="external">浏览迷官网</a>或者<a href="http://www.infoq.com/cn/news/2013/02/webkit-history-and-now" target="_blank" rel="external">WebKit的前世今生</a>或者<a href="从KHTML到WebKit，再到Blink">从KHTML到WebKit，再到Blink</a>或者<a href="http://web.jobbole.com/84826/" target="_blank" rel="external">主流浏览器内核介绍</a>。</p><p><strong>渲染引擎的工作流程和主要特征</strong></p><p>浏览器内核渲染引擎工作的主要流程如下图所示：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html8.png?raw=true"></p><blockquote><p><strong>渲染引擎工作流程说明</strong></p><p>① 解析HTML并构造DOM树（Parsing HTML to Construct the DOM tree）<br>② 构造渲染树（Render Tree construction）<br>③ 布局渲染树（layout of the render tree）<br>④ 绘制渲染树（Painting the render tree）</p></blockquote><p><strong>渲染引擎的特征</strong></p><p>如果按照具体的功能处理来划分，那么渲染引擎主要包括<span style="color:red">HTML解释器、CSS解释器、JavaScript引擎以及布局和绘图</span>等模块，以及这些模块和基础模块(渲染引擎需要依赖的如网络、存储、音频|视频等底层模块)调用相关的部分。下面给出渲染引擎的构成模块已经依赖的底层模块关系图。<br>                                                                                     <img src="https://github.com/flowerField/Source/blob/master/Blog/html10.png?raw=true"></p><p><strong><code>HTML解释器</code></strong> 用于解释HTML的文本，主要用于将HTML文本解释成DOM树，DOM（文档对象模型）是一种用来表示文档的树状结构。</p><p><strong><code>CSS解释器</code></strong>级联样式表的解释器用于为DOM树中的各元素对象(Node)计算出样式信息，为网页的最终布局做好准备工作。</p><p><strong><code>JavaScript引擎</code></strong>JavaScript脚本语言把网页带到了全新的世界，JavaScript引擎能够解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页的内容和样式信息，从而影响渲染结果。</p><p><strong><code>布局和绘图(Layout)</code></strong>在DOM创建后，需要把页面中的元素对象和样式信息结合在一起并计算出大小、位置等布局信息。根据这些信息先构成用于表示页面的内部表示模型（渲染模型），然后调用图形库来绘制所有的节点并最终得到我们看到的网页视图（图片）。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-0-浏览器的发展和特性&quot;&gt;&lt;a href=&quot;#1-0-浏览器的发展和特性&quot; class=&quot;headerlink&quot; title=&quot;1.0 浏览器的发展和特性&quot;&gt;&lt;/a&gt;1.0 浏览器的发展和特性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;浏览器的发展&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [011]-空谷幽兰</title>
    <link href="https://weibo.com/u/3800117445/2018/05/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B011%5D-%E7%A9%BA%E8%B0%B7%E5%B9%BD%E5%85%B0/"/>
    <id>https://weibo.com/u/3800117445/2018/05/25/读书笔记 [011]-空谷幽兰/</id>
    <published>2018-05-25T00:11:18.000Z</published>
    <updated>2018-06-11T02:08:44.865Z</updated>
    
    <content type="html"><![CDATA[<div style="color:#195; font-size:20px">※·※序言 (空谷幽兰)※·※</div><p>比尔·波特1972年去往台湾。<br>天亮前起来诵经，夜晚听钟声，一日三餐素食，一个房间，一张床，一顶蚊帐，没有钞票。如果我的腿太痛，我就读书。</p><p>天地就在身边，死亡近在咫尺。<br>遵循严格的戒律，戒律就是自己对自己的要求。戒律是修行成为可能。如果你对自己不做要求，修行就会一无所获。</p><p>道教徒和佛教徒追求的是不变的东西，这是他们不追名逐利的原因。</p><div style="color:#195; font-size:20px">※·※ 第一章 隐士的天堂 ※·※</div><p>在整个中国的历史上，一直就有人愿意在山里度过他们的一生：吃的很少，穿得很破，睡的是茅屋，在高山上垦荒，说话不多，留下来的文字更少——也许只有几首诗、一两个仙方什么的。他们与时代脱节，却并不与季节脱节；他们弃平原之尘埃而取高山之烟霞；他们历史悠久，而又默默无闻——他们孕育了精神生活之根，是这个世界上最古老的社会中最受尊敬的人。</p><p>中国人一直很崇敬隐士，没有人曾对此做出过解释，也没有人要求解释。隐士就那么存在着：在城墙外，在大山里，雪后飘着几缕孤独的炊烟。从有文字记载的时候起，中国就已经有了隐士。</p><p>只有当我们独处的时候，我们才会更清楚的意识到，我们与万物同在。</p><p>1972年开始了解中国的隐士传统。从美国搬到了台湾。<br>三年后，结束了寺院生活，隐居在竹子湖山村，并翻译一些隐士的著作。<br>1987年冬天，台湾到中国大陆旅游的禁令解除。<br>1989年春天，获得赞助同朋友史蒂芬·约翰逊成行，前往中国大陆寻找隐士。</p><p>两星期后，在香港碰头，然后一起飞往北京。<br>第二天，参观了广济寺，此乃中国佛教协会所在地。我问佛协的副会长周绍良，他是否知道可以到哪里找到几个隐士。他还没来得及回答这个问题，广济寺的方丈净慧法师说，他曾经听说过西安附近的终南山里有隐士。</p><p>两天后，参观完长城，回到北京。<br>通过火车这种交通工具去往北京西北的中国古代佛教中心大同。<br>第二天早晨，到达大同。<br>第二天，第一次冒险进入农村，去游览恒山，没有发现任何有隐士居住的迹象。<br>次日，动身前往五台山，我们想那儿可能有隐士居住。</p><p><span style="color:red">可是事实却并非如此。视野里几乎没有一棵树。我推断：没有森林就没有枯枝，没有枯枝就没有木柴，没有木柴就没有茶，没有茶就没有禅，没有禅就没有隐士。</span></p><p>他们先后向我保证，如今所有的和尚和尼师都生活在寺庙里。据他们所知，五台山或中国其他任何山上，都没有隐士。</p><p>接着花了几天的时间游览西安，之后去参观了最后一个地方：草堂寺。</p><p>领我们参观了寺庙的庭院之后，方丈把我们带到他的方丈室里。我告诉他，我们正在寻找隐士。此时，他的几个弟子也拥进屋里。他看看他们，然后看看我，最后说：“我对隐士的事情一无所知。但是既然你们远道来了，为什么不参拜一下路边的小砖塔呢？”<br>我们从山后的小路下山。<br>我们发现了隐士的天堂。临走前，我问一位和尚这些山的名字。他说：“这里是终南山。这儿是真修行的出家人来的地方。”</p><p>在过去的三十年里，中国国内和国外的观察家们都断言，这场运动是一个巨大的成功，它彻底清除了人民群众的精神鸦片和迷信。大多数观察家已经把佛教视为死去的宗教。</p><p>动身前两个星期，台湾陆委会行政秘书告诉我，共产党早就把大陆上的隐士连同真正的出家人都“消灭”光了。</p><p>他们的微笑，使我们觉得自己遇见了中国最幸福、最有智慧的人。</p><p>我们所考察的山中，有一座叫太姥山，就在福建省东北部。</p><p>太姥山上五十年。修行方式是持名念佛，念阿弥陀佛。</p><div class="tip">(注)主要行动路线。太姥山—(公共汽车)—&gt;福州—(公共汽车)—&gt;厦门—(船)—&gt;香港——&gt;台湾。</div><div style="color:#195; font-size:20px">※·※ 第二章 月亮山 ※·※</div><p>当我头一次听说终南山的时候，我既不知道它们的位置，也不了解他们的重要性。</p><p>名词是不变化的，因此无法区分单复数，所以我仍然不知道，终南山是指一座山，还是指一列山脉。几天之后，我发现，它既指一座山，又指一列山脉。回到台湾以后，我了解到，它所指的远远不仅是山脉。</p><div class="tip">秦岭-终南山-南山-昆仑-中南山脉-萨满。</div><br>隐士传统之所以能够延续，是因为中国人一向尊重过去，而隐士则保持了那个“过去”最重要的因素——它的精神传统。<br><br><div style="color:#195; font-size:20px">※·※ 第三章 举世皆浊 ※·※</div><p>修道意味着孤独的生活或者是从政生涯。<br>屈原是中国历史上第一位伟大的诗人。大约公元前300年左右，他以三闾大夫的身份供职于楚国宫廷。</p><p>屈原没能称为一位隐士，他拒绝了渔父的建议，跳进了汨罗江。</p><p>每年的阴历五月初五，中国人仍然画着龙舟去捞救屈原。人们往水里扔粽子，好让鱼龙乱作一团，以争取时间，使龙舟能够追上屈原。但是，不管人们怎样努力，诗人依旧年年沉水——只苦了中国的江河，变得越来越浑浊了。</p><p>道德和政治之间的矛盾是隐士传统的核心。</p><p>张良和诸葛亮是两位著名的隐士。</p><p>隐居和从政被看做是月亮的黑暗和光明，不可分而又互补。隐士和官员常常是同一个人，只是在他声明中的不同时期，有时候是隐士，有时候是官员罢了。</p><p>当中国的第一位伟大的诗人从宫廷中被放逐出来的时候，他自沉而葬身于鱼腹；中国第二位伟大的诗人陶渊明则还没有等到任期结束，就隐居到了乡下。在中国，隐士们有一种解脱自在的精神，即保持心灵而不是身体远离城市的尘嚣。</p><div style="color:#195; font-size:20px">※·※ 第四章 访道 ※·※</div><p>道德经是道教最早的经典，迄今为止还没有哪一种对道的解释能够超过它。</p><p>中国的警察就像北欧神话中的巨人。不管在哪里，警察检查一次，一般都要花上二十元到一百元人民币。</p><p>祖庵村是重阳宫的所在地，重阳宫是中国过去最著名的道教圣地之一，它建于13世纪，供奉的是道教全真派的创始人王重阳。</p><p>从那以后，王重阳在这里度过了七年的时光。他和吕洞宾、汉钟离三个人一起生活在一个岩洞里，那个岩洞，王重阳称之为“活死人墓”。</p><div style="color:#195; font-size:20px">※·※ 第五章 鹤之声 ※·※</div><p>如道教徒所宣称的，道教的历史形态可能起源于终南山西部的楼观台。</p><p>玉泉院是一座道观，建于11世纪中期，是为了纪念陈抟而修建的。在院基的东面，有华佗墓。</p><p>仙姑观这里是谢道长住的地方，我们找到他的时候，他正在床上支着身体，用一盏热灯烤膝盖，治疗关节炎。他曾经以武功而闻名于世，现在却连走路都有点困难了。</p><p>他的身子骨异常硬朗，心清澈得就像久雨后的天空。</p><p>他们都怎么啦？<br>有些人死了，很多人走了。还有很多人还俗了。<br>道观怎么样呢？<br>道观里挤满了游客。什么都变了，现在旅游局管着道观了。</p><p>我舒展着四肢，躺在树荫底下，看着天上的云，不知道从什么地方飘来，然后又消失在无何有之乡。</p><p><span style="color:red">对危险的清醒认识能够使人全神贯注。</span><br>如果你准备要学道，你不必去找师父，师父会找你的。道是不可以言传的，悟道前你必须修行。悟是自然发生的，对每个人来说都是不同的，主要是清心寡欲。修行要花很长时间，所以你必须保持身体健康。如果你有很多念头和欲望，你就活不到实现目标的时候。</p><p>大部分师父在他们一生中，只把核心的秘密传授给一位弟子，而且大师们都已经隐居到山的更深处去了，拒绝在这个物质时代教化人。他说，道观里的教导是肤浅的。</p><p>仙鹤在道教中是变化、超越、洒脱、纯洁和长寿的象征。用它来代表华山是再完美不过的了。可是很显然，这只鹤已经飞走了。</p><p>半路上，我的腿因为精疲力尽和恐惧而开始发抖，我问向导还有多远。他说，两个小时，然后指指就在白云下的那个崖顶。当他刚才告诉我们苏道长的岩洞不远的时候，我忘了问他到底有多远。</p><div style="color:#195; font-size:20px">※·※ 第六章  登天之道 ※·※</div><p>道教徒寻求的是修成一个长生不死之身，而佛教徒寻求的是摆脱一切身相。</p><p>在中国出现的八大佛教宗派中，有七个宗派是在终南山里或者是其附近开出它们的第一片花瓣的。它们是三论宗、唯识宗、律宗、净土宗、华严宗、密宗和禅宗。</p><p>在古代，蓝田地区以产玉而著名（道教徒们追求长生不死的过程中所使用的一种矿物）现在变成铀了。两种不同的矿物，都能把人送上天堂。</p><p>我问续洞主持天气是不是太冷了，香蕉能结果吗，他说，他种这几棵香蕉树只是为了好玩。我点点头。在台湾，我也在自己的窗外种了一棵，也只是为了好玩——为了听夏雨打在芭蕉叶上的声音。</p><p>在禅宗里，我们不停的问，谁在念佛。<br>在净土宗里，我们只是念佛号，再也没有什么了。所有的法门都适合，法无对错，修行的差别只是根基的问题。法门就像糖，人们喜欢不同种类的糖，但是它只是糖，法是空的。</p><p>为什么这么多人来到终南山修行？<br>终南山一直延伸到印度，最初的和尚们来中国的时候，他们就定居在终南山里。另外，这一带仍然有很多的在家人，愿意供养来修行的人。</p><p>不管鸠摩罗什是在哪里工作的，一千六百年来，他所翻译的经文，无论是在风格上还是在语法上，都再也没有人能够超过他。</p><p>如果不过一种合乎正道的生活，就什么也成就不了。</p><p>实际上，住在净业寺的八九位和尚中，有三位是北大中文系的毕业生。我惊诧于年轻出家人受教育程度之高。</p><p>旅游已经把少林寺变成了一座养老院，任何呆在那里的人，都被认为对名闻利养比对佛法更感兴趣。</p><p>如果你修行，你就会有所得，如果你不修行，你就会一无所获。</p><div style="color:#195; font-size:20px">※·※ 第七章 云中君 ※·※</div><p>西安现在仍然是一个旅行者的城市，与此相协调的，它的城市标志是一只大雁。</p><p>曲水流觞的游戏，起源于曲江池（长安八景之一）。</p><p>王宝钏和薛平贵的故事，寒窑。</p><p>我用望眼镜浏览了一下周围的平原，到处都是坟墓。</p><p>兴教寺和玄奘塔。兴教寺的匾额由康有为1923年题写。</p><p>禅宗的和尚不念经。</p><p>您修哪个法门？念佛还是坐禅？<br>答：我只是随缘度日。</p><p>人们来参观的时候，你教他们佛法吗？<br>答：不一定，每个人都不一样。要教他们，你必须了解对方心里在想什么，而且你得有些能力。如果有人要淹死了，而你不会游泳，那么你跳下去没有任何好处。如果一个人不想被拯救，你就救不了他，他必须愿意被拯救。</p><div style="color:#195; font-size:20px">※·※ 第八章 朱雀山 ※·※</div><p>在中国的古代，每个方向都有自己的神：东方青龙，北方玄武，西方白虎，南方朱雀。最早使用这些字眼的书是《山海经》。</p><div class="tip">作者记录了时任中国国家气功团团长何建新给自己治疗疹子的事情，非常有意思。</div><p>我登了记，付了相当昂贵的医药费——三十元人民币，也就是六美元。</p><p>他让我站着，两腿分开，闭上眼睛，然后开始围着我转圈，哼哼着，用他体内气的运动，发出搅动声和嘶嘶声。这样做了几分钟之后，他让我坐下来，然后开始往我体内扎针灸用的针：在我的拇指和食指之间，脖子后面、胳膊上、膝盖上以及脚裸上然后他让我闭上眼睛呼气，我仿佛是一只被针扎了的轮胎。</p><p>当我坐在那里漏气的时候，他给其他病人治疗，偶尔回来捻弄一下那些针，并喊叫着把他的气泼洒在四周。最后，他给我开了一种草药，两天后疹子消失了。</p><p>杨虎城将军墓.<br>公元712年，杜甫出生在临近的河南省，但是他的祖祖辈辈却住在长安南面的少陵原，后来他的创作高峰期大部分是在这里度过的。实际上，他把自己称为少陵野老，并把他的诗集用少陵来命名。</p><p>将军的生活过的比这个国家最伟大的诗人好。</p><p>法不是片面的，你必须修所有的法。在禅宗里，你没有念头。在净土宗里，你有一个念头。它们都是一样的。他们的目的都是要把你的本来面目指给你看。</p><p>印光和虚云被认为是二十世纪最伟大的大师之一。虚云革新了中国禅宗，与此同时，印光革新了净土宗。听过他讲法的人都说，那些讲法是空前绝后的。</p><p>19世纪末，去顶峰的沿途还有七十二座寺庙。现在只剩下五座了，而且都是重修的。20世纪60年代，当文革席卷中国的时候，所有站着的东西都被红卫兵打到了。</p><p>旅馆是最贱在刘澜涛避暑别墅的遗址上建立起来的。文革前，刘澜涛是中国西北五省的中共书记，也是中国最有权力的任务之一。文革时，他被打成了走资派。我对刘澜涛选择风景的眼光表示欣赏。</p><p>修行要靠个人，真修行的人太少了。我不怎么修行，我晚上打坐，白天干杂活儿，我只是在照管这座庙。</p><div style="color:#195; font-size:20px">※·※ 第九章 走过销魂桥 ※·※</div><p>灞河和灞桥。<br>汉文帝：一位罕见的国君，他只想过得像隐士一样快活，他对于俭朴的热爱几乎是传奇性的，他在宫廷里穿草鞋。<br>梁鸿和韩康。</p><p>坑儒谷：文革期间，红卫兵们很喜欢提示知识分子坑儒谷的存在。<br>刘邦和项羽。<br>鸿门和骊山。<br>骊山最主要也最著名的温泉叫华清池。<br>西安事变——捉蒋亭。<br>唐玄宗和杨贵妃。<br>女娲是伏羲的妹妹和妻子。</p><p>道没有名字，修道就意味着回归于无。<br>当人们努力去寻找道的时候，他们就失去了道。他们混淆了有和无。我们所做的一切只是修德，包括我们的精神、我们的心还有想法。</p><p>陈道长是一个很少见的头脑清晰、心直口快的道士。他说完了想说的话，就要干杂活儿去了，</p><p>菩提达摩的眼皮：一千五百年前，菩提达摩为了防止坐禅时睡着，把眼皮割掉了。他的眼皮落地的地方，长出了第一批茶树。</p><p>在中央展厅里，我突然发现自己站在释迦摩尼佛的舍利前。</p><p>公元7世纪，当玄奘大师从印度回长安的时候，在他所带回的物品中，有五百颗释迦摩尼佛的舍利。</p><p><span style="color:red">当一具普通的肉体被焚烧以后，剩下来的只有碎骨头片和灰烬。当一个修行人的遗体被焚烧以后，人们就会找到一些像玻璃或者是瓷器一样的小石头。释迦摩尼佛的舍利到达中国以后，它们被放进两只小玻璃瓶中。这两只小玻璃瓶又被放进一只小金盒里，然后这只金盒又被放进一只镶着白银和母珠的大盒子里，最后人们才把这只大盒子安放在那座小石塔里。<span></span></span></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※序言 (空谷幽兰)※·※&lt;/div&gt;

&lt;p&gt;比尔·波特1972年去往台湾。&lt;br&gt;天亮前起来诵经，夜晚听钟声，一日三餐素食，一个房间，一张床，一顶蚊帐，没有钞票。如果我的腿太痛，我就读书。&lt;/
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[04]-Grunt构建工具的使用进阶</title>
    <link href="https://weibo.com/u/3800117445/2018/05/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B04%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/05/21/前端工程化系列[04] Grunt构建工具的使用进阶/</id>
    <published>2018-05-21T05:12:13.000Z</published>
    <updated>2018-06-11T02:04:44.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">前端工程化系列[02]-Grunt构建工具的基本使用</a>和<a href="http://wendingding.com/2018/05/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[03]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" target="_blank" rel="external">前端工程化系列[03]-Grunt构建工具的运转机制</a>这两篇文章中，我们对Grunt以及Grunt插件的使用已经有了初步的认识，并探讨了Grunt的主要组件以及它的运转机制，这篇文章是Grunt使用的进阶教程，主要输出以下内容：</p><p>❏ &nbsp;<span style="color:#f25">Grunt项目的自定义任务</span><br>❏ &nbsp;<span style="color:#f25">Grunt任务的描述和依赖</span><br>❏ &nbsp;<span style="color:#f25">Grunt多目标任务和选项</span><br>❏ &nbsp;<span style="color:#f25">Grunt项目任务模板配置</span><br>❏ &nbsp;<span style="color:#f25">Grunt自动化构建和监听</span></p></blockquote><h3 id="3-1-Grunt自定义任务"><a href="#3-1-Grunt自定义任务" class="headerlink" title="3.1 Grunt自定义任务"></a>3.1 Grunt自定义任务</h3><p>在使用Grunt的时候，可以先到Grunt官网的插件列表搜索是否有适合自己项目的Grunt插件，如果有那么建议直接使用，如果没有那么开发者可以尝试自定义任务或者是自己创建对应的插件。Grunt的插件其实就是一些封装好的任务(Task)，没有什么稀奇的，Grunt支持自定义任务，而且方式非常简单。</p><p>如果我们需要定义一个任务，向控制台里输出字符串信息，那么在package.json文件、Gruntfile文件已经创建且grunt本地依赖已安装的前提下，如下编辑Gruntfile文件即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1)自定义任务(一)</span></div><div class="line">    <span class="comment">//向控制台输出:hello 文顶顶</span></div><div class="line">    <span class="comment">//第一个参数:任务的名称(Task)</span></div><div class="line">    <span class="comment">//第二个参数:具体的任务内容</span></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"hello 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2)自定义任务(二)</span></div><div class="line">    grunt.registerTask(<span class="string">"football"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>终端输入命令执行任务，可以单个执行，也可以一起执行，下面给出具体执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">wendingding:02-Grunt_Test wendingding$ grunt hello</div><div class="line">Running "hello" task</div><div class="line">hello 文顶顶</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:02-Grunt_Test wendingding$ grunt football</div><div class="line">Running "football" task</div><div class="line">皇家马德里: how are you!</div><div class="line">尤文图斯: how old are you！</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:02-Grunt_Test wendingding$ grunt hello football</div><div class="line">Running "hello" task</div><div class="line">hello 文顶顶</div><div class="line"></div><div class="line">Running "football" task</div><div class="line">皇家马德里: how are you!</div><div class="line">尤文图斯: how old are you！</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>通过上面的代码我们可以看到，<span style="color:red">自定义任务非常简单，只需要调用grunt对象的registerTask方法即可，其中第一个参数是Task的名称，第二个参数是回调函数用来存放具体的任务（比如这里是打印输出）。</span></p><div class="tip">在自定义任务中，我们用到了grunt.log.writeln函数，这是Grunt提供的众多内置方法之一，作用是向控制台输出消息并换行。同类型的方法还有grunt.log.error()、grunt.log.subhead()等方法，大家可以到<a href="https://gruntjs.com/api/grunt.log" target="_blank" rel="external">官网API文档</a>自行查看。</div><p>Grunt项目在具体使用的时候，通常是自定义Task + Grunt插件相结合的形式，我们来看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1)自定义任务(一) 任务名称 hello</span></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"hello 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2)自定义任务(二) 任务名称 football</span></div><div class="line">    grunt.registerTask(<span class="string">"football"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//(2) 插件的处理</span></div><div class="line">    <span class="comment">//使用步骤:</span></div><div class="line">    <span class="comment">//[1] 先把对应的插件下载和安装到本地的项目中 $ npm install grunt-contrib-concat --save-dev</span></div><div class="line">    <span class="comment">//[2] 对插件(任务)进行配置 grunt.initConfig</span></div><div class="line">    <span class="comment">//[3] 加载对应的插件 loadNpmTasks</span></div><div class="line">    <span class="comment">//[4] 注册任务      grunt.registerTask</span></div><div class="line">    <span class="comment">//[5] 通过grunt命令执行任务</span></div><div class="line">    <span class="comment">//配置插件相关信息</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">        <span class="string">"concat"</span>:&#123;</div><div class="line">            <span class="string">"dist"</span>:&#123;</div><div class="line">                <span class="string">"src"</span>:[<span class="string">"src/demo_one.js"</span>,<span class="string">"src/demo_two.js"</span>,<span class="string">"src/demo_three.js"</span>],</div><div class="line">                <span class="string">"dest"</span>:<span class="string">"dist/index.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务（一）：把hello \ football \ concat 这三个Task注册为default的Task</span></div><div class="line">    <span class="comment">//当执行$ grunt 或者是$ grunt default的时候，会顺序执行者三个任务！</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"hello"</span>,<span class="string">"football"</span>,<span class="string">"concat"</span>]);</div><div class="line">    <span class="comment">//注册任务(二)</span></div><div class="line">    grunt.registerTask(<span class="string">"customTask"</span>,[<span class="string">"hello"</span>,<span class="string">"football"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>对于上面的Gruntfile文件，如果在终端输入<code>$ grunt</code>或者<code>$ grunt default</code> 命令则依次执行hello football和concat三个任务，输入<code>$ grunt customTask</code>则一次执行hello football 自定义任务。</p><h3 id="3-2-任务描述和依赖"><a href="#3-2-任务描述和依赖" class="headerlink" title="3.2 任务描述和依赖"></a>3.2 任务描述和依赖</h3><p><strong>设置任务描述</strong></p><p>随着项目复杂性的增加，Grunt任务也会越来越多，而任务(Task)的可用性、用途以及调用方法可能会变得难以追踪。所幸，我们可以通过给任务设定相应的描述信息来解决这些问题。</p><p>要给任务设置描述信息非常简单，只需要在调用registerTask方法的时候多传递一个参数即可（作为第二个参数传递），我们可以把一个具体的字符串描述信息作为函数的参数传递。</p><p>这里，我们修改上面示例代码中football任务部分的代码，并任务设置描述信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grunt.registerTask(<span class="string">"football"</span>,<span class="string">"17-18赛季 欧冠八分之一决赛抽签场景"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>此时，在终端中输入<code>$ grunt --help</code>命令就能够看到当前Grunt项目中可用的Task，以及相应的描述信息了，关键信息如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Available tasks</div><div class="line">         hello  Custom task.</div><div class="line">      football  17-18赛季 欧冠八分之一决赛抽签场景</div><div class="line">        concat  Concatenate files. *</div><div class="line">       default  Alias for "hello", "football", "concat" tasks.</div><div class="line">    customTask  Alias for "hello", "football" tasks.</div></pre></td></tr></table></figure><p><strong>任务依赖</strong></p><p>在复杂的Grunt工作流程中，很多任务之间往往存在依赖关系，比如js代码的语法检查和压缩这两个任务，压缩任务需要依赖于语法检查任务，它们在执行的时候存在一定的先后关系，这种情况我们称之为任务依赖。</p><p>我们可以在注册任务的时候，刻意指定这种依赖关系，他们更多的是以一种特定的先后顺序执行。<span style="color:red">如果是自定义任务，也可以通过grunt.task.requires()方法来设定这种任务间的依赖关系。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//注册两个自定义任务</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * 第一个参数:Task的名称</span></div><div class="line"><span class="comment">    * 第二个参数:任务的描述信息</span></div><div class="line"><span class="comment">    * */</span></div><div class="line">    grunt.registerTask(<span class="string">"hi"</span>,<span class="string">"描述信息:这是一个打招呼的任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.ok(<span class="string">"hi 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="string">"任务的描述次信息:这是一个简单问候任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//设置任务依赖：表明当前的任务在执行的时候需要依赖于另外一个任务</span></div><div class="line">        <span class="comment">//必须先执行hi这个任务,才能执行hello这个任务</span></div><div class="line">        grunt.task.requires(<span class="string">"hi"</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Nice to meet you!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码中定义了hi和hello两个任务，其中hello这个Task需要依赖于hi的执行，如果直接执行hello，那么会打印任务依赖的提示信息，具体的执行情况如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello</div><div class="line">Running "hello" task</div><div class="line">Warning: Required task "hi" must be run first. Use --force to continue.</div><div class="line"></div><div class="line">Aborted due to warnings.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hi hello</div><div class="line">Running "hi" task</div><div class="line">&gt;&gt; hi 文顶顶</div><div class="line"></div><div class="line">Running "hello" task</div><div class="line">Nice to meet you!</div><div class="line">Done.</div></pre></td></tr></table></figure></p><h3 id="3-3-Grunt多目标任务和Options选项"><a href="#3-3-Grunt多目标任务和Options选项" class="headerlink" title="3.3 Grunt多目标任务和Options选项"></a>3.3 Grunt多目标任务和Options选项</h3><p><strong>理解多目标Task</strong></p><p>Grunt中的多目标任务（multi-task）是相对于基本任务而言的，多目标任务几乎是Grunt中最复杂的概念。它的使用方式非常灵活，其设计的目的是可以在当个项目中支持多个Targets目标[<code>可以认为是多种配置</code>]。当任务在执行的时候，可以一次性执行全部的Target也可以指定某一特定的Target执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//(1) 配置Task，给Task设置多个Target</span></div><div class="line">    grunt.config(<span class="string">"hello"</span>,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"targetA"</span>:&#123;</div><div class="line">                <span class="string">"des"</span>:<span class="string">"Nice to meet you!"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"targetB"</span>:&#123;</div><div class="line">                <span class="string">"des"</span>:<span class="string">"how are you?"</span></div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//(2) 自定义任务 任务的名称为hello</span></div><div class="line">    <span class="comment">//第一个参数：Task名称</span></div><div class="line">    <span class="comment">//第二个参数：任务的描述信息</span></div><div class="line">    <span class="comment">//第三个参数：具体要执行的任务</span></div><div class="line">   grunt.registerMultiTask(<span class="string">"hello"</span>,<span class="string">"描述信息:打招呼"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.ok(<span class="string">"hello 文顶顶"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"this.target:"</span>,<span class="keyword">this</span>.target);</div><div class="line">        grunt.log.writeln(<span class="string">"this.data:"</span>,<span class="keyword">this</span>.data);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>代码说明</strong></p><p>通过观察可以发现，我们通过<code>grunt.registerMultiTask方法</code>创建了支持多任务（Target）操作的自定义任务hello，主要任务就是输出<span style="color:#f22">“hello 文顶顶”</span>消息以及打印当前的target和data值。然后通过<code>grunt.config方法</code>来给hello这个Task设定了两个Target，分别是targetA和targetB。</p><p>在上面的代码中，我们引用了this.target和this.data这两个属性，<span style="color:#f22">回调函数中的this指向的是当前正在运行的目标对象。</span>执行targetA这个选项的时候，打印的this对象如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">nameArgs</span>: <span class="string">'hello:targetA'</span>,</div><div class="line">  name: <span class="string">'hello'</span>,</div><div class="line">  args: [],</div><div class="line">  flags: &#123;&#125;,</div><div class="line">  <span class="keyword">async</span>: [<span class="built_in">Function</span>],</div><div class="line">  errorCount: [Getter],</div><div class="line">  requires: [<span class="built_in">Function</span>: bound ],</div><div class="line">  requiresConfig: [<span class="built_in">Function</span>],</div><div class="line">  options: [<span class="built_in">Function</span>],</div><div class="line">  target: <span class="string">'targetA'</span>,</div><div class="line">  data: &#123; <span class="attr">des</span>: <span class="string">'Nice to meet you!'</span> &#125;,</div><div class="line">  files: [],</div><div class="line">  filesSrc: [Getter] &#125;</div></pre></td></tr></table></figure></p><p>目前为止，我们一直在谈论Task（任务）和Target（目标），大家可能懵逼了，不禁要问<code>它们之间到底是什么关系？</code></p><p>私以为可以简单的类比一下，假设现在有一个任务就是中午吃大餐，而具体吃什么大餐，可以灵活安排多个方案进行选择，比如方案A吃西餐，方案B吃中餐，方案C吃日本料理。等我们真正到了餐馆要开吃的时候，可以选择方案A吃西餐或者是方案B吃中餐，甚至中餐、西餐和日本料理全端上桌也未尝不可。</p><p><span style="color:#f22">Task指的是整个任务，在这个例子中就是要吃大餐，Target指的是任务中的某一种可行方案，也就是方案A、方案B和方案C，吃大餐这个Task中我们配置了三个Target。定义任务的目的是为了执行，在执行Task的时候，我们可以选择执行某个或某几个指定的Target(目标)，这样的处理方式无疑更强大而且操作起来更加的灵活。</span></p><p><strong>多目标任务的执行</strong></p><p>运行多目标Task的时候，有多种方式选择。</p><p>① 让Task按照指定的target运行。<code>$ grunt TaskName:targetName</code></p><p>② 让Task把所有的target都运行一次。<code>$ grunt TaskName</code></p><p>下面列出示例代码的具体执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello</div><div class="line">Running "hello:targetA" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetA</div><div class="line">this.data: &#123; des: 'Nice to meet you!' &#125;</div><div class="line"></div><div class="line">Running "hello:targetB" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetB</div><div class="line">this.data: &#123; des: 'how are you?' &#125;</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello:targetA</div><div class="line">Running "hello:targetA" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetA</div><div class="line">this.data: &#123; des: 'Nice to meet you!' &#125;</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello:targetB</div><div class="line">Running "hello:targetB" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetB</div><div class="line">this.data: &#123; des: 'how are you?' &#125;</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><div class="tip">如果在Gruntfile文件中，调用了<code>grunt.registerTask方法</code>来注册自定义任务，那么可以通过<code>TaskName:targetName</code>的来方式直接指定任务的Target</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册任务 [给hello起一个别名]</span></div><div class="line"> grunt.registerTask(<span class="string">"helloTargetA"</span>,[<span class="string">"hello:targetA"</span>]);</div></pre></td></tr></table></figure><p>在终端中，输入<code>$ grunt helloTargetA</code>命令将会执行hello这个Task中的targetA选项。</p><p><strong>多目标任务的Options选项</strong></p><p>在对多目标的任务进行配置的时候，任何存储在options选项下面的数据都会被特殊的处理。</p><p>下面列出一份Gruntfile文件中的核心代码，并以多种方式执行，通过这份代码能够帮助我们理解多目标任务的Options选项配置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1) 配置Task相关信息</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * 第一个参数:Task的名称</span></div><div class="line"><span class="comment">    * 第二个参数:任务的描述信息</span></div><div class="line"><span class="comment">    * */</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">       <span class="string">"hi"</span>: &#123;</div><div class="line">           <span class="comment">/*对整个任务中所有target的配置项 全局配置*/</span></div><div class="line">           options:&#123;</div><div class="line">               <span class="string">"outPut"</span>:<span class="string">"array"</span></div><div class="line">           &#125;,</div><div class="line">           targetA:&#123;</div><div class="line">               arrM:[<span class="string">"targetA_1"</span>,<span class="string">"targetA_2"</span>,<span class="string">"targetA_3"</span>]</div><div class="line">           &#125;,</div><div class="line">           targetB:&#123;</div><div class="line">               options:&#123;</div><div class="line">                   <span class="string">"outPut"</span>:<span class="string">"json"</span></div><div class="line">               &#125;,</div><div class="line">               arrM:[<span class="string">"targetB_1"</span>,<span class="string">"targetB_2"</span>,<span class="string">"targetB_3"</span>]</div><div class="line">           &#125;,</div><div class="line">           targetC:&#123;</div><div class="line">               arrM:[<span class="string">"targetC_1"</span>,<span class="string">"targetC_2"</span>,<span class="string">"targetC_3"</span>]</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2) 自定义任务 Task名称为hi</span></div><div class="line">    <span class="comment">//第一个参数：Task名称</span></div><div class="line">    <span class="comment">//第二个参数：任务的描述信息</span></div><div class="line">    <span class="comment">//第三个参数：具体要执行的任务</span></div><div class="line">    grunt.registerMultiTask(<span class="string">"hi"</span>,<span class="string">"描述次信息:这是一个打招呼的任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"任务当前执行的target: "</span>+<span class="keyword">this</span>.target);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"任务当前执行的target对应的数据: \n"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> objT = <span class="keyword">this</span>.options();</div><div class="line">        <span class="keyword">if</span> (objT.outPut === <span class="string">"array"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"输出数组:\n"</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.arrM);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (objT.outPut === <span class="string">"json"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"输出JSON数据:\n"</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data.arrM));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(1) 相关的概念 Task(任务-hi) | target(目标)</span></div><div class="line">    <span class="comment">//(2) 任务的配置:任务中可以配置一个或者是多个目标  调用config</span></div><div class="line">    <span class="comment">//(3) 复合任务的执行(多任务-多target)</span></div><div class="line">    <span class="comment">//   001 grunt TaskName 把当前Task下面所有的目标操作都执行一遍</span></div><div class="line">    <span class="comment">//   002 grunt TaskName:targetName 执行当前Task下面的某一个指定的目标</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"hi"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">wendingding:06-Grunt项目多任务和options wendingding$ grunt</div><div class="line">Running "hi:targetA" (hi) task</div><div class="line">任务当前执行的target: targetA</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出数组:</div><div class="line">[ 'targetA_1', 'targetA_2', 'targetA_3' ]</div><div class="line"></div><div class="line">Running "hi:targetB" (hi) task</div><div class="line">任务当前执行的target: targetB</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出JSON数据:</div><div class="line">["targetB_1","targetB_2","targetB_3"]</div><div class="line"></div><div class="line">Running "hi:targetC" (hi) task</div><div class="line">任务当前执行的target: targetC</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出数组:</div><div class="line">[ 'targetC_1', 'targetC_2', 'targetC_3' ]</div><div class="line"></div><div class="line">Done</div></pre></td></tr></table></figure></p><p><strong>代码说明</strong></p><p>上面的代码中定义了一个多目标任务，Task的名称为<code>hi</code>，该Task有三个target目标选项，分别是<code>targetA、targetB和targetC</code>。在任务配置相关代码中，全局的options配置项中outPut属性对应的值为array，表示具体的目标任务在执行的时候以数组的形式输出。</p><p>我们看到在targetB目标中重写了options选项中的outPut属性为json，当终端执行<code>$ grunt</code>命令的时候，会依次执行所有三个target目标选项，而targetA和targetC以数组格式来输出内容，targetB则以json格式来输出内容。</p><p><span style="color:#f25">Grunt多目标任务以及选项使得我们可以针对不同的应用环境，以不同的方式来运行同一个Task。可以利用这一点，我们完全能够定义Task为不同的构建环境创建不同的输出目标。</span></p><div class="tip">说明 ✧ <code>this.options()方法</code>用于获取当前正在执行的目标Task的options配置选项</div><h3 id="3-4-Grunt项目任务配置模板"><a href="#3-4-Grunt项目任务配置模板" class="headerlink" title="3.4 Grunt项目任务配置模板"></a>3.4 Grunt项目任务配置模板</h3><p><strong>Grunt项目中配置模板的简单使用</strong></p><p>在Grunt项目中，我们可以使用<code>&lt;% %&gt;</code>分隔符的方式来指定模板，当Task读取自己配置信息的时候模板的具体内容会自动扩展，且支持以递归的方式展开。</p><p>在通过<code>&lt;%= ... %&gt;</code>在向模板绑定数据的时候，我们可以直接传递配置对象中的属性或调用grunt提供的方法，<span style="color:red">模板中属性的上下文就是当前的配置对象</span>。</p><p>下面，我们通过Gruntfile文件中的一段核心代码来展现配置模板的使用情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//(1) 创建并设置grunt的配置对象</span></div><div class="line">    <span class="comment">//配置对象：该对象将作为参数传递给grunt.config.init方法</span></div><div class="line">    <span class="keyword">var</span> configObj = &#123;</div><div class="line">        concat: &#123;</div><div class="line">            target: &#123;</div><div class="line">              <span class="comment">//src:["src/demo1.js","src/demo2.js"]</span></div><div class="line">                src: [<span class="string">'&lt;%= srcPath %&gt;demo1.js'</span>, <span class="string">'&lt;%= srcPath %&gt;demo2.js'</span>],</div><div class="line">              <span class="comment">//dest:["dist/2018_05_21_index.js"]</span></div><div class="line">                dest: <span class="string">'&lt;%= targetPath %&gt;'</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        srcPath:<span class="string">"src/"</span>,</div><div class="line">        destPath:<span class="string">"dist/"</span>,</div><div class="line">        targetPath:<span class="string">"&lt;%= destPath %&gt;&lt;%= grunt.template.today('yyyy_mm_dd_') %&gt;index.js"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//(2) 调用init方法对任务(Task)进行配置</span></div><div class="line">    <span class="comment">// grunt.config.init 方法 === grunt.initConfig方法</span></div><div class="line">    grunt.config.init(configObj);</div><div class="line"></div><div class="line">    <span class="comment">//(3) 加载concat插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//(4) 注册Task</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面这段代码对concat插件代码合并Task进行了配置，使用到了模板技术。该任务把src目录下的demo1和demo2两个js文件合并到dist目录下并命名为2018_05_21_index.js文件。</p><p><strong>Grunt项目中导入外部的数据</strong></p><p>在向模板绑定数据的时候，常见的做法还会导入外部的数据，并把导入的数据设置为配置对象的指定属性值。比如在开发中常常需要用到当前Grunt项目的元信息，包括名称、版本等，这些数据常通过调用<code>grunt.file.readJSON方法</code>加载package.json文件的方式获取。下面给出代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//设置(demoTask和concat)Task的配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        <span class="comment">//从package.json文件中读取项目的元(基本)信息</span></div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//demoTask的配置信息</span></div><div class="line">        demoTask :&#123;</div><div class="line">           banner:<span class="string">"&lt;%=pkg.name%&gt; -- &lt;%=pkg.version%&gt;"</span></div><div class="line">       &#125;,</div><div class="line">        <span class="comment">//concat的配置信息</span></div><div class="line">        concat:&#123;</div><div class="line">           options:&#123;</div><div class="line">               stripBanners:<span class="literal">true</span>,</div><div class="line">               banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt; 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">           &#125;,</div><div class="line">           target:&#123;</div><div class="line">               src:[<span class="string">"src/demo1.js"</span>,<span class="string">"src/demo2.js"</span>],</div><div class="line">               dest:<span class="string">'dist/index.js'</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//自定义Task 任务的名称为demoTask</span></div><div class="line">    grunt.registerMultiTask(<span class="string">"demoTask"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"执行demo任务"</span>);</div><div class="line">        <span class="comment">//表示调用config方法来读取demoTask里面的banner属性并输出</span></div><div class="line">        <span class="built_in">console</span>.log(grunt.config(<span class="string">"demoTask.banner"</span>));</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//从node_modules目录中加载concat插件</span></div><div class="line">    <span class="comment">//注意：需要先把插件下载到本地  npm install grunt-contrib-concat --save-dev</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"demoTask"</span>,<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>如果在终端输入<code>$ grunt</code>命令执行，那么demoTask任务将会输出<code>grunt_demo -- 1.0.0</code>打印消息，而concat任务则把两个js文件合并到dist目录下面的index.js文件并添加注释信息。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wendingding$ grunt</div><div class="line">Running "demoTask:banner" (demoTask) task</div><div class="line">执行demo任务</div><div class="line">grunt_demo -- 1.0.0</div><div class="line"></div><div class="line">Running "concat:target" (concat) task</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:07-Grunt项目模板配置 wendingding$ cat dist/index.js</div><div class="line">/*项目名称：grunt_demo 项目版本：1.0.0 项目的作者：文顶顶 更新时间：2018-05-21*/</div><div class="line">console.log("demo1");</div><div class="line">console.log("demo2");</div></pre></td></tr></table></figure></p><div class="tip"><br><strong>说明</strong> &nbsp;grunt.file.readJSON方法用于加载JSON数据，grunt.file.readYAML方法用于加载<a href="http://yaml.org/" target="_blank" rel="external">YAML</a>数据。</div><h3 id="3-5-Grunt自动化构建和监听"><a href="#3-5-Grunt自动化构建和监听" class="headerlink" title="3.5 Grunt自动化构建和监听"></a>3.5 Grunt自动化构建和监听</h3><p>到这里，基本上就可以说已经熟练掌握Grunt了。上文我们在进行代码演示的时候，不论是自定义任务还是Grunt插件使用的讲解都是片段性的，支离破碎的，Grunt作为一款自动化构建工具，<code>自动化</code>这三个字到现在还没有体现出来。</p><p>顾名思义，<span style="color:#f25">自动化构建的意思就是能够监听项目中指定的文件，当这些文件发生改变后自动的来执行某些特定的任务。</span> 否则的话，每次修改文件后，都需要我们在终端里面输入对应的命令来重新执行，这顶多能算<code>半自动化</code>是远远不够的。</p><p>下面给出一份更全面些的Gruntfile文件，该文件中使用了几款常用的Grunt插件(uglify、cssmin、concat等)来搭建自动化构建项目的工作流。<a href="https://github.com/flowerField/ex.git" target="_blank" rel="external">点击获取演示代码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">// 项目配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//代码合并</span></div><div class="line">        concat:&#123;</div><div class="line">            options:&#123;</div><div class="line">                stripBanners:<span class="literal">true</span>,</div><div class="line">             banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt;'</span></div><div class="line">             +<span class="string">' 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">            &#125;,</div><div class="line">            target:&#123;</div><div class="line">                src:[<span class="string">"src/demo1.js"</span>,<span class="string">"src/demo2.js"</span>],</div><div class="line">                dest:<span class="string">'dist/index.js'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js代码压缩</span></div><div class="line">        uglify:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"dist/index.js"</span>,</div><div class="line">                dest:<span class="string">"dist/index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//css代码压缩</span></div><div class="line">        cssmin:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"src/index.css"</span>,</div><div class="line">                dest:<span class="string">"dist/index.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js语法检查</span></div><div class="line">        jshint:&#123;</div><div class="line">            target:[<span class="string">'Gruntfile.js'</span>,<span class="string">"dist/index.js"</span>],</div><div class="line">            options:&#123;</div><div class="line">                jshintrc:<span class="string">".jshintrc"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//监听 自动构建</span></div><div class="line">        watch:&#123;</div><div class="line">            target:&#123;</div><div class="line">                files:[<span class="string">"src/*.js"</span>,<span class="string">"src/*.css"</span>],</div><div class="line">                <span class="comment">//只要指定路径的文件(js和css)发生了变化，就自动执行tasks中列出的任务</span></div><div class="line">                tasks:[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//通过命令行安装插件（省略...）</span></div><div class="line">    <span class="comment">//从node_modules路径加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-jshint"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-watch"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务：在执行$ grunt命令的时候依次执行代码的合并|检查|压缩等任务并开启监听</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>,<span class="string">"watch"</span>])</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p><strong>当在终端输入<code>$ grunt</code>命令的时候，grunt会执行以下任务</strong></p><p>① &nbsp;合并src/demo1.js和src/demo2.js文件并命名为index.js保存到dist目录<br>② &nbsp;按照既定的规则对Gruntfile.js和index.js文件来进行语法检查<br>③ &nbsp;压缩index.js文件并命名为index.min.js保存在dist目录<br>④ &nbsp;压缩src/index.css文件并保存到dist/index.min.css<br>⑤ &nbsp;<span style="color:#f25">开启监听，如果src目录下面的js文件或css文件被更改则重新构建</span></p></blockquote><p>关于监听插件<code>grunt-contrib-watch</code>的更多用法建议查看<a href="https://www.npmjs.com/package/grunt-contrib-watch" target="_blank" rel="external">使用文档</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[03]-Grunt构建工具的运转机制</title>
    <link href="https://weibo.com/u/3800117445/2018/05/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B03%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%90%E8%BD%AC%E6%9C%BA%E5%88%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/05/20/前端工程化系列[03] Grunt构建工具的运转机制/</id>
    <published>2018-05-20T02:06:13.000Z</published>
    <updated>2018-06-11T02:04:44.633Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">前端工程化系列[02]-Grunt构建工具的基本使用</a>这篇文章中，已经对Grunt做了简单的介绍，此外，我们还知道了该如何来安装Grunt环境，以及使用一些常见的插件了，这篇文章主要介绍Grunt的核心组件和运转机制。</p></blockquote><p>Grunt是一套前端自动化构建工具，可以帮助我们简化开发中需要反复处理的任务，甚至可以实现自动构建等功能。</p><p>Grunt拥有数量庞大的插件，这些插件能够帮助我们处理开发中遇到的绝大多数构建任务，比如代码的预编译、压缩、代码检查、单元测试等。但为什么在终端输入Grunt相关命令，就能够执行对应的任务，Grunt到底是怎么运转的？这些知识对于深入研究Grunt非常重要,下面我们从Grunt运转的组件和运转机制两方面来展开讨论。</p><h3 id="2-1-Grunt的核心组件"><a href="#2-1-Grunt的核心组件" class="headerlink" title="2.1  Grunt的核心组件"></a>2.1  Grunt的核心组件</h3><p><strong><span style="color:#f25">node和npm</span></strong></p><p>Grunt项目基于Node.js，Grunt和相关的插件都通过 npm 安装并管理。</p><p><strong><span style="color:#f25">Grunt-cli</span></strong></p><p> <span style="color:#195">Grunt命令行用于调用与Gruntfile文件在同一目录中的 Grunt模块</span>，通过<code>-g</code>参数把Grunt命令行安装到全局环境中，这样的话在所有文件目录中都可以调用grunt相关的命令。</p><p>在命令行中运行Grunt 相关命令时(比如 <code>$grunt default</code>)，内部会根据node提供的require系统查找来当前目录中安装的 Grunt，如果找到那么加载，并把加载的grunt作为参数传递到Gruntfile文件中，然后执行指定的任务。</p><p><strong><span style="color:#f25">Task</span></strong></p><p>Task就是任务的意思，grunt支持自定义任务，也支持使用现成的插件任务。比如向控制台输出一句问候这可以被认为是一个Task，对所有的js文件进行压缩这也是一个Task，通常任务(Task)都是可配置的。</p><p><strong><span style="color:#f25">Grunt本地依赖</span></strong></p><p>安装了grunt命令行不等于就安装了grunt，这只是让我们拥有了在命令行中使用grunt相关命令的能力，对于每个需要使用grunt的工程，仍然需要为其配置grunt本地依赖。</p><p><strong><span style="color:#f25">Grunt插件(Plugins)</span></strong></p><p><span style="color:#195">Grunt插件是一系列能够用于不同项目的可配置任务的集合。</span>Grunt插件通常以npm包的形式发布。<a href="https://gruntjs.com/plugins" target="_blank" rel="external">Grunt官网的插件列表</a>列出了所有可用的Grunt插件，截止当前的插件数量为6,393个，其中带有contrib前缀的插件由Grunt官方开发和维护。</p><p><strong><span style="color:#f25">package.json文件</span></strong></p><p><span style="color:#195">package.json文件用于被npm存储项目的元数据，以便将此项目发布为npm模块。</span>我们可以在此文件中列出项目依赖的Grunt和Grunt插件，保存在devDependencies（开发依赖）配置字段内，我们可以通过<code>$ npm install</code>命令来加载该文件中的所有依赖项。</p><p><strong><span style="color:#f25">Gruntfile.js文件</span></strong></p><p>Gruntfile文件是Grunt项目中最核心的文件，该文件同package.json文件一起存放在项目的根目录中，主要用来配置或定义任务（task）并加载Grunt插件。标准的grunt项目中必须拥有package.json和Gruntfile这两个文件。</p><p><strong><span style="color:#f25">node_modules文件夹</span></strong></p><p>node_modules文件目录存放着从远程仓库下载的grunt以及所有相关的grunt插件。</p><h3 id="2-2-Grunt的运转机制"><a href="#2-2-Grunt的运转机制" class="headerlink" title="2.2 Grunt的运转机制"></a>2.2 Grunt的运转机制</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt_02.png?raw=true"></p><p>上面给出了Grunt项目中各主要组件的关系图示，是根据个人的理解绘制的，所以可能并非完全准确，但基本上已经能够说清楚Grunt的运转机制了。</p><p>我们在使用Grunt作为项目构建工具的时候，所做的事情大概可以分成三块：准备、配置、执行。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 准备阶段&nbsp; &nbsp;</strong></span></p><p>准备阶段主要进行以下操作</p><blockquote><p>❏ &nbsp;node环境的安装、npm的安装(在安装node的时候默认安装)</p><p>❏ &nbsp;grunt-cli命令行的安装(通过<code>$ npm install -g grunt-cli</code>命令)</p><p>❏ &nbsp;创建package.json文件(手动创建或通过<code>$ npm init</code>命令交互式创建)</p><p>❏ &nbsp;配置grunt本地依赖(通过<code>$ npm install grunt --save-dev</code>下载grunt到项目)</p><p>❏ &nbsp;安装需要的grunt插件(通过<code>$ npm install grunt-contrib-xx --save-dev</code>命令把需要的插件下载到node_modules目录)</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 配置阶段&nbsp; &nbsp;</strong></span></p><p>配置阶段主要就是<span style="color:#f25">创建和编辑Gruntfile文件，在该文件中接收grunt参数并配置Task，注册Task。</span>Task简单说就是任务的意思，我们可以自定义任务，也可以直接使用现成的、一些其他优秀开发者定义好并打包为node模块发布的任务（其实就是grunt插件）。</p><p>一般来说，我们总是通过grunt为我们提供的<code>grunt.initConfig</code>方法来对Task(插件)进行配置，如果是该Task是Grunt插件那么还需要先从node_modules目录中加载。</p><p>如果对多个Task的执行有指定的顺序或者依赖关系，那么我们可以通过<code>grunt.registerTask</code>方法来<code>注册Task</code>。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 执行阶段&nbsp; &nbsp;</strong></span></p><p>在执行阶段，通过在命令行中输入<code>$ grunt task名称</code>的方式来执行指定的任务。</p><p>执行Task的时候，可以单个执行，例如：</p><p><code>$ grunt taskName1</code><br><code>$ grunt taskName2</code></p><p>也可以用单条命令执行多个Task，每个Task都将按照参数的传入顺序依次执行，例如：</p><p><code>$ grunt taskName1 taskName2</code></p><p>在使用构建工具的时候，这些Task具体怎么执行，执行的顺序等并非是固定不变的，需要结合特定的需求来特殊处理。如果总是有一组Task需要按顺序执行，一般可以使用grunt.registerTask方法来给这组Task设置个别名，这一组的Task以数组的形式传递。</p><p>例如：要依次执行js文件的合并、语法检查、代码压缩、css代码压缩等任务，则配置好相关Task后可以像下面这样来设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt.registerTask(<span class="string">"customTask"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]);</div></pre></td></tr></table></figure><p>要执行这组任务的时候，直接执行<code>$ grunt customTask</code>命令即可。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[02]-Grunt构建工具的基本使用</title>
    <link href="https://weibo.com/u/3800117445/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B02%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/05/18/前端工程化系列[02] Grunt构建工具的使用/</id>
    <published>2018-05-18T12:36:13.000Z</published>
    <updated>2018-06-11T02:04:44.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍前端开发中常用的构建工具Grunt，具体包括Grunt的基本情况、安装、使用和常见插件的安装、配置和使用等内容。</p></blockquote><h3 id="1-1-Grunt简单介绍"><a href="#1-1-Grunt简单介绍" class="headerlink" title="1.1 Grunt简单介绍"></a>1.1 Grunt简单介绍</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt.png?raw=true" height="300px"></p><p><span style="color:#f25">Grunt是一套前端自动化构建工具。</span>对于需要反复重复的任务（如压缩、编译、单元测试等），自动化构建工具可以减轻并简化我们的工作。我们只需要在 Gruntfile 文件中正确配置好要处理的任务，任务运行器就会自动帮我们完成大部分工作。</p><p><strong>Grunt的优点</strong></p><blockquote><p>❏  Grunt拥有庞大的生态系统，并且一直在增长。<br>❏  Grunt支持我们自己创作插件并发布。</p></blockquote><p>由于Grunt拥有数量庞大的插件，所以几乎任何的任务都可以利用Grunt来自动完成，你也可以根据自己项目的特点来创作合适的插件发布。</p><p><strong><span style="color:#f25">Grunt的工作方式</span></strong></p><p>Grunt为开发者提供了一个工具包，用于创建命令行程序来执行项目构建过程中的重复性任务，比如压缩js代码、编译Sass样式等。Grunt不仅仅能创建简单任务以解决特定工程遇到的特定需求，还能将任务打包为可复用的插件。这些插件可以被发布、分享，使用以及被其他人进行改进。</p><p>Grunt的运转依赖于四个核心的组件：分别是<span style="color:#f25">Gruntfile、Tasks 、Plugins以及任务配置。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① Gruntfile &nbsp; &nbsp;</strong></span></p><p>Gruntfile指的是在项目根目录下面名为Gruntfile.js的Node模块。该文件使得我们可以加载Grunt插件，创建自定义任务，并根据项目需求对它们进行配置。</p><p>Grunt每次运行时的首要任务都是接受该模块发出的指令。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② Tasks &nbsp; &nbsp;</strong></span></p><p>Tasks作为Grunt的基本构建模块，它实际上是由Grunt的registerTask（）方法注册的具名函数。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ Plugins &nbsp; &nbsp;</strong></span></p><p>Plugins是一系列能够用于不同项目的可配置任务的集合。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;④ 任务配置 &nbsp; &nbsp;</strong></span></p><p>Grunt强调配置优先，任务和插件的功能都可以通过配置文件进行定制，以适应不同工程的需求。这种代码和配置相分离的特性，使开发者能够创造出高复用的插件。</p><p><strong>相关参考</strong></p><p><strong>现在最新版本&nbsp;&nbsp;&nbsp;&nbsp;</strong>   <span style="color:#f25">v1.0.2</span><br><strong>其它构建工具&nbsp;&nbsp;&nbsp;&nbsp;</strong> <span style="color:#f25"> gulp、webpack、fis3等</span></p><p><a href="http://www.gruntjs.com" target="_blank" rel="external">Grunt官网</a><br><a href="http://www.gruntjs.net/" target="_blank" rel="external">Grunt官网(中文)</a><br><a href="http://www.gruntjs.net/plugins" target="_blank" rel="external">Grunt相关的插件列表</a></p><h3 id="1-2-Grunt的安装"><a href="#1-2-Grunt的安装" class="headerlink" title="1.2 Grunt的安装"></a>1.2 Grunt的安装</h3><p>Grunt和相关的插件都通过 npm 安装并管理。</p><p>Grunt基于Node.js，安装之前要先安装Node.js。</p><blockquote><p><strong>Node.js的安装</strong></p><p>① 打开<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>找到Download选项，选择对应的版本下载。<br>② 下载之后，根据对应的提示进行安装即可。<br>③ 安装完成之后，可以通过<code>$ node --version</code>和<code>$ npm --version</code>命令查看是否安装成功。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ node --version</div><div class="line">v8.9.3</div><div class="line">wendingding:~ wendingding$ npm --version</div><div class="line">5.5.1</div><div class="line">wendingding:~ wendingding$</div></pre></td></tr></table></figure><p><strong>安装注意点</strong></p><p>❗ ️Grunt依赖于nodejs的v0.8.0及以上版本；<br>❗ ️奇数版本号的 Node.js 被认为是不稳定的开发版；<br>❗️  需确保当前环境中所安装的 npm 已经是最新版本（<code>$ npm update -g npm</code>）</p><p><strong><span style="color:#f25">安装Grunt命令行</span></strong></p><p><strong>注意</strong> 在使用Grunt之前，需要先安装Grunt命令行到全局环境中。</p><p>安装命令：<code>$ npm install -g grunt-cli</code></p><p>安装完之后，可以通过<code>$ grunt</code>命令来验证Grunt命令行是否安装完成并生效，命令行中的<code>-g</code>表示全局安装。</p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ npm install -g grunt-cli</div><div class="line">/usr/local/bin/grunt -&gt; /usr/local/lib/node_modules/grunt-cli/bin/grunt</div><div class="line">+ grunt-cli@1.2.0</div><div class="line">added 16 packages in 9.289s</div><div class="line">wendingding:~ wendingding$ grunt</div><div class="line">grunt-cli: The grunt command line interface (v1.2.0)</div><div class="line"></div><div class="line">Fatal error: Unable to find local grunt.</div><div class="line"></div><div class="line">If you're seeing this message, grunt hasn't been installed locally to</div><div class="line">your project. For more information about installing and configuring grunt,</div><div class="line">please see the Getting Started guide:</div><div class="line"></div><div class="line">http://gruntjs.com/getting-started</div></pre></td></tr></table></figure></p><p><strong>Grunt命令行的作用</strong></p><p><code>Grunt命令行用于调用与Gruntfile在同一目录中 Grunt</code>。每次运行Grunt 时，都会根据node提供的require()系统查找本地安装的 Grunt（<code>因此我们可以在项目的任意子目录中运行grunt</code>） ，如果找到一份本地安装的 Grunt，命令行就将其加载，并传递Gruntfile中的配置信息，然后执行指定的任务。</p><h3 id="1-3-Grunt的安装和使用"><a href="#1-3-Grunt的安装和使用" class="headerlink" title="1.3 Grunt的安装和使用"></a>1.3 Grunt的安装和使用</h3><h4 id="1-3-1-Grunt使用的基本步骤"><a href="#1-3-1-Grunt使用的基本步骤" class="headerlink" title="1.3.1 Grunt使用的基本步骤"></a>1.3.1 Grunt使用的基本步骤</h4><blockquote><p><strong><span style="color:#f25">Grunt使用的基本步骤</span></strong></p><p>① &nbsp;生成package.json和Gruntfile.js文件<br>② &nbsp;命令行安装项目中需要用到的插件<br>③ &nbsp;编辑Gruntfile文件定义Task并进行配置<br>④ &nbsp;命令行以grunt task的方式执行任务</p></blockquote><h4 id="1-3-2-Grunt的安装"><a href="#1-3-2-Grunt的安装" class="headerlink" title="1.3.2 Grunt的安装"></a>1.3.2 Grunt的安装</h4><p>接下来，我们通过一个完整的Grunt案例来介绍Grunt的常规使用方法。首先创建的对应的项目文件目录，这里命名为Grunt_demo文件夹，然后创建<code>package.json文件</code>和<code>Gruntfile.js文件</code>并进行相关配置,安装相应的插件并执行Task。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 创建package.json文件&nbsp; &nbsp;</strong></span></p><p>创建package.json文件有两种方式，一种是直接创建然后以json格式的字段来进行配置，第二种是通过执行npm install来创建，推荐通过命令行的方式来创建。</p><p><strong> ✧ 直接创建package.json文件 ✧ </strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ mkdir Grunt_Demo</div><div class="line">wendingding:~ wendingding$ cd Grunt_Demo/</div><div class="line">wendingding:Grunt_Demo wendingding$ PWD</div><div class="line">/Users/文顶顶/Grunt_Demo</div><div class="line">wendingding:Grunt_Demo wendingding$ touch package.json</div><div class="line">wendingding:Grunt_Demo wendingding$ open package.json</div></pre></td></tr></table></figure><p>命令行说明</p><p><code>$ mkdir Grunt_Demo</code> 表示创建文件夹<br><code>$ cd Grunt_Demo/</code>    表示进入文件目录<br><code>$ PWD</code>              表示查看当前路径<br><code>$ touch package.json</code> 表示创建package.json文件<br><code>$ open package.json</code> 表示使用记事本打开文件并编辑</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ open package.json</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">"name":"Grunt_Demo",</div><div class="line">"version":"1.0.0",</div><div class="line">"dependencies":&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>$ cat package.json</code> 表示查看文件内容</p><p>创建好package.json文件后，可以根据需要添加内容字段到文件中。该json文件中最基本字段主要有<span style="color:#195">name、version和dependencies</span>，其中name和version对应的是Grunt项目的名称和版本，而dependencies字段中则列出该项目的依赖。</p><p><span style="color:#f25">package.json文件用于被npm存储项目的元数据，以便将此项目发布为npm模块。我们可以在此文件中列出项目依赖的Grunt和Grunt插件，保存在devDependencies（开发依赖）配置段内。</span></p><p><strong> ✧ 初始化命令创建package.json文件 ✧ </strong></p><p>除手动创建外，我们还能够通过命令行来进行初始化操作，会以交互的方式来生成一个包含基本配置信息的package.json文件。</p><p>初始化命令：<code>$ npm init</code></p><p>下面列出具体的命令行执行情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm init</div><div class="line">This utility will walk you through creating a package.json file.</div><div class="line">It only covers the most common items, and tries to guess sensible defaults.</div><div class="line"></div><div class="line">See `npm help json` for definitive documentation on these fields</div><div class="line">and exactly what they do.</div><div class="line"></div><div class="line">Use `npm install <span class="tag">&lt;<span class="name">pkg</span>&gt;</span>` afterwards to install a package and</div><div class="line">save it as a dependency in the package.json file.</div><div class="line"></div><div class="line">Press ^C at any time to quit.</div><div class="line">package name: (grunt_demo)</div><div class="line">version: (1.0.0)</div><div class="line">description:</div><div class="line">entry point: (index.js)</div><div class="line">test command:</div><div class="line">git repository:</div><div class="line">keywords:</div><div class="line">author:</div><div class="line">license: (ISC)</div><div class="line">About to write to /Users/文顶顶/Grunt_Demo/package.json:</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC"</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Is this ok? (yes) yes</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在执行<code>npm init</code>命令创建基本package.json文件的时候，可以设置名称、版本、依赖等选项，如果不设置直接回车表示以默认(建议)的方式来进行配置。</p><pre class="tip"><strong>package.json文件注意点</strong><br>❐ package.json应当放置于项目的根目录中，并同项目源代码一起管理。<br>❐ 如果在根目录中运行npm install命令，那么将依据package.json列出的依赖项来自动安装适当版本的依赖。</pre><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 创建Gruntfile文件&nbsp; &nbsp;</strong></span></p><p>Gruntfile文件是Grunt项目中最核心的文件，可以被命名为 Gruntfile.js 或者是Gruntfile.coffee，该文件同package.json文件一起存放在项目的根目录中，主要<code>用来配置或定义任务（task）并加载Grunt插件</code>。</p><p>标准的grunt项目中必须拥有package.json和Gruntfile这两个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ touch Gruntfile.js</div><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 2</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">└── package.json</div><div class="line"></div><div class="line">0 directories, 2 files</div></pre></td></tr></table></figure><p><code>$ tree -L 2</code> 表示以树状图的方式列出当前目录下面的二级文件结构，具体使用可以参考<a href="http://wendingding.com/2018/04/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20Mac%E7%B3%BB%E7%BB%9F%E4%B8%ADTree%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">网络编程系列 Mac系统中Tree的使用</a></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 安装Grunt &nbsp; &nbsp;</strong></span></p><p>在创建Grunt项目的过程中，我们可以通过<code>$ npm install &lt;module&gt; --save-dev</code>模式的命令来安装Grunt和Grunt插件。该命令在安装<module>的同时，会自动将其添加到package.json文件的devDependencies 配置段中。</module></p><p>接下来我们演示安装Grunt最新版本到项目目录中，并将其添加到devDependencies内。</p><p>命令行：<code>$ npm install grunt --save-dev</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm install grunt --save-dev</div><div class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</div><div class="line">npm WARN grunt_demo@1.0.0 No description</div><div class="line">npm WARN grunt_demo@1.0.0 No repository field.</div><div class="line"></div><div class="line">+ grunt@1.0.2</div><div class="line">added 94 packages in 33.833s</div></pre></td></tr></table></figure><p>命令行执行完毕之后，会发现package.json的配置段中信息发生了变更，在devDependencies配置项中增加了grunt字段和对应的版本信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;grunt_demo&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;&quot;,</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;grunt&quot;: &quot;^1.0.2&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>项目的根目录中增加了node_modules文件中，该目录列出了必要的依赖文件，下面给出文件结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 2</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── node_modules</div><div class="line">│   ├── abbrev</div><div class="line">│   ├── ansi-regex</div><div class="line">│   ├── ansi-styles</div><div class="line">│   ├── argparse</div><div class="line">│   ├── array-find-index</div><div class="line">│   ├── async</div><div class="line">│   ├── balanced-match</div><div class="line">│   ├── brace-expansion</div><div class="line">│   ├── builtin-modules</div><div class="line">│   ├── camelcase</div><div class="line">│   ├── camelcase-keys</div><div class="line">│   ├── chalk</div><div class="line">│   ├── coffeescript</div><div class="line">│   ├── colors</div><div class="line">│   ├── concat-map</div><div class="line">│   ├── currently-unhandled</div><div class="line">│   ├── dateformat</div><div class="line">│   ├── decamelize</div><div class="line">│   ├── error-ex</div><div class="line">│   ├── escape-string-regexp</div><div class="line">│   ├── esprima</div><div class="line">│   ├── eventemitter2</div><div class="line">│   ├── exit</div><div class="line">│   ├── find-up</div><div class="line">│   ├── findup-sync</div><div class="line">│   ├── fs.realpath</div><div class="line">│   ├── get-stdin</div><div class="line">│   ├── getobject</div><div class="line">│   ├── glob</div><div class="line">│   ├── graceful-fs</div><div class="line">│   ├── grunt</div><div class="line">│   ├── grunt-known-options</div><div class="line">│   ├── grunt-legacy-log</div><div class="line">│   ├── grunt-legacy-log-utils</div><div class="line">│   ├── grunt-legacy-util</div><div class="line">│   ├── has-ansi</div><div class="line">│   ├── hooker</div><div class="line">│   ├── hosted-git-info</div><div class="line">│   ├── iconv-lite</div><div class="line">│   ├── indent-string</div><div class="line">│   ├── inflight</div><div class="line">│   ├── inherits</div><div class="line">│   ├── is-arrayish</div><div class="line">│   ├── is-builtin-module</div><div class="line">│   ├── is-finite</div><div class="line">│   ├── is-utf8</div><div class="line">│   ├── isexe</div><div class="line">│   ├── js-yaml</div><div class="line">│   ├── load-json-file</div><div class="line">│   ├── lodash</div><div class="line">│   ├── loud-rejection</div><div class="line">│   ├── map-obj</div><div class="line">│   ├── meow</div><div class="line">│   ├── minimatch</div><div class="line">│   ├── minimist</div><div class="line">│   ├── nopt</div><div class="line">│   ├── normalize-package-data</div><div class="line">│   ├── number-is-nan</div><div class="line">│   ├── object-assign</div><div class="line">│   ├── once</div><div class="line">│   ├── parse-json</div><div class="line">│   ├── path-exists</div><div class="line">│   ├── path-is-absolute</div><div class="line">│   ├── path-type</div><div class="line">│   ├── pify</div><div class="line">│   ├── pinkie</div><div class="line">│   ├── pinkie-promise</div><div class="line">│   ├── read-pkg</div><div class="line">│   ├── read-pkg-up</div><div class="line">│   ├── redent</div><div class="line">│   ├── repeating</div><div class="line">│   ├── resolve</div><div class="line">│   ├── rimraf</div><div class="line">│   ├── safer-buffer</div><div class="line">│   ├── semver</div><div class="line">│   ├── signal-exit</div><div class="line">│   ├── spdx-correct</div><div class="line">│   ├── spdx-exceptions</div><div class="line">│   ├── spdx-expression-parse</div><div class="line">│   ├── spdx-license-ids</div><div class="line">│   ├── sprintf-js</div><div class="line">│   ├── strip-ansi</div><div class="line">│   ├── strip-bom</div><div class="line">│   ├── strip-indent</div><div class="line">│   ├── supports-color</div><div class="line">│   ├── trim-newlines</div><div class="line">│   ├── underscore.string</div><div class="line">│   ├── validate-npm-package-license</div><div class="line">│   ├── which</div><div class="line">│   └── wrappy</div><div class="line">├── package-lock.json</div><div class="line">└── package.json</div><div class="line"></div><div class="line">91 directories, 3 files</div></pre></td></tr></table></figure><p>至此，Grunt项目的基本配置以及Grunt的安装已经完成，在开发中使用Grunt主要是用Grunt相关的一些插件来实现特定的功能。Grunt的生态中提供了非常丰富的插件，我们可以直接在官方搜索查看，接下来给大家介绍几个在前端项目构建中常用到的插件。</p><h4 id="1-3-3-Grunt插件的安装和使用"><a href="#1-3-3-Grunt插件的安装和使用" class="headerlink" title="1.3.3 Grunt插件的安装和使用"></a>1.3.3 Grunt插件的安装和使用</h4><p><strong> ✧ <span style="color:#195">文件合并插件concat的安装和使用 </span>✧ </strong></p><p>concat插件的地址：<a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank" rel="external">https://github.com/gruntjs/grunt-contrib-concat</a></p><p>concat插件安装命令：<code>$ npm install grunt-contrib-concat --save-dev</code></p><p><code>--save-dev</code>参数表示插件安装完成后，记录相关信息到package.json文件中的devDependencies配置项。</p><p>下面列出具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm install grunt-contrib-concat --save-dev</div><div class="line">npm WARN grunt_demo@1.0.0 No description</div><div class="line">npm WARN grunt_demo@1.0.0 No repository field.</div><div class="line"></div><div class="line">+ grunt-contrib-concat@1.0.1</div><div class="line">added 2 packages in 3.165s</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC",</div><div class="line">  "devDependencies": &#123;</div><div class="line">    "grunt": "^1.0.2",</div><div class="line">    "grunt-contrib-concat": "^1.0.1"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>插件安装完成后，在项目的node_modules文件目录会新增加grunt-contrib-concat模块。接下来我们通过编辑Gruntfile文件来定义和配置Task。</p><p>在项目的根目录中创建src文件夹，在该文件夹下面创建两个示例的js文件，分别为demo_one.js和demo_two.js</p><p>demo_one.js文件的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明demoOne函数并执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"demoOne.js文件中的内容"</span>);</div><div class="line">&#125;</div><div class="line">demoOne();</div></pre></td></tr></table></figure></p><p>demo_two.js文件的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明demoTwo函数并执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"demoTwo.js文件中的内容"</span>);</div><div class="line">&#125;</div><div class="line">demoTwo();</div></pre></td></tr></table></figure></p><p><strong><span style="color:#f25">编辑Gruntfile文件定义和配置Task</span></strong></p><p>接下来我们需要编辑Gruntfile文件，在该文件中告诉grunt具体的任务(Task)是什么，以及这些任务(Task)应该如何执行，下面给出示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数,规定所有的代码都需要写在该函数内部</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//项目配置信息</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">        <span class="comment">//表示从package文件中加载json数据,并保存到pkg属性中</span></div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//concat任务的配置信息</span></div><div class="line">        <span class="string">"concat"</span>:&#123;</div><div class="line">            dist: &#123;</div><div class="line">                <span class="comment">//把src目录下面的demo_one和demo_two文件合并成demo.js文件保存到dist目录</span></div><div class="line">                src: [<span class="string">'src/demo_one.js'</span>, <span class="string">'src/demo_two.js'</span>],</div><div class="line">                dest: <span class="string">'dist/demo.js'</span>,</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">//加载包含concat任务的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//设置默认执行的任务列表</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>代码说明</strong></p><p>上面的示例代码主要由三部分组成：<code>配置任务相关代码</code> + <code>加载插件相关代码</code> + <code>注册任务相关代码</code>,所有的代码都需要写在module.exports这个包装函数内部，grunt作为包装函数的参数传递。</p><p> 这里代码中的pkg部分并非必要，loadNpmTasks方法用于从node_modules中加载对应的插件，registerTask方法表示把concat这个任务加入到默认的任务队列中(该行代码并非必需)，如果不写该行代码则可以直接以<code>$ grunt concat</code>的方式执行合并任务。当然也可以通过registerTask方法来给Task注册个别名，然后通过<code>$ grunt 别名</code>指令来执行该Task。</p><p>当前的目录结构如下(注：省略node_modules目录细节)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 1</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── demo_one.js</div><div class="line">    └── demo_two.js</div></pre></td></tr></table></figure></p><p>不同插件的使用方式可能也不尽相同，插件的具体用法请参考对应的文档说明。通过编辑Gruntfile文件指定任务的配置项、加载插件并注册任务后，就可以通过命令行来执行Task了。</p><p><strong><span style="color:#f25">执行Task</span></strong></p><p>执行Task的命令行：<code>$ grunt</code> 或者是<code>$ grunt default</code> 或者是<code>$ grunt concat</code><br>命令行输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ grunt default</div><div class="line">Running &quot;concat:dist&quot; (concat) task</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>Task执行结束后，src目录下面的demo_one.js和demo_two.js两个文件会被合并成demo.js文件并保存到dist目录下，如果指定的目录不存在那么将会直接创建。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt_01.png?raw=true" height="200px"></p><p><strong> ✧ <span style="color:#195">压缩插件uglify和cssmin的安装和使用 </span>✧ </strong></p><p>创建新的文件目录Grunt_Test来演示javaScript的压缩插件uglify以及CSS的压缩插件cssmin的使用，创建好文件目录之后，同样通过<code>$ npm init</code>初始化命令来生成基础的package.json文件。</p><p>先安装grunt到本地的项目中，具体命令如下：</p><p><code>$ npm install grunt --save-dev</code></p><p>然后下载需要用到的对应插件到本地的项目中，具体命令如下 ：</p><p><code>$ npm install grunt-contrib-uglify --save-dev</code>   表示安装uglify插件</p><p><code>$ npm install grunt-contrib-cssmin --save-dev</code>   表示cssmin插件</p><p>上面的命令行执行完毕后，grunt就会把两个压缩插件下载到node_modules文件目录下，可以通过在该目录下查找grunt-contrib-uglify和grunt-contrib-cssmi文件进行验证。</p><p><code>--save--dev</code>参数会把下载记录更新到package.json文件中的devDependencies字段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">"grunt": "^1.0.2",</div><div class="line">    "grunt-contrib-cssmin": "^2.2.1",</div><div class="line">    "grunt-contrib-uglify": "^3.3.0"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>为了演示压缩插件的具体使用，下面我们在项目根目录下创建index.js文件，并新建style文件夹，并在该目录下创建index.css文件，具体的目录结构如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── node_modules</div><div class="line">│   ├── ...(省略)</div><div class="line">│   ├── grunt-contrib-cssmin</div><div class="line">│   ├── grunt-contrib-uglify</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">├── index.js</div><div class="line">└── style</div><div class="line">└── index.css</div></pre></td></tr></table></figure></p><p>index.js文件内容为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by wendingding on 18/5/19.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"文顶顶"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"______"</span> + c);</div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure></p><p>index.css文件内容为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">    <span class="attribute">background</span>: red;</div><div class="line">&#125;</div><div class="line">*&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来我们创建并编辑Gruntfile文件，通过特定的代码定义和配置Task。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> app = &#123;</div><div class="line">        src:<span class="string">"src/"</span>,</div><div class="line">        dist:<span class="string">"dist/"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//(1) 项目配置信息</span></div><div class="line">    <span class="comment">//说明：initConfig方法等价于grunt.config.init()方法;</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">    <span class="comment">//定义js文件压缩Task: 表示把src目录下面的index.js文件压缩到dist目录中的index.min.js</span></div><div class="line">        <span class="string">"uglify"</span>:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:app.src + <span class="string">"index.js"</span>,</div><div class="line">                dest:app.dist + <span class="string">"index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    <span class="comment">//定义css文件压缩Task: 表示把src/style目录中的index.css文件压缩到dist目录中的index.min.css</span></div><div class="line">        <span class="string">"cssmin"</span>:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:app.src + <span class="string">"style/index.css"</span>,</div><div class="line">                dest:app.dist + <span class="string">"index.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2) 加载对应的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//(3) 注册任务</span></div><div class="line">    <span class="comment">//002 注册任务的第一种方式</span></div><div class="line">    <span class="comment">//① 这种方式可以不写任何注册任务相关的代码</span></div><div class="line">    <span class="comment">//② 我们可以通过$ grunt uglify和$ grunt cssmin命令来分别执行这两个Task</span></div><div class="line">    <span class="comment">//③ 支持以$ grunt uglify cssmin的方式来依次执行多个Task</span></div><div class="line"></div><div class="line">    <span class="comment">//002 注册任务的第二种方式</span></div><div class="line">    <span class="comment">//① 这种方式相当于给每个任务都起一个Task名称，通过$ grunt task名称的方式执行</span></div><div class="line">    <span class="comment">//② 执行命令 $ grunt uglifyTask 表示执行js文件的压缩操作</span></div><div class="line">    <span class="comment">//③ 执行命令 $ grunt cssminTask 表示执行css文件的压缩操作</span></div><div class="line">    <span class="comment">//④ 执行命令 $ grunt cssminTask uglifyTask 表示先执行css文件的压缩，再执行js文件的压缩</span></div><div class="line">    <span class="comment">//grunt.registerTask("uglifyTask","uglify");</span></div><div class="line">    <span class="comment">//grunt.registerTask("cssminTask","cssmin");</span></div><div class="line"></div><div class="line">    <span class="comment">//003 注册任务的第三种方式</span></div><div class="line">    <span class="comment">// ① 这种方式把多个任务添加到default任务队列中，执行$ grunt default的时候，所有的Task依次执行</span></div><div class="line">    <span class="comment">// ② 执行命令为 $ grunt default 或者是$ grunt  因为default可以被省略</span></div><div class="line">    <span class="comment">// grunt.registerTask("default",["uglify","cssmin"]);</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>根据任务注册的不同方式来执行Task，下面分别给出三种方式的执行命令</p><p>方式（1）先执行<code>$ grunt cssmin</code>再执行 <code>$ grunt uglify</code>，或者通过<code>$ grunt cssmin uglify</code>命令来依次执行多个任务。</p><p>方式（2）先执行<code>$ grunt cssminTask</code>再执行 <code>$ grunt uglifyTask</code>，或者通过<code>$ grunt cssminTask uglifyTask</code>命令来依次执行多个任务。</p><p>方式（3）通过<code>$ grunt</code>或者是<code>$ grunt default</code>命令来依次执行多个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Test wendingding$ grunt default</div><div class="line">Running &quot;uglify:target&quot; (uglify) task</div><div class="line">&gt;&gt; 1 file created 174 B → 93 B</div><div class="line"></div><div class="line">Running &quot;cssmin:target&quot; (cssmin) task</div><div class="line">&gt;&gt; 1 file created. 89 B → 57 B</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>当两个任务执行完毕后，项目中会创建dist目录，该目录中新增两个文件分别对应压缩版的js文件和压缩版的css文件，新的目录结构如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── node_modules</div><div class="line">│   ├── ...(省略)</div><div class="line">│   ├── grunt-contrib-cssmin</div><div class="line">│   ├── grunt-contrib-uglify</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">├── dist</div><div class="line">│   ├── index.min.js</div><div class="line">│   └── index.min.css</div><div class="line">└── src</div><div class="line">├── index.js</div><div class="line">└── style</div><div class="line">└── index.css</div></pre></td></tr></table></figure></p><p>上文列出了代码合并插件concat和压缩插件uglify|uglify的安装和基本使用过程，grunt生态系统拥有数量庞大的高质量插件群体，无法一一介绍，可以到<a href="http://www.gruntjs.net/plugins" target="_blank" rel="external">Grunt相关的插件列表页面-中文</a>或<a href="https://gruntjs.com/plugins" target="_blank" rel="external">Grunt相关的插件列表页面-官网</a>自行查看。</p><blockquote><p><strong><span style="color:#f25">Grunt插件使用总结</span></strong></p><p>❏ 创建package.json文件(简单配置)和Gruntfile文件(<code>$ npm init</code>)<br>❏ 通过命令行把Grunt下载和安装到本地项目中(<code>$ npm install grunt --save-dev</code>)<br>❏ 通过命令行把Grunt插件下载和安装到本地项目中(<code>$ npm install grunt-contrib-xxx</code>)<br>❏ 在Gruntfile文件中对Grunt插件的Task进行配置（grunt.initConfig）<br>❏ 在Gruntfile文件中通过代码来加载对应的插件（grunt.loadNpmTasks）<br>❏ 在Gruntfile文件中通过代码来注册任务（grunt.registerTask）<br>❏ 在命令行中通过grunt + 任务名的方式来执行Task或加入到default队列以grunt命令执行。</p></blockquote><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍前端开发中常用的构建工具Grunt，具体包括Grunt的基本情况、安装、使用和常见插件的安装、配置和使用等内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-Grunt简单介绍&quot;&gt;&lt;a href=&quot;#1-1-Grunt简
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [010]-孩子王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B010%5D-%E5%AD%A9%E5%AD%90%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/17/读书笔记 [010]-孩子王/</id>
    <published>2018-05-17T14:11:18.000Z</published>
    <updated>2018-06-11T02:08:44.859Z</updated>
    
    <content type="html"><![CDATA[<div style="color:#195; font-size:20px">※·※（一）※·※</div><p>一九七六年，我在生产队已经干了七年。</p><p>我想了许久，心里有些紧张，想不通为什么要我去教书，又觉得有些得意，毕竟有人看得起，只是不知是谁。</p><p>我钻进去，黑黑的先是什么也看不清，慢慢就分辨出一块五柳平方米的间隔来。</p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>上午收拾停当，下午便开始教书了。老陈叫我去，教给我一个很脏的课本和一盒粉笔，还有红、蓝墨水，一直蘸水钢笔，一个备课本。</p><p>山野里很难有这种景象，这样多的蓬头垢面的娃子如分吃什么般聚坐在一起。</p><p><span style="color:#f25">“哈！做官没有印，读书不发书。”</span></p><p>书是没有的。咱们地方小，订了书，到县里去领，常常就没有了，说是印不出来，不够分。别的年级来了几本，学生们伙着用，大部分还是要抄的。这里和大城市不一样呢。</p><p>牛是极犟的东西，而且有气度，任打任骂，慢慢眨着眼吃它想吃的东西。</p><p>学生比牛好管多了。</p><p>书都没有，老起什么立？</p><p>教室前的场子没了学生，显出空旷。阳光落在地面，有些晃眼。</p><p>王福穿一件极短的上衣，胳膊露出半截。裤子也极短，揪皱着，一双脚极大。他用手拈起一支粉笔，手极大。</p><p>我收拾着一应教具，觉得这两节课尚有收获，结结实实地教了几个字，有如一天用锄翻了几分山地，记工员来量了，认认真真地记在账上。</p><p>我心里呀了一声，这王七桶我是认识的。王七桶绰号王稀屎。</p><p>车开到半路遇到泥泞，他总是爬下去。</p><p>我于是知道王福是王七桶的儿子，就说：“你爹我知道，很能干。”</p><p>王福说：“算上今天的一共三千四百五十一个字。” 我吃了一惊，说：“这么精确？” 王福说：“不信你数。”</p><p>不识字，大约是文盲，读不懂，大约是文化盲。</p><p><span style="color:#f25">老黑说：“中央台说了上句，我能对出下句，那都是套路，我摸得很熟，不消听。”我笑起来，说：“大约全国人民都很熟。我那个班上的学生，写作文，社论上的话来得个熟，不用教。你出个庆祝国庆的作文题，他能把去年的十一社论抄来，你还觉得一点儿不过时。”</span></p><p><span style="color:red">支书说：“家有隔夜粮，不当孩子王。学生们可闹？”</span></p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>我忽然觉得，愈是简单的事，也许真的愈不容易。</p><p>我家没有表，我起来了，我穿起衣服，我洗脸，我去伙房打饭，我吃了饭，洗了碗，我拿了书包，我没有表，我走了多久，山有雾，我到学校，我坐下，上课。</p><p>王福很高兴，眼白闪起来，抹一抹嘴。</p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p>课文于是不再教，终日只是认字，选各种事情来写。</p><p>记录一件事，永远在事后，这个道理是扳不动的。</p><p>我输了。<span style="color:#f25">我不要，我要——我要把字典抄下来。每天抄，五万字，一天抄一百，五百天。我们抄书，抄了八年呢。</span></p><div style="color:#195; font-size:20px">※·※（五）※·※</div><p>自此，每日放了学，王福便在屋中抄字典。我每每点一支烟在旁边望着他抄。有时怀疑起来，是不是我害了学生？书究竟可以这样教吗？学也究竟可以这样学吗？初时将教书看得严重，现在又将学习搞得如此呆板，我于教书，到底要负怎么样的责任？</p><div style="color:#195; font-size:20px">※·※（六）※·※</div><p><strong>我的父亲</strong></p><p><span style="color:#f25">我的父亲是世界中力气最大的人。他在队里扛麻袋，别人都比不过他。我的父亲又是世界上吃饭最多的人。家里的饭，都是母亲让他吃饱。这很对，因为父亲要做工，每月拿钱来养活一家人。但是父亲说：“我没有王福力气大，因为王福在识字。” 父亲是一个不能讲话的人，但我懂他的意思，队上有人欺负他，我明白。所以我要好好学文化，替他说话。父亲很辛苦，今天他病了，后来慢慢爬起来，还要去干活，不愿失去一天的钱。我要上学，现在还替不了他。早上出的白太阳，父亲在山上走，走进白太阳里去。我想，父亲有力气啦。</span></p><p>“课在上，但是课文没有教。”吴干事又说：“为什么？” 我想一想，终于说：“没有用”。</p><p>第二天极早的时候，我回来收拾了行李，将竹笆留在床上，趁了大雾，扛着行李沿山路去了三队。太阳依旧是白白的一圈。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※（一）※·※&lt;/div&gt;

&lt;p&gt;一九七六年，我在生产队已经干了七年。&lt;/p&gt;
&lt;p&gt;我想了许久，心里有些紧张，想不通为什么要我去教书，又觉得有些得意，毕竟有人看得起，只是不知是谁。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [009]-树王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B009%5D-%E6%A0%91%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/17/读书笔记 [009]-树王/</id>
    <published>2018-05-17T02:11:18.000Z</published>
    <updated>2018-06-11T02:08:44.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>按：《树王》承袭前作，立意似乎更甚，更富有想象力，更生动，对自然和人物的刻画入木三分。</p></blockquote><div style="color:#195; font-size:20px">※·※（一）※·※</div><p>知青中，李立是好读书的人。</p><p>吃完了饭，李立提议来个营火晚会。</p><p>生产队就在大山缝脚下，从站的地方望上去，森林的林子似乎要压下来，月光下只觉得如同鬼魅。</p><p>“接受贫下中农再教育，建设祖国，保卫祖国，改变一穷二白。”</p><p><span style="color:#F25">“把没用的树砍掉，种上有用的树。”</span></p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>山上原来极难走。</p><p>我忽然觉得这山像人脑的沟回，只不知其中思想着什么。又想，一个国家若都是山，那实际的面积比只有平原要多很多。</p><p>李立反插了腰，深深地吸一口气，说：“伟大。改造中国，伟大。”大家都同意着。</p><p>我生平从未见过这样大的树。</p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>第三天，大家便开始上山干活。活计自然是砍树。千百年没人动过这原始森林，于是整个森林长成一团。树都相互躲让着，又都互相争夺着，从上到下，无有闲处。</p><p>李立原并不十分强壮，却有一股狠劲，是别人比不得的。</p><p>队上发刀的头一天，我便用了三个钟头将刀磨得锋快。<span style="color:#f25">人有利器，易起杀心。</span>上到山上，逢物便砍，自觉英雄无比。只是一到砍树，刃常常损缺。</p><p>他想了想，看看了手，伸给我一只，说：“苦的很，你摸摸，苦的很，大比武，苦的很。”我摸一摸肖疙瘩的手。这手极硬，若在黑暗中触到，认为是手的可能性很小。而且这手的指头短而粗。肖疙瘩将手背翻过来，指甲极小，背上的肉也如一层石壳。</p><p><strong>磨刀 学习如何正确磨刀 送磨刀石</strong></p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p><strong>砍倒了山顶的巨树</strong></p><p><span style="color:#F25">树明明倒了，却没有巨大的声响。</span></p><p>我忽然觉得风冷，回过神来，才觉出一身凉汗，见大家也都有些缩头缩脑，开始有话，只是低低的地说。</p><p>天更暗了，月亮不再黄，青白地照过来，一山的断树奇奇怪怪。</p><div style="color:#195; font-size:20px">※·※（五）※·※</div><p><strong>给六爪买糖</strong></p><p>月光仍旧很亮，我不由站在场上，四下望望。目力所及的山上，树都已经翻倒，如同尸体，再没有初来时的神秘。</p><div style="color:#195; font-size:20px">※·※（六）※·※</div><p><span style="color:#F25">山上的树木终于都被砍倒。每日早晨的太阳便觉得格外刺眼。</span></p><p>原来肖疙瘩本是贵州的一个山民，年轻时从家乡入伍。部队上见他顽勇，又吃得苦，善攀登，便叫他干侦察。62年部队练兵大比武，肖疙瘩成绩好，于是被提为一个侦察班长。</p><p>渐渐不能明白<span style="color:#f25">为什么要将好端端的森林断倒烧掉，用有用的树换 有用的树，半斤八两的账算不清，自然有些怀疑怨言</span>。</p><p>“李立也是抽风，说是要砍对面山上那颗树王，破除迷信。”</p><p>李立不以为然，站起来说：<span style="color:#f25">“重要的问题是教育农民。旧的东西，是要具体去破的。树王砍不砍，说到底，没什么。可是树王一倒，一种观念就被破除了，迷信还在其次，重要的是，人在如何建设的问题上将会思想为之一新，得到净化。”</span></p><p>李立叫了支书，支书并不拿刀，叫了队长，队长也不拿刀，大家一齐上山。</p><div style="color:#195; font-size:20px">※·※（七）※·※</div><p>一张白纸，好画最新最美的图画。</p><p>学生们造反，皇帝都拉下马了，人家砍了头说是有个碗大的疤。你砍了头，可有碗大的疤？就是有，你那个疤值几个钱？糊涂！</p><p>原来护着树根的这个矮小汉子，才是树王！</p><p>支书说：“砍吧！总归是要砍，学生们有道理，不破不立，砍。”</p><div style="color:#195; font-size:20px">※·※（八）※·※</div><p><strong>砍树 砍倒 树王</strong></p><p>大树整整砍了四天，肖疙瘩也整整在旁边守了四天，一句话不说，定定地看刀在树上起落。</p><p>我坐了一会儿，见肖疙瘩如无魂的一个人，只有悄悄回来。</p><div style="color:#195; font-size:20px">※·※（九）※·※</div><p>防火带终于锄好，队长宣布要烧山了。</p><p><span style="border:1px solid #000">&nbsp;&nbsp; 这一章的描写精彩至极 &nbsp;&nbsp;</span></p><p>大伙霎时封了山顶，两边的火撞在一起，腾起几百丈高，须仰视才见。那火的顶端，舔着通红的天底。我这才明白，我从未真正见过火，也未见过毁灭，更不知新生。</p><p>山上是彻底地沸腾了。数万棵大树在火焰中离开大地，升向天空。</p><div style="color:#195; font-size:20px">※·※（十）※·※</div><p>这之后，肖疙瘩便一病不起。</p><p>我每日去看他，日见其枯缩。原来十分强悍而沉默的一个汉子，现在沉默依旧，强悍却渐渐消失。</p><p>大火烧失了大家的精神，大家又似乎聚德要有个结果，才得寄托。</p><p>“”我的女人与娃儿不识字，我不行了，要写一封书信给他，说我最后还是对不起他，请他原谅我先走了——”</p><p>葬的地方肖疙瘩也说过，就在离那棵巨树一丈远的地方。大家抬了棺材上山，在树桩根边挖了坑，埋了。那棵巨树仍仰翻在那里，端口刀痕累累，枝叶已经枯掉，却不脱落，仍有鸟儿飞来立在横倒的树身上栖息。</p><p>当天便有大雨。</p><p>一座山秃秃的，尚有未烧完的大树残枝，黑黑的立着，如果宇宙有箭飞来，深深射入山的裸体，只留黑羽箭尾在外面。</p><p><span style="color:#F25">肖疙瘩的骨殖仍埋在原来的葬处。这地方渐渐就长出一片草，生白花。有懂得的人说：这草是药，极是医得刀伤。大家在山上干活时，常常歇下来望，便能看到那棵巨大的树桩，有如人跌破后留下的疤；也能看到那片白花，有如肢体被砍伤，露出白白的骨。</span></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;按：《树王》承袭前作，立意似乎更甚，更富有想象力，更生动，对自然和人物的刻画入木三分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※（一）※·※&lt;/div&gt;

&lt;p&gt;知青
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [008]-棋王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B008%5D-%E6%A3%8B%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/16/读书笔记 [008]-棋王/</id>
    <published>2018-05-16T12:57:18.000Z</published>
    <updated>2018-06-11T02:08:44.835Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：棋王应该是阿城最好的一部小说，阿城也由《棋王》《树王》《孩子王》盛名。</div><p><a href="https://book.douban.com/subject/26382501/" target="_blank" rel="external">《棋王》</a>作者<a href="https://book.douban.com/author/122104/" target="_blank" rel="external">阿城</a>，原名钟阿城，1949年生人。阿城被认为是伤痕文学的代表人物，我不太懂伤痕文学，只是读他的文字，恰如身临其境，故事娓娓道来，文字运用的妙极，只因我个人素养和学识有限，很难准备表达，但这不影响我对这位作家的尊重和喜欢，恰如王小波。</p><p>阿城的《棋王》和王小波的《黄金时代》给我一种恍恍惚惚浑然一体的感觉，这本书以特定历史为背景描写了一位“棋王”。据说有读者读完《黄金时代》后，竟跑去问询李银河女士，“是否认识陈清扬？和陈清扬还有联系吗？” 哈哈，或许这也正是写作的魅力之一。如果你读过这部小说，或许你也会如此？这两本书虽然风格不同，但都描述知青岁月，味道浓正。</p><p>每个人阅读的方式不同，我读第一遍的时候喜欢捧着书慢读，第二遍的时候有详有略，并且喜欢勾勾画画，读完之后我可能会把阅读过程中的点滴记录整理成文，于是就有了这样的一些读书笔记。</p><div style="color:#195; font-size:20px">※·※（一）※·※</div><p>我的几个朋友，都已经被我送走插队，现在轮到我了，竟没有人来送。父母生前颇有些污点，运动一开始就被打翻死去。</p><p><strong> 我的视角：特殊时期背景，父母双亡，下乡插队。</strong></p><p>我知道棋呆子就是王一生，可不知道王一生就是他。</p><p>王一生简直大名鼎鼎。</p><p>一路下去，慢慢发现我和王一生之间，既开始有互相的信任和基于经验的同情，又有各自的疑问。</p><p><strong>接下来的很大一部分篇幅，我和王一生讨论了吃的问题，经历过那段时期的人也许更能体会。</strong></p><p>人吃饭，不但是一肚子的需要，更是一种精神需要。</p><p><span style="color:#f25">何以解忧，唯有象棋。何以解不痛快，唯有象棋。</span></p><p>他对吃是虔诚的，而且很精细。有时你会可怜那些饭被他吃得一个渣儿都不剩，真有点儿惨无人道。我在火车上一直看着他下棋，发现他同样是精细的，但就有气度的多。</p><div class="tip">按：这段话是王一山给我讲如何学棋的经过,后面有一段阴阳相交的论述非常精彩</div><p>老头让我先说。我们俩就在垃圾站下盲棋，我是连输五盘。</p><p><span style="color:#f25">为棋不为生，为棋是养性</span>，生会坏性，所以生不可以太盛。</p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>这个农场在大山林里，活计就是砍树，烧山，挖坑，再栽树。不栽树的时候，就种点儿粮食。</p><p>山上总要放火，野兽们都惊走了，很难打到。</p><p>即使打到，野物们走惯了，没膘，熬不得油。尺把长的老鼠也捉来吃，因为老鼠是吃粮的，大家说鼠肉就是人肉，也算吃人吧。</p><p>你在车上给我讲的两个故事，我琢磨了，后来挺喜欢的。你不错，读了不少书。可是归根到底，解决什么呢？是呀，一个人拼命想活着，最后都神经了，后来好了，活下来了，可接着怎么活呢？</p><p>人要知足，顿顿饱就是福。</p><p><strong>王一生家庭的情况</strong></p><p>你家里到底是怎么个情况呢？</p><p>他叹了一口气，望着屋顶，很久才说：“穷。困难啊！我们家三口人儿，母亲死了，只有父亲，妹妹和我。我父亲嘛，挣得少。”</p><p><strong>母亲 家世 无字棋</strong></p><p><span style="color:red">妈不能看你念完初中，跟你爹说了，怎么困难也要念完。高中，妈打听了，那是为上大学，咱们家用不着上大学，你爹也不行了，你妹妹还小，等你初中念完了就挣钱，家里就靠你了。妈要走了，一辈子也没给你留下什么，只捡人家的牙刷把，给你磨了一幅棋。</span></p><p>不一刻，蛇肉吃完，只剩下两副蛇骨在碗里。</p><p>大家就说这燕窝一定非常好吃。脚卵又微微一笑，说：“我吃过的，很腥。”大家就感叹了，说费那么多钱，吃一口腥，太划不来。</p><p>天黑下来，早升在半空的月亮渐渐亮了。我点起油灯，立刻四壁都是人影子。</p><p>不久，脚卵抬起头，看着王一生说；<span style="color:#f25">“天下是你的”</span>。抽出一支烟给王一生，又说：<span style="color:#195">“你的棋是跟谁学的？” 王一生也看着脚卵，说：“跟天下人。”</span>脚卵说：“蛮好，蛮好，你的棋蛮好。”</p><p><strong>文教书记 调动</strong></p><p>这次运动会，他来信告诉我，让我争取参加农场的棋类队到地区的比赛，赢了，调动自然好说。</p><p>王一生叹一口气，说：“倪斌是个好人。”</p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>这以后，大家没事儿，常提起王一生，津津有味的回忆王一生光膀子大战脚卵。我说了王一生如何如何不容易，脚卵说：“我父亲说过的，寒门出高士”。</p><p>王一生很着急的样子，说：“这半年我总是请事假出来下棋，等我知道报名赶回去，分场说我表现不好，不准我出来参加比赛，连名都没报上。”</p><div class="tip">按 书记暗示倪斌以家里古玩换取工作调动，顺带解决王一生参赛的问题。</div><p>王一生在黑暗里说：“我不赛了，没意思。倪斌是好心，可我不想赛了。”</p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p>人是越来越多，后来的人拼命的往前挤，挤不进去，就抓住人打听，以为是杀人的告示。</p><p>再也没有人动一下，似乎是要把命放在棋里搏。</p><p>我心里忽然有一种很古来的东西涌上来，喉咙紧紧的往上走。</p><p>这种阵势，我从来也没有见过，你想想看，九个人与他一个人下，九局连环！车轮大战！我要写信给我的父亲，把这次的棋谱都寄给他。</p><p>王一生的姿势没有变，仍旧是双手扶膝，眼平视着，像是望着极远极远的远处，又像是盯着极近极近的近处，瘦瘦的肩挑着宽大的衣服，土没有拍干净，东一块儿，西一块儿。</p><p>王一生孤身一人坐在大屋子中央，瞪眼看着我们，双手支在膝上，铁铸一个细树桩，似无所见，似无所闻。高高的一盏电灯，暗暗地照在他脸上，眼睛深陷进去，黑黑的似俯视大千世界，茫茫宇宙。</p><p>山民和地区的人层层围了，争睹棋王风采，又都点头儿叹息。</p><p>我笑起来，想：<span style="color:#195">不做俗人，哪儿会知道这般乐趣？家破人亡，平了头每日荷锄，却自有真人生在里面，见识到了，即是幸，即是福。衣食是本，自有人类，就是每日在忙这个。可囿在其中，终于还不太像人。</span></p><div style="color:#195; font-size:20px">※·※（后记）※·※</div><p>棋王这部小说字里行间，可见年代的质感，可见尘土飞扬的写意，可见匮乏的物质下丰饶的灵魂。</p><p>王一生和九个人象棋大战，最后和冠军言和，老人说王一生的棋是道家的棋。</p><p>看到这一段的时候并不是特别理解，后来找到阿城的原话解读。</p><p>其实，老者这样说只是要给自己台阶下，不失去了面子。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：棋王应该是阿城最好的一部小说，阿城也由《棋王》《树王》《孩子王》盛名。&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26382501/&quot; target=&quot;_blank&quot; rel=&quot;ex
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [007]-你我皆凡人</title>
    <link href="https://weibo.com/u/3800117445/2018/05/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B007%5D-%E4%BD%A0%E6%88%91%E7%9A%86%E5%87%A1%E4%BA%BA/"/>
    <id>https://weibo.com/u/3800117445/2018/05/16/读书笔记 [007]-你我皆凡人/</id>
    <published>2018-05-16T04:38:18.000Z</published>
    <updated>2018-06-11T02:08:44.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://book.douban.com/subject/26383472/" target="_blank" rel="external">你我皆凡人</a>这本书其实是六神磊磊公众号里若干文章的合集，虽然并没有任何实质性的意义但是却很有意思，适合无聊的时候消遣。</p></blockquote><p>王重阳和林朝英的真正问题，在于不会谈恋爱。<br>他们就这样不咸不淡的互相顶着帖，挥霍着年华岁月，还以为这就算是在谈恋爱。</p><p>你也很体面，我也很体面，但是我们的爱情，只收获了一个永远寂静的朋友圈。</p><div class="tip">读到雪山飞狐的时候，是真爱程灵素，远远超过袁紫衣，电视剧也同样。</div><p>程灵素：<code>她对敌人狠，对朋友义，对爱人忠，气度磊落，坦荡豁达。</code></p><p>女士们都在习惯性的仰攻，二流人物的女徒弟，总是想方设法撬一流人物的男徒弟。</p><p>江湖上还有一个规律：越是往基层走，男士就越容易被剩下，而女士反而越不愁嫁。在哪些江湖二三流的门派中，姑娘很抢手，根本不用担心被剩下。最容易被剩下的，反而是程英。</p><div class="tip">程英出场不久，对杨过暗生情愫，在宣纸上写”既见君子 云胡不喜”给我的印象太深刻了。</div><p>程英和郭襄都有点过于理想，最后前者只得到了一句“兄妹之情，皓如日月”，后者只得到一句“咱们就此别过”。</p><p>康敏从来就不清楚自己真正要什么，不断的开辟新战场，把自己在旧战场的缴获轻易的就拼光了。</p><p>“戚芳困境”：女人的一次背叛，不能用另一次背叛来救赎。</p><p>阿紫变成不良少女，主要是因为成长环境太差。几乎完全相同的环境，程灵素却长成了和阿紫完全相反的人：善良、仁爱、宽容、绝不滥杀无辜、心灵十分健全，为什么？唯一的解释就是程灵素有一个师傅——毒手药王。药王对于程灵素的影响不在于教诲，而在于另外两个方面：一是自身超强的学术水平，二是以身作则的宽厚人格。</p><p>在金庸的小说里，记叙了一个让人不忍卒读的故事：一位叫做欧阳锋的执着的古籍善本收藏家最后发了疯。</p><p>在江湖上，有一个名字最狂野、最张狂的教派，叫做日月神教。但讽刺的是，这个组织的头目东方不败先生完全没有这种功能。</p><p><span style="color:#195">金兵有狼牙棒，俺们有天灵盖。</span></p><p>那个江湖上已经没有了伟大的武功，只剩下一些伟大的公公。</p><p><span style="color:#f55">成王败寇是一种残忍的公平。</span></p><p><span style="color:#f55">侠之大者，为国为民。</span>当这八个大字的旗帜高高飘扬在襄阳城上时，郭靖已经是整个江湖的道义领袖和精神导师。</p><p>杨过原本是郭靖-黄蓉家族的成员，而且是郭靖极为看重的嫡系。郭靖送他去全真教拜师，本来是想让他开一家分公司，没想到杨过反而被另一家大企业古墓派猎获，另立门户，后来和郭家一度要决裂。</p><p>第三次华山论剑，它名义上的主题是祭奠洪七公，而它实质上的主题是郭靖-黄蓉联盟一统江湖的加冕礼。</p><p>数十年过去，华山论剑终于从五湖四海的英雄争霸，变成了一家人其乐融融的内部聚会，那所谓东南西北的名号，也从天下豪杰誓死争夺的地盘和版图，变成了郭靖-黄蓉联盟内部商量着分的蛋糕。</p><p>如果郭靖-黄蓉加载有纹章，那么一定是这样的：<span style="color:#195">上空飞舞着双雕，背景是巍峨的华山，衬底的是雄伟的襄阳城。</span></p><p>余沧海在攻入群玉院的时候撞见了华山派大弟子令狐冲。余掌门向他发出了振聋发聩的正义质问：嫖妓宿娼，是甚么行径？但他实在不好意思质问别人“杀人全家，是什么行径”，因为他杀过林震南全家，也不好意思质问别人“抢人钱财，是什么行径”，因为他侵吞人家福威镖局的财产，也不好意思质问别人“夺人武功，是什么行径”，因为他抢过人家的辟邪剑谱。</p><p>侠客行和连城诀是相反的两部书。<br>在一个复杂的世界里，做聪明人无疑是好事，但是在一个太过复杂的世界里，做一个笨人或许也是不坏的选择。</p><p>小圈子里的大人物，一大显著特点是对批评的容忍度往往比较低。但是他们在关起门来面对自己村里的人的时候，会显得无比自信。</p><p>他们越不擅长什么，就越教人家什么。</p><p><span style="color:#195">尊重你自己的行业，尊重你的禀赋特长。</span></p><p>教主常常是最不忠实的员工，这种事发生在各行各业，就好像编写星座知识的人往往最不信星座一样。</p><p>对于粉丝而言，有两样东西最敏感，道德感和自尊心。</p><p>他们的崇拜是一种高利贷。他们对你的喜爱，很容易转化为愤怒，他们付出了尊敬后，会聚精会神、小心翼翼地等待着回报。如果这种预期的回报没有出现，他们就会用十倍的怨毒让你补偿。</p><p>往往开会的人越多，会议越不重要。</p><p>各大门派说，纸是有限的，而钱是无限的，以无限的钱买有限的纸，能不涨价嘛？然而不要忘记了，侠客也是有限的。人们总是下意识的觉得，纸张有限，侠客很多。<code>有一些过剩，是门派性的过剩，有一些短期，是江湖性的短缺。</code></p><p>历史的答案总是隐藏在云雾之中，凡人最难看清楚的，就是当下的时代在历史中所处的位置。</p><p class="tip"><br><strong>后记</strong> ➣<br>其实一本书读完就读完了，这本小书应该是去年早些时候买的，初看挺有意思的，再看觉得那一层意思更浓了，我觉得所有文章中<code>读懂华山论剑</code>写的最好，而<code>《射雕英雄传》：一个关于收藏的故事</code>最有意思。今天整理桌子又看到了这本书，遂记录其间只言片语，这本书以后应该不会再拿起了，因为很多东西意思意思就行了。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26383472/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;你我皆凡人&lt;/a&gt;这本书其实是六神磊磊公众号里若干文章的合集，虽然并没有任何实质性
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[01]-Bower包管理工具的使用</title>
    <link href="https://weibo.com/u/3800117445/2018/05/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B01%5D%20%20Bower%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/05/14/前端工程化系列[01]  Bower的安装和使用/</id>
    <published>2018-05-14T11:45:13.000Z</published>
    <updated>2018-06-11T02:04:44.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍前端开发中常用的包管理工具Bower，具体包括Bower的基本情况、安装、使用和常见命令等内容，最后还介绍了依赖树管理的常见方式以及Bower采用的策略并进行了比较。</p></blockquote><h3 id="1-1-关于Bower"><a href="#1-1-关于Bower" class="headerlink" title="1.1 关于Bower"></a>1.1 关于Bower</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower.png?raw=true" height="200px"></p><p>Bower是一款优秀的包管理器，它由Twitter公司开发，支持以命令行的方式来对包进行搜索、下载、更新和卸载。</p><p><strong>模块或组件</strong>指独立完整的模块，可以是应用的一部分或者是扩展，依赖可以是jQuery或backbone这样的库，也可以像Bootstrap这样的UI框架或者是UI组件。</p><p><strong>包</strong>英文（package）模块或组件的另一种叫法。</p><p><strong>依赖</strong>一个模块为了满足独立完整原则所必须的其他模块，依赖提供了这个模块所需要的功能，如果没有这个功能，那么这个组件就无法工作。例如我们认为jQuery-ui这个组件依赖于jQuery。</p><p><strong>Bower的优点</strong></p><blockquote><p>❑  专为前端开发设计，几乎所有的主流前端库都可以使用该工具。<br>❑  约束松散，使用简单。<br>❑  依赖树扁平更适合Web应用开发。</p></blockquote><p>官网参考：<a href="https://bower.io/" target="_blank" rel="external">https://bower.io/</a></p><h3 id="1-2-Bower的安装"><a href="#1-2-Bower的安装" class="headerlink" title="1.2 Bower的安装"></a>1.2 Bower的安装</h3><p>在安装bower之前，必须确认你已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>。</p><p><strong>安装Bower</strong></p><p>使用npm来安装Bower，-g表示全局安装</p><p><code>$ npm install -g bower</code></p><p><strong>查看Bower版本</strong></p><p>Bower安装完成后就能在命令行中直接使用bower命令了，可以通过下面的命令行来查看当前的版本。</p><p><code>$ bower -v</code> 或者是<code>$ bower -version</code></p><p><strong>查看帮助信息</strong></p><p>使用help命令来查看帮助信息。</p><p><code>$ bower -help</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line"></div><div class="line">    bower <span class="tag">&lt;<span class="name">command</span>&gt;</span> [<span class="tag">&lt;<span class="name">args</span>&gt;</span>] [<span class="tag">&lt;<span class="name">options</span>&gt;</span>]</div><div class="line">Commands:</div><div class="line"></div><div class="line">    cache            Manage bower cache(管理缓存信息)</div><div class="line">    help             Display help information about Bower（显示关于Bower的帮助信息）</div><div class="line">    home             Opens a package homepage into your favorite browser</div><div class="line">    info             Info of a particular package(显示特定包的详细信息)</div><div class="line">    init             Interactively create a bower.json file（交互式创建bower.json文件）</div><div class="line">    install          Install a package locally（安装包到本地）</div><div class="line">    link             Symlink a package folder(在本地bower库建立一个项目链接）</div><div class="line">    list             List local packages - and possible updates（列出本地包以及可能的更新）</div><div class="line">    login            Authenticate with GitHub and store credentials（Github身份认证）</div><div class="line">    lookup           Look up a single package URL by name（根据包名查询包的URL）</div><div class="line">    prune            Removes local extraneous packages（删除项目没有用到的包）</div><div class="line">    register         Register a package（注册一个包）</div><div class="line">    search           Search for packages by name（通过名称来搜索包）</div><div class="line">    update           Update a local package（更新项目的包）</div><div class="line">    uninstall        Remove a local package（移除项目的包）</div><div class="line">    unregister       Remove a package from the registry（注销包）</div><div class="line">    version          Bump a package version（列出版本信息）</div><div class="line">Options:...</div></pre></td></tr></table></figure><h3 id="1-3-Bower的使用"><a href="#1-3-Bower的使用" class="headerlink" title="1.3 Bower的使用"></a>1.3 Bower的使用</h3><p><strong>初始化操作</strong></p><p>在桌面创建新的文件夹，用来演示Bower的使用。先使用命令行进入到文件夹路径，然后使用下面的命令来对Bower进行初始化操作。</p><p><code>$ bower init</code></p><p>根据提示来交互式的设置基本项，初始化操作完成之后，会在文件夹的根目录中创建一个bower.json文件，里面包含一些基本信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"bowerDemo"</span>,</div><div class="line">  <span class="string">"authors"</span>: [</div><div class="line">    <span class="string">"wendingding"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"description"</span>: <span class="string">"Nothing"</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span>,</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"wendingding.com"</span>,</div><div class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"ignore"</span>: [</div><div class="line">    <span class="string">"**/.*"</span>,</div><div class="line">    <span class="string">"node_modules"</span>,</div><div class="line">    <span class="string">"bower_components"</span>,</div><div class="line">    <span class="string">"test"</span>,</div><div class="line">    <span class="string">"tests"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>安装指定的包</strong></p><p>尝试执行下面的命令行，来把jQuery框架安装到当前项目中。</p><p><code>$ bower install --save jquery</code></p><p>命令行中的save参数会把包记录保存到bower.json文件中，install命令会把jQuery框架下载到bower_components目录中，该目录文件是保存所有组件和依赖的地方。当执行install命令的时候，Bower会从仓库中获取到jQuery组件的信息然后和bower.json文件中的信息进行比较，如果jQuery没有安装，那么就会默认安装最新版本，如果已经安装了，则bower会自动停止并提示。</p><p>具体的执行情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bogon:Demo wendingding$ bower install --save jquery</div><div class="line">bower invalid-meta  <span class="keyword">for</span>:<span class="regexp">/Users/</span>文顶顶/Desktop/Demo/bower.json</div><div class="line">bower invalid-meta  The <span class="string">"name"</span> is recommended to be lowercase, can contain digits, dots</div><div class="line">bower cached        https:<span class="comment">//github.com/jquery/jquery-dist.git#3.3.1</span></div><div class="line">bower validate      <span class="number">3.3</span><span class="number">.1</span> against https:<span class="comment">//github.com/jquery/jquery-dist.git#*</span></div><div class="line">bower install       jquery#3.3.1</div><div class="line"></div><div class="line">jquery#3.3.1 bower_components/jquery</div></pre></td></tr></table></figure></p><p>命令执行完毕后，Bower会在根目录下生成bower_components文件夹，并把下载好的包（jQuery框架）放在这个文件夹里面。此时目录结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── bower.json</div><div class="line">└── bower_components</div><div class="line">    └── jquery</div><div class="line">        ├── AUTHORS.txt</div><div class="line">        ├── LICENSE.txt</div><div class="line">        ├── README.md</div><div class="line">        ├── bower.json</div><div class="line">        ├── dist</div><div class="line">        ├── external</div><div class="line">        └── src</div></pre></td></tr></table></figure></p><p>查看bower.json文件会发现，此时更新了包和对应的版本信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"jquery"</span>: <span class="string">"^3.3.1"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><blockquote><p><strong><span style="color:#f55">Bower在执行安装操作的时候，主要做了如下操作：</span></strong></p><p>① &nbsp;检查项目目录中的bower.json文件，以确定包是否已经安装了。<br>② &nbsp;如果指定的包没有安装，那么Bower就会检查Bower仓库中是否存在名称对应的包<br>③ &nbsp;如果Bower仓库中存在指定的包，那么就下载最新版本到本地<br>④ &nbsp;把下载好的包的文件添加到项目目录中，并且更新bower.json文件(包名和版本)</p></blockquote><h3 id="1-4-Bower的常见命令"><a href="#1-4-Bower的常见命令" class="headerlink" title="1.4 Bower的常见命令"></a>1.4 Bower的常见命令</h3><p><strong>安装指定包</strong></p><p><code>$ bower install                               # 通过 bower.json 文件安装</code><br><code>$ bower install jquery                      # 通过在github上注册的包名安装</code><br><code>$ bower install desandro/masonry            # GitHub短链接</code><br><code>$ bower install http://example.com/x.js     # URL路径</code><br><code>$ bower install git://github.com/user/package.git   #Github上的 .git</code></p><p>想要下载安装的包可以是GitHub上的短链接、.git 、一个URL路径等。</p><p><strong>搜索指定的包</strong></p><p><code>$ bower search jquery</code></p><p>如果我们在使用框架或者是框架插件的时候，记不住或者是不确定包的名字，则可以尝试先通过关键字搜索，bower会列出包含关键字的所有可用包。</p><p><strong>安装包的指定版本</strong></p><p><code>$ bower install --save jquery#1.8.0</code></p><p>Bower通过#号来确定需要下载的版本，如果没有指定版本，则Bower自动帮我们下载最新的。所以，如果需要下载特定版本的包，可以在安装命令中使用#号来声明。</p><p>如果要安装指定的版本，也可以先在bower.json文件中对dependencies选项进行配置，然后执行<code>$ bower install</code>或者是<code>$ bower update</code>命令。</p><p><strong>查看已安装的包</strong></p><p> <code>$ bower list</code><br> <code>$ bower list --paths</code></p><p>具体的执行情况如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wendingding$ bower list</div><div class="line">bower check-<span class="keyword">new</span>     Checking <span class="keyword">for</span> <span class="keyword">new</span> versions <span class="keyword">of</span> the project dependencies...</div><div class="line">demo /Users/文顶顶/Desktop/Test</div><div class="line">├── jquery#3.3.1</div><div class="line">└─┬ jquery-ui#1.12.1</div><div class="line">  └── jquery#3.3.1</div><div class="line">wendingding$ bower list --paths</div><div class="line">  jquery: bower_components/jquery/dist/jquery.js</div><div class="line">  jquery-ui<span class="string">': bower_components/jquery-ui/jquery-ui.js</span></div></pre></td></tr></table></figure><p><code>list命令</code>可以查看项目中当前下载过的包，并提供最新版本号。<br><code>paths命令</code>可以查看当前下载过的所有包在项目中的对应路径，在其它工具中需要声明/配置前端依赖包地址的时候该命令可能会比较有用。</p><p><strong>卸载指定的包</strong></p><p><code>$ bower uninstall jquery</code></p><p>卸载本地项目中已经安装的jQuery框架。</p><p><strong>更新指定的包</strong></p><p><code>$ bower update jquery</code></p><p>更新包的过程和安装包的过程差不多，区别在于更新的时候会使用新文件替换旧文件，上面的命令强制安装最新版本的jQuery框架。</p><p><strong>查看指定包的详细信息</strong></p><p><code>$ bower info jquery</code></p><p>通过info指令可以查看指定包的详情，还指令会列出对应的git仓库地址，以及所有可用的版本。</p><h3 id="1-5-Bower安装有依赖的包"><a href="#1-5-Bower安装有依赖的包" class="headerlink" title="1.5 Bower安装有依赖的包"></a>1.5 Bower安装有依赖的包</h3><p>通常当我们使用Bower命令(<code>bower install --save xxx</code>)来安装指定包的时候，Bower会查找包对应的git仓库地址然后下载到本地并在bower.json文件中记录版本等信息。但有的包在使用的时候可能存在依赖关系，比如ember这个包需要依赖于jQuery框架。</p><blockquote><p><strong>使用Bower安装有依赖包的两种方式</strong><br>❑  先安装该包的依赖项（这里为jQuery），再安装指定的包（这里为ember）<br>❑  直接安装（这里为ember）</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;方式 ① &nbsp; &nbsp;</strong></span></p><p>先安装依赖,再安装指定包</p><p><code>$ bower install --save jquery</code><br><code>$ bower install --save ember</code><br><code>$ bower list</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">├─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">│ └── jquery#3.3.1</div><div class="line">└── jquery#3.3.1</div></pre></td></tr></table></figure><p><span style="border:1px solid#000"><strong>&nbsp; &nbsp;方式 ② &nbsp; &nbsp;</strong></span></p><p>直接安装指定包,会自动安装依赖(推荐)</p><p><code>$ bower install --save ember</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bower invalid-meta  for:/Users/文顶顶i/Desktop/Test/bower.json</div><div class="line">bower cached        https://github.com/components/ember.git#2.18.2</div><div class="line">bower validate      2.18.2 against https://github.com/components/ember.git#*</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#&gt;=1.7.0<span class="tag">&lt;<span class="name">4.0.0</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">ember</span>#<span class="attr">2.18.2</span> <span class="attr">bower_components</span>/<span class="attr">ember</span></span></div><div class="line"><span class="tag">└── <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">jquery</span>#<span class="attr">3.3.1</span> <span class="attr">bower_components</span>/<span class="attr">jquery</span>`</span></div></pre></td></tr></table></figure><p>列出项目中已经安装的所有包和依赖关系</p><p><code>$ bower list</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">└─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">  └── jquery#3.3.1</div></pre></td></tr></table></figure></p><p>该命令行在安装ember包的时候，发现需要依赖于jQuery框架，就会自动下载对应版本的jQuery框架并安装到本地项目中。</p><h3 id="1-6-依赖树管理"><a href="#1-6-依赖树管理" class="headerlink" title="1.6 依赖树管理"></a>1.6 依赖树管理</h3><p>组件(包)并非总是相互独立的，有些组件(包)在使用的时候需要依赖于另外一些组件(包)，就像上文提到的ember需要依赖于jQuery，jQuery-ui需要依赖于jQuery一样，我们尝试使用下面的图示来描述这种关系。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree1.png?raw=true"></p><p>上面的图示揭示了包（组件）与包（组件）之间的依赖关系，非常简单容易理解。在实际中，每个组件可能都有多个依赖，而这些依赖自己可能还有别的依赖，或者多个不同组件都依赖于某个指定的组件，因此在处理的时候可能会非常复杂。为了理清楚这复杂的关系，依赖管理工具会把所有的依赖构成一颗<code>Dependency Tree</code>（依赖树）。</p><blockquote><p><strong>依赖树主要有三种</strong><br>❑   嵌套依赖树<br>❑   扁平依赖树<br>❑   混合依赖树</p></blockquote><p>注意：在构造依赖树的时候，组件（包）必须要有唯一的标识，该标识由组件的名称和版本号构成，也就是说jQuery1.7.3和jQuery3.3.1是两个不同的组件。</p><p><strong>嵌套依赖树</strong></p><p><code>基本理念</code>：每个组件各自都有自己的依赖，而不会共用一个依赖。<br><code>主要问题</code>：项目中会产生同一组件的多个副本，且可能有多个版本的组件共存比较混乱。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree2.png?raw=true"></p><p><strong>扁平依赖树</strong></p><p><code>基本理念</code>：保证每个组件在项目只有一个版本，没有任何其它的副本。<br><code>主要问题</code>：容易产生冲突，如果两个组件需要同一个依赖的不同版本，就会导致出错，必须要用户自己来解决冲突，决定具体使用哪个依赖并解决潜在的不一致性。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree3.png?raw=true"></p><p><strong>混合依赖树</strong></p><p><code>基本理念</code>：使用最高效的办法来管理一个组件的不同版本。<br><code>主要特点</code>：混合依赖树是扁平依赖树和嵌套依赖树的折中方案，如果一个组件的依赖已经安装了，而且版本也兼容，那么就不必再次下载安装，只要指向已安装的那个组件即可，如果版本不兼容的话，则下载安装并版本兼容的组件。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree4.png?raw=true"></p><h3 id="1-7-Bower依赖树管理和冲突处理"><a href="#1-7-Bower依赖树管理和冲突处理" class="headerlink" title="1.7 Bower依赖树管理和冲突处理"></a>1.7 Bower依赖树管理和冲突处理</h3><p>Bower作为专为前端开发者设计的依赖管理工具，是完全基于扁平依赖树的。上文介绍了扁平依赖树在处理的时候要求<strong>保证每个组件在项目只有一个版本，没有任何其它的副本</strong>，优缺参半。那既然如此，Bower为什么不使用更高效的混合依赖树？</p><blockquote><p><strong>Bower采用扁平依赖树管理的原因</strong></p><p><span style="color:#f25">（1）代码体积对于前端开发非常重要，而扁平树管理可以实现组件最(少)小化。</span><br><span style="color:#f25">（2）所有组件默认都在浏览器的全局作用域中运行，不同版本的同名组件会产生冲突。</span></p></blockquote><p>因为Bower采用了扁平依赖树的方式来处理，所以在使用的时候容易产生冲突，这种依赖管理方式要求开发者注重组件的版本兼容和依赖关系。接下来，我们简单演示Bower使用过程中会出现冲突的情况。</p><p><strong>冲突的产生和处理</strong></p><p>① 安装jQuery框架的1.2.3版本</p><p><code>$ bower install --save jquery#1.2.3</code></p><p>执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain...</div><div class="line">bower not-cached    https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower resolve       https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower download      https://github.com/jquery/jquery-dist/archive/1.2.3.tar.gz</div><div class="line">bower extract       jquery#1.2.3 archive.tar.gz</div><div class="line">bower deprecated    Package jquery is using the deprecated component.json</div><div class="line">bower resolved      https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower install       jquery#1.2.3</div></pre></td></tr></table></figure></p><p>② 安装ember组件并解决冲突</p><p><code>$ bower install --save ember</code></p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bogon:Test wendingding$ bower install --save ember</div><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain digits, dots, dashes</div><div class="line">bower cached        https://github.com/components/ember.git#2.18.2</div><div class="line">bower validate      2.18.2 against https://github.com/components/ember.git#*</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#&gt;= 1.7.0 <span class="tag">&lt; <span class="attr">4.0.0</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">Unable</span> <span class="attr">to</span> <span class="attr">find</span> <span class="attr">a</span> <span class="attr">suitable</span> <span class="attr">version</span> <span class="attr">for</span> <span class="attr">jquery</span>, <span class="attr">please</span> <span class="attr">choose</span> <span class="attr">one</span> <span class="attr">by</span> <span class="attr">typing</span> <span class="attr">one</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">numbers</span> <span class="attr">below:</span></span></div><div class="line"><span class="tag">    <span class="attr">1</span>) <span class="attr">jquery</span>#<span class="attr">1.2.3</span> <span class="attr">which</span> <span class="attr">resolved</span> <span class="attr">to</span> <span class="attr">1.2.3</span> <span class="attr">and</span> <span class="attr">is</span> <span class="attr">required</span> <span class="attr">by</span> <span class="attr">Test</span></span></div><div class="line"><span class="tag">    <span class="attr">2</span>) <span class="attr">jquery</span>#&gt;</span>= 1.7.0 <span class="tag">&lt; <span class="attr">4.0.0</span> <span class="attr">which</span> <span class="attr">resolved</span> <span class="attr">to</span> <span class="attr">3.3.1</span> <span class="attr">and</span> <span class="attr">is</span> <span class="attr">required</span> <span class="attr">by</span> <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">Prefix</span> <span class="attr">the</span> <span class="attr">choice</span> <span class="attr">with</span> ! <span class="attr">to</span> <span class="attr">persist</span> <span class="attr">it</span> <span class="attr">to</span> <span class="attr">bower.json</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag">? <span class="attr">Answer</span> <span class="attr">2</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">jquery</span>#<span class="attr">3.3.1</span> <span class="attr">bower_components</span>/<span class="attr">jquery</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">ember</span>#<span class="attr">2.18.2</span> <span class="attr">bower_components</span>/<span class="attr">ember</span></span></div><div class="line"><span class="tag">└── <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div></pre></td></tr></table></figure></p><p><code>说明</code>：我们先把jQuery的1.2.3版本安装到了项目中，然后又通过Bower来安装ember，而ember组件需要依赖于jQuery框架，这里有个关键信息就是<code>ember要求依赖的jQuery框架版本范围为1.70 ~ 4.0.0</code>和本地已经安装的jQuery 1.2.3冲突，Bower并不会自己处理这个问题而是抛出一个异常，把选择权交给用户，由用户来选择使用哪种方案。</p><p>通过命令行的打印，我们看到Bower为我们提供了两个可选项，第一个选项是保留本地已经安装的1.2.3版本，第二个选项是保存ember所依赖的版本，这里显示了依赖需要的版本范围jQuery#&gt;=1.70&lt;4.0.0和最终会决定(resolved)的版本(3.3.1)。上面的示例中，冲突产生后我们输入2，选择安装jQuery的3.3.1版本。</p><p>③ 查看项目已安装的组件信息</p><p><code>$ bower list</code></p><p>具体的组件和依赖结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">├─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">│ └── jquery#3.3.1</div><div class="line">└── jquery#3.3.1 incompatible with 1.2.3 (1.2.3 available, latest is 3.3.1)</div></pre></td></tr></table></figure></p><p>冲突处理完后，项目中原本下载安装好的jQuery1.2.3版本被重新下载的3.3.1版本替代。</p><h3 id="1-8-Bower自定义组件目录"><a href="#1-8-Bower自定义组件目录" class="headerlink" title="1.8 Bower自定义组件目录"></a>1.8 Bower自定义组件目录</h3><p>默认情况下，所有的依赖包都被下载保存到bower_components文件路径，如果想要把依赖包下载到自己指定的目录，使用.bowerrc文件配合bower.json就可以实现。</p><p>在项目根目录创建.bowerrc文件，使用json格式来设置文件路径。<br><code>{    &quot;directory&quot;: &quot;指定路径&quot;}</code><br>保存好以后，执行bower install命令，就会把bower.json配置好的相关组件全部下载到指定的路径中。</p><p>命令行参考<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">bogon:Test wendingding$ touch .bowerrc</div><div class="line">bogon:Test wendingding$ vim .bowerrc</div><div class="line">bogon:Test wendingding$ cat .bowerrc</div><div class="line">&#123;</div><div class="line">    "directory": "app/xxx/"</div><div class="line">&#125;</div><div class="line">bogon:Test wendingding$ cat bower.json</div><div class="line">&#123;</div><div class="line">  "name": "Test",</div><div class="line">  "authors": [</div><div class="line">    "flowerField <span class="tag">&lt;<span class="name">18681537032@163.com</span>&gt;</span>"</div><div class="line">  ],</div><div class="line">  "description": "",</div><div class="line">  "main": "",</div><div class="line">  "license": "MIT",</div><div class="line">  "homepage": "",</div><div class="line">  "ignore": [</div><div class="line">    "**/.*",</div><div class="line">    "node_modules",</div><div class="line">    "bower_components",</div><div class="line">    "test",</div><div class="line">    "tests"</div><div class="line">  ],</div><div class="line">  "dependencies": &#123;</div><div class="line">    "jquery": "^3.3.1"</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">bogon:Test wendingding$ bower install</div><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain digits...</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#^3.3.1</div><div class="line">bower install       jquery#3.3.1</div><div class="line"></div><div class="line">jquery#3.3.1 app/xxx/jquery</div><div class="line">bogon:Test wendingding$ tree -L 3</div><div class="line">.</div><div class="line">├── app</div><div class="line">│   └── xxx</div><div class="line">│       └── jquery</div><div class="line">└── bower.json</div></pre></td></tr></table></figure></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍前端开发中常用的包管理工具Bower，具体包括Bower的基本情况、安装、使用和常见命令等内容，最后还介绍了依赖树管理的常见方式以及Bower采用的策略并进行了比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-关于Bo
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
