<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花田半亩</title>
  
  <subtitle>文顶顶的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weibo.com/u/3800117445/"/>
  <updated>2018-05-12T10:05:26.972Z</updated>
  <id>https://weibo.com/u/3800117445/</id>
  
  <author>
    <name>文顶顶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javaScript系列 [06]-javaScript和this</title>
    <link href="https://weibo.com/u/3800117445/2018/05/11/javaScript%E7%B3%BB%E5%88%97%20%5B06%5D-javaScript%E5%92%8Cthis/"/>
    <id>https://weibo.com/u/3800117445/2018/05/11/javaScript系列 [06]-javaScript和this/</id>
    <published>2018-05-11T12:20:13.000Z</published>
    <updated>2018-05-12T10:05:26.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20[01]-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/" target="_blank" rel="external">javaScript系列 [01]-javaScript函数基础</a>这篇文章中我已经简单介绍了JavaScript语言在函数使用中this的指向问题，虽然篇幅不长，但其实最重要的部分已经讲清楚了，这篇文章我们来单独谈一谈神秘的this，或者叫<code>怎么也搞不清楚的指天指地指空气的this</code>。</p></blockquote><h3 id="1-1-this简单说明"><a href="#1-1-this简单说明" class="headerlink" title="1.1 this简单说明"></a>1.1 this简单说明</h3><p><strong>this</strong>关键字被认为是JavaScript语言中最复杂的机制之一，跟this相关的知识很多开发者往往总是一知半解，更有甚者很多人完全搞不懂也不愿意去搞懂跟this相关的内容，在必须要用到的时候宁愿选择在代码中总是使用临时打印验证的方式来探知this的指向。这是现实，也许因为他们觉得跟this有关的这一切都混乱不堪，各种文档晦涩难懂，this的指向好似没有固定的套路，总是变来变去难以捉摸。其实，this原本并没有那么复杂，它就是个被自动定义在函数作用域中的变量，总是指向某个特定的“对象”。接下来，我们将尝试用这样一篇文章来讲清楚跟this有关的以下问题：</p><blockquote><p>❐   this 是什么？<br>❐   为什么要使用this?<br>❐   this指向谁？<br>❐   this绑定的几种情况<br>❐   this固定规则外的注意事项<br>❐   this的几个使用场景介绍</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;this是什么?&nbsp; &nbsp;</strong></span></p><p>在声明函数的时候，除了声明时定义的形式参数外，每个函数还接受两个附加的参数：<code>this</code>和<code>arguments</code>。其中arguments是一个类似于数组的结构，保存了函数调用时传递的所有实际参数，arguments这个参数让我们有能力编写<code>能够接受任意个数参数的</code>函数。参数this在面向对象编程中非常重要，它总是指向一个“特定的对象”，至于这个特定的对象是谁通常取决于函数的调用模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//默认指向window</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">           res += <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用sum函数的时候，this默认指向window</span></div><div class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">//计算输入参数的累加和，结果为10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>现在我们知道和this有关的关键信息是：</p><p><span style="color:#F55">① this是JavaScript中所有函数的隐藏参数之一，因此每个函数中都能访问this。</span><br><span style="color:#F55">② 函数中的this总是指向一个特定对象，该对象具体取决于函数的调用模式。</span></p><div class="tip"><br>说明：在script标签中我们也可以直接访问this，它通常总是指向widow，我们讨论的this主要特指函数内部(函数体)的this。<br></div><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;为什么要使用this?&nbsp; &nbsp;</strong></span></p><p><span style="color:#F55">this提供一种更优雅的方式来隐士的传递一个对象引用，因为拥有this，所以我们可以把API设计得更加的简洁并且易于复用。简单点说，那就是this可以帮助我们省略参数。</span></p><p>我们可以通过以下两个代码片段来加深对this使用的理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**代码 [ 01 ]**/</span></div><div class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">contentText</span>:<span class="string">"天王盖地虎 小鸡炖蘑菇"</span>&#125;;</div><div class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">"燕赤霞"</span>,<span class="attr">contentText</span>:<span class="string">"天地无极 乾坤借法 急急如令令"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(obj.name+<span class="string">"口诀是："</span> + getContentText(obj));;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj.contentText + <span class="string">"哒哒哒哒~"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">speak(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">speak(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div><div class="line"></div><div class="line">getContentText(personOne);</div><div class="line">getContentText(personTwo);</div></pre></td></tr></table></figure><p><strong>代码说明：</strong>上面的代码声明了两个函数：speak和getContentText，这两个函数都需要访问对象中的属性，上面的代码中每个函数都接收一个obj对象作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**代码 [ 02 ]**/</span></div><div class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">contentText</span>:<span class="string">"天王盖地虎 小鸡炖蘑菇"</span>&#125;;</div><div class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">"燕赤霞"</span>,<span class="attr">contentText</span>:<span class="string">"天地无极 乾坤借法 急急如令令"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"口诀是："</span> + getContentText.call(<span class="keyword">this</span>));;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contentText + <span class="string">"哒哒哒哒~"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">speak.call(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">speak.call(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div><div class="line"></div><div class="line">getContentText.call(personOne);  <span class="comment">//天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">getContentText.call(personTwo);  <span class="comment">//天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div></pre></td></tr></table></figure><p><strong>代码说明：</strong>完成相同的功能，还是两个同样的函数，区别在于我们借助this省略掉了函数必须要传递的对象参数，实现更优雅。而且如果你的代码越来越复杂，那么需要显式传递的上下文对象会让代码变得越来越混乱而难以维护，使用this则不会如此。</p><h3 id="1-2-函数和this"><a href="#1-2-函数和this" class="headerlink" title="1.2 函数和this"></a>1.2 函数和this</h3><p>this指向谁绑定给哪个对象并不是在编写代码的时候决定的，而是在运行时进行绑定的，它的上下文取决于函数调用时的各种条件 。<span style="color:F55">this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</span></p><p>当函数被调用时，会创建一个执行上下文。该上下文会包含一些特殊的信息，例如函数在哪里被调用，函数的调用方式，函数的参数等，this其实是该上下文中的一个属性，它指向谁完全取决于函数的调用方式。</p><p>现在我们已经弄明白了this最核心的知识：<span style="color:#F55">this的指向取决于函数的调用方式。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;函数基础&nbsp; &nbsp;</strong></span></p><p>在接着讲解之前，有必要对函数的情况进行简单说明，比如函数的创建、参数的传递、函数的调用以及返回值等等。</p><p><strong>函数的创建</strong><br>在开发中我们有多种方式来创建（声明）函数，可以使用function关键字直接声明一个具名函数或者是匿名函数，也可以使用Function构造函数来创建一个函数实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 function关键字声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"命名函数|具名函数"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"匿名函数"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log("函数实例对象的函数体")'</span>);</div></pre></td></tr></table></figure></p><p><strong>函数的参数</strong><br>函数的参数有两种，一种是形式参数，一种是实际参数。</p><p><strong>形式参数</strong><br>在函数声明（创建）的时候，我们可以通过一定的方式来指定函数的参数，相当于在函数体内声明了对应的临时局部变量。</p><p><strong>实际参数</strong><br>在函数调用的时候，会把实际参数的值传递给形式参数，存在一个隐藏的赋值操作，实际参数就是函数调用时()中的参数。</p><p><strong>隐藏参数</strong><br>JavaScript中所有函数中均可以使用this和arguments这两个附加的隐藏参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[1] 函数的声明</span></div><div class="line"><span class="comment">//01 function关键字声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"命名函数|具名函数"</span>,<span class="string">"a的值:"</span> +a , <span class="string">"b的值:"</span>+b);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);      <span class="comment">//此处指向window全局对象</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//此处打印的是["f1的a","f1的b"]结构的数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"匿名函数"</span>,<span class="string">"a的值:"</span> +a , <span class="string">"b的值:"</span>+b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></div><div class="line"><span class="comment">//a和b为新创建的函数对象的形式参数</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'console.log("函数实例对象的函数体","a的值:" +a , "b的值:"+b)'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[2] 函数的调用</span></div><div class="line"></div><div class="line"><span class="comment">//"f1的a"和"f1的b"这两个字符串作为f1函数此处调用传递的实际参数</span></div><div class="line"><span class="comment">//在调用函数的时候，会把"f1的a"这个字符串赋值给形参a,把"f1的b"这个字符串赋值给形参b</span></div><div class="line">f1(<span class="string">"f1的a"</span>,<span class="string">"f1的b"</span>);  <span class="comment">//命名函数|具名函数 a的值:f1的a b的值:f1的b</span></div><div class="line"></div><div class="line">f2(<span class="string">"f2的a"</span>,<span class="string">"f3的b"</span>);  <span class="comment">//匿名函数 a的值:f2的a b的值:f3的b</span></div><div class="line">f3(<span class="string">"f3的a"</span>,<span class="string">"f3的b"</span>);  <span class="comment">//函数实例对象的函数体 a的值:f3的a b的值:f3的b</span></div></pre></td></tr></table></figure><p><strong>函数调用</strong><br>函数名后面跟上调用运算符<code>[()]</code>的代码，我们称为函数调用，当函数被调用的时候，会把实参赋值给形参并自上而下的执行函数体中的代码。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;函数调用和this绑定&nbsp; &nbsp;</strong></span></p><p>因为this的绑定完全取决于函数的调用方式，所以要搞清楚this绑定问题只需要搞清楚函数调用方式即可，函数的调用方式通常来说有以下四种：</p><blockquote><p>❐   普通函数调用(默认绑定)<br>❐   对象方法调用(隐式绑定)<br>❐   构造函数调用(new绑定)<br>❐   函数上下文调用(显式绑定)</p></blockquote><p>函数的调用方式只有上面的四种情况，而要确定其具体的调用方式，需要先确定函数调用的位置。</p><p><strong>函数调用位置</strong><br>函数调用位置也就是函数在代码中被调用的位置<code>[函数名+()的形式]</code>，我们可以通过下面的示例代码来理解函数的调用位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>);</div><div class="line">    <span class="comment">//当前的函数调用栈：f1</span></div><div class="line">    f2();   <span class="comment">//函数f2调用的位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>);</div><div class="line">    <span class="comment">//当前函数调用栈:f1 --&gt; f2</span></div><div class="line">    f3();   <span class="comment">//函数f3调用的位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//当前函数调用栈:f1--&gt;f2--&gt;f3</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f3"</span>);</div><div class="line">&#125;</div><div class="line">f1();       <span class="comment">//函数f1调用的位置</span></div></pre></td></tr></table></figure></p><h3 id="1-3-this绑定浅析"><a href="#1-3-this绑定浅析" class="headerlink" title="1.3 this绑定浅析"></a>1.3 this绑定浅析</h3><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 普通函数调用(默认绑定) &nbsp; &nbsp;</strong></span></p><p><code>普通函数调用</code>就是函数名后面直接更上调用运算符调用，这种情况下函数调用时应用了this的默认绑定，如果是在非严格模式下，该this指向全局对象window，如果是在严格模式下，不能将全局对象用于默认绑定，该this会绑定到undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明全局变量 t</span></div><div class="line"><span class="keyword">var</span> t = <span class="number">123</span>;           <span class="comment">//所有全局变量自动成为全局对象的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>); <span class="comment">//foo</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//this ---&gt; 全局对象window</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.t);<span class="comment">//123</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">foo();  <span class="comment">//非严格模式下:以普通函数方式调用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;      <span class="comment">//作用域开启严格模式</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"fn"</span>); <span class="comment">//fn</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//this ---&gt;undefined</span></div><div class="line">    <span class="comment">//Uncaught TypeError: Cannot read property 't' of undefined</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn();  <span class="comment">//严格模式下:以普通函数方式调用</span></div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/this_01.png?raw=true"></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 对象方法调用(隐式绑定) &nbsp; &nbsp;</strong></span></p><p><code>对象方法调用</code>又称为隐式绑定，当函数引用有上下文对象的时候，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。需要注意的是，如果存在引用链，那么只有对象属性引用链中的最后一层在调用位置中起作用，下面我们通过一个代码片段来理解这种调用方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"wenidngding"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//普通函数调用，函数中的this默认绑定到全局对象，打印wendingding</span></div><div class="line">showName();</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"小猪佩奇"</span>,</div><div class="line">    showName:showName</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj,打印小猪佩奇</span></div><div class="line">obj.showName();</div></pre></td></tr></table></figure></p><p><strong>上下文对象</strong></p><p>上下文对象可以简单理解为函数调用时该函数的拥有者，或者引用当前函数的对象。</p><p><strong>this丢失的问题</strong></p><p>我们在确定this绑定问题的时候不能一根筋的把<code>该函数是否是对象的方法</code>作为判断的准则，而要抓住问题的本质，而且代码中可能存在this隐式绑定丢失的问题。外在的所有形式其实都不重要，最根本的就是看函数调用的时候，用的是什么方式？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字面量方式创建对象，该对象拥有name属性和showName方法</span></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name:<span class="string">"小猪佩奇"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(001)</span></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj1,打印小猪佩奇</span></div><div class="line">obj1.showName();</div><div class="line"></div><div class="line"><span class="comment">//[1] 把obj.showName方法赋值给其他的对象</span></div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"阿文"</span>&#125;;</div><div class="line">obj2.show = obj1.showName;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(002)</span></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj2,打印阿文</span></div><div class="line">obj2.show();</div><div class="line"></div><div class="line"><span class="comment">//[2] 把obj.showName方法赋值给一个变量</span></div><div class="line"><span class="keyword">var</span> fn = obj1.showName;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(003)</span></div><div class="line"><span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></div><div class="line"><span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></div><div class="line">fn();</div><div class="line"></div><div class="line"><span class="comment">//[3] 把obj.showName方法作为其他函数的参数（回调函数）来使用</span></div><div class="line"><span class="comment">//声明函数，该函数接收一个函数作为参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callBack</span>) </span>&#123;</div><div class="line">    <span class="comment">//调用位置(004)</span></div><div class="line">    <span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></div><div class="line">    <span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></div><div class="line">    callBack();</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用位置(005) 此处不涉及this</span></div><div class="line">foo(obj1.showName);</div></pre></td></tr></table></figure></p><p><span style="color:#F55"><strong>➤ 思考：能否缩短对DOM操作相关的方法？</strong></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"demoID"</span>)); <span class="comment">//正确</span></div><div class="line"></div><div class="line"><span class="comment">//声明getById函数，该函数指向document.getElementById方法</span></div><div class="line"><span class="keyword">var</span> getById = <span class="built_in">document</span>.getElementById;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getById(<span class="string">"demoID"</span>));<span class="comment">//报错：Uncaught TypeError: Illegal invocation</span></div></pre></td></tr></table></figure></p><p><strong>代码说明</strong> 有的朋友可能尝试过像上面这样来写代码，发现通过这样简单的处理想要缩短DOM操作相关方法的方式是不可取的，为什么会报错？原因在于document.getElementById方法内部的实现依赖于this，而上面的代码<code>偷换了函数的调用方式，函数的调用方式由对象方法调用转变成了普通函数调用，this绑定的对象由document变成了window</code>。</p><p>怎么解决呢，可以尝试使用显式的绑定指定函数内的this，参考代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getById = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//显式的设置document.getElementById函数内部的this绑定到document对象</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>)</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(getById(<span class="string">"demoID"</span>));  <span class="comment">//正确</span></div></pre></td></tr></table></figure></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 构造函数调用(new绑定) &nbsp; &nbsp;</strong></span><br><code>构造函数方式调用</code>其实就是在调用函数的时候使用new关键字，这种调用方式主要用于创建指定构造函数对应的实例对象。</p><p><strong>构造函数</strong><br>构造函数就是普通的函数，本身和普通的函数没有任何区别，其实构造函数应该被称为<code>以构造方式调用的函数</code>，这样也许会更准确一些。因为在调用的时候总是以new关键字开头<code>[例如：new Person() ]</code>，所以我们把像Person这样的函数叫做构造函数。虽然构造函数和普通函数无异，但因为它们调用的直接目的完全不同，为了人为的区分它们，开发者总是约定构造函数的首字母大写。</p><p>当函数被以普通方式调用的时候，会完成实参向形参的赋值操作，继而自上而下的执行函数体中的代码，当构造函数被调用的时候，目的在于获得对应的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明一个Person函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Perosn</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(001)</span></div><div class="line"><span class="comment">//构造函数方式调用(new绑定) Person函数内部的this指向新创建的实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Perosn(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(002)</span></div><div class="line"><span class="comment">//对象方法的方式调用(隐式绑定) show方法内部的this指向的是引用的对象，也就是p1</span></div><div class="line"><span class="comment">//打印：姓名：zs 年龄：18</span></div><div class="line">p1.show();</div></pre></td></tr></table></figure><p><strong>构造函数内部细节</strong></p><p>使用new以构造函数的方式来调用Person的时候，内部主要做以下操作</p><blockquote><p>①  创建空的Object类型的实例对象，假设为对象o<br>② 让函数内部的this指向新创建的实例对象o<br>③ 设置实例对象o的原型对象指向构造函数默认关联的原型对象<br>④ 在函数内通过this来添加属性和方法<br>⑤ 在最后默认把新创建的实例对象返回</p></blockquote><p><strong>总结</strong> <span style="color:#f55">如果以构造函数方式调用，函数内部的this绑定给新创建出来的实例对象。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;④ 函数上下文调用(显式绑定) &nbsp; &nbsp;</strong></span><br>在开发中我们可以通过call()或者是apply()方法来显式的给函数绑定指定的this，使用call或者是apply方法这种调用方式我们称为是函数上下文调用。</p><p>JavaScript语言中提供的绝大多数函数以及我们自己创建的所有函数都可以使用call和apply方法，这两个方法的作用几乎完全相同，只有传参的方式有细微的差别。</p><p><strong>call方法和apply方法的使用</strong></p><p>作用：借用对象的方法并显式绑定函数内的this。<br>语法：<code>对象.方法.call(绑定的对象，参数1，参数2...) | 对象.方法.apply(绑定的对象，[参数1，参数2...])</code></p><p>使用代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name:<span class="string">"zs"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名 "</span> + <span class="keyword">this</span>.name,a, b);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"ls"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(001)</span></div><div class="line"><span class="comment">//以对象方法的方式调用函数，函数内部的this指向引用对象，也就是obj1</span></div><div class="line"><span class="comment">//打印结果为：姓名 zs 1 2</span></div><div class="line">obj1.showName(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(002)</span></div><div class="line"><span class="comment">//obj2对象并不拥有showName方法，此处报错：obj2.showName is not a function</span></div><div class="line"><span class="comment">//obj2.showName();</span></div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(003)</span></div><div class="line"><span class="comment">//函数上下文的方式(call)调用函数，函数内部的this绑定给第一个参数obj2</span></div><div class="line"><span class="comment">//打印结果为：姓名 ls 哈哈 嘿嘿</span></div><div class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></div><div class="line"><span class="comment">//其它的参数：哈哈和嘿嘿这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></div><div class="line">obj1.showName.call(obj2,<span class="string">"哈哈"</span>,<span class="string">"嘿嘿"</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(004)</span></div><div class="line"><span class="comment">//函数上下文的方式(apply)调用函数，函数内部的this绑定给第一个参数obj2</span></div><div class="line"><span class="comment">//打印结果为：姓名 ls 呵呵 嘎嘎</span></div><div class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></div><div class="line"><span class="comment">//其它的参数：呵呵和嘎嘎这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></div><div class="line">obj1.showName.apply(obj2,[<span class="string">"呵呵"</span>,<span class="string">"嘎嘎"</span>]);</div></pre></td></tr></table></figure></p><p><strong>总结</strong> <span style="color:#f55">如果以函数上下文的方式来调用，函数内部的this绑定call或者是apply方法的第一个参数，如果该参数不是对象类型那么会自动转换为对应的对象形式。</span></p><h3 id="1-4-this的注意事项"><a href="#1-4-this的注意事项" class="headerlink" title="1.4 this的注意事项"></a>1.4 this的注意事项</h3><p>我们已经介绍了一般情况下this绑定的问题，虽然上面的规则可以适用绝大多数的代码场景，但也并非总是百分百如此，也有例外。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ① &nbsp; &nbsp;</strong></span></p><p>在使用call或者apply方法的时候，<span style="color:#F55">非严格模式下如果我们传递的参数是null或者是undefined，那么这些值在调用的时候其实会被忽略，this默认绑定的其实是全局对象。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**[代码 01]**/</span></div><div class="line"><span class="comment">//声明全局变量用于测试</span></div><div class="line">   <span class="keyword">var</span> name = <span class="string">"测试的name"</span>;</div><div class="line">   <span class="keyword">var</span> obj1 = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"姓名 "</span> + <span class="keyword">this</span>.name,a, b);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="comment">//注意：虽然此处以上下文的方式调用，但是因为传递的第一个参数是null,实际这里应用的是默认绑定规则</span></div><div class="line">   obj1.showName.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>);       <span class="comment">//姓名 测试的name 1 2</span></div><div class="line">   obj1.showName.call(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//姓名 测试的name 1 2</span></div></pre></td></tr></table></figure><p>严格模式下，传递null或者是undefined作为call和apply方法的第一个参数，this的绑定和上下文调用保持一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**[代码 02]**/</span></div><div class="line"><span class="comment">//开启严格模式</span></div><div class="line"><span class="meta">   "use strict"</span>;</div><div class="line"></div><div class="line">   <span class="comment">//声明全局变量用于测试</span></div><div class="line">   <span class="keyword">var</span> obj = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   obj.showName.call(<span class="literal">null</span>);        <span class="comment">//null</span></div><div class="line">   obj.showName.apply(<span class="literal">undefined</span>);  <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="comment">//建议的处理方式</span></div><div class="line">obj.showName.apply(<span class="built_in">Object</span>.create(<span class="literal">null</span>));</div></pre></td></tr></table></figure></p><p><strong>建议</strong> 以前我们在以函数上下文方式来调用函数的时候，如果并不关心函数内部的this绑定，那么一般会传递null值或者undefined值。如果这样的话，在非严格模式下，函数内部的this默认绑定给全局对象并不安全，建议传递空对象[<code>可以使用Object.create(null)方式创建</code>]，这样函数操作会更安全而且代码可读性会更好。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ② &nbsp; &nbsp;</strong></span></p><p>ES6中推出了一种特殊的函数类型：箭头函数。箭头函数使用<code>=&gt;操作符</code>来定义，需要注意的是箭头函数内部的this绑定并不适用于既定的四种规则，this的绑定由外层作用域来决定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"fn"</span>,<span class="keyword">this</span>);</div><div class="line">    <span class="comment">//fn函数中返回一个箭头函数</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"zs"</span>&#125;;</div><div class="line"><span class="comment">//fn以普通函数方式调用，fn中的this指向全局对象</span></div><div class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向window</span></div><div class="line">fn()();</div><div class="line"></div><div class="line"><span class="comment">//fn以函数上下文方式调用，fn中的this指向对象o</span></div><div class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向对象o</span></div><div class="line">fn.call(o)(); <span class="comment">//this指向&#123;name:"zs"&#125;对象</span></div></pre></td></tr></table></figure></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ③ &nbsp; &nbsp;</strong></span></p><p>需要特别注意的是：在代码中我们可能会创建函数的“间接引用”，这种情况下调用函数会使用默认绑定规则。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objA = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> objB = &#123;<span class="attr">name</span>:<span class="string">"ls"</span>&#125;;</div><div class="line">   objA.showName();                <span class="comment">//对象方法调用，this指向objA 打印zs</span></div><div class="line"></div><div class="line">   (objB.showName = objA.showName)(); <span class="comment">//打印 空字符串</span></div></pre></td></tr></table></figure></p><p><strong>代码说明</strong> 我们重点看最后一行代码，赋值表达式<code>objB.showName = objA.showName</code>的返回值是目标函数的引用，这种<code>间接引用</code>调用方式符合普通函数调用的规则，this会被绑定给全局对象。最后一行代码，拆开来写的形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = objB.showName = objA.showName;</div><div class="line">   f(); <span class="comment">//打印 空字符串</span></div></pre></td></tr></table></figure></p><h3 id="1-5-this绑定总结"><a href="#1-5-this绑定总结" class="headerlink" title="1.5 this绑定总结"></a>1.5 this绑定总结</h3><p>当函数的调用位置确定后，我们可以顺序应用下面的四条规则来判断this的绑定对象</p><blockquote><p>① 是否由new调用？ 如果是，则绑定到构造函数新创建的实例对象身上。<br>② 是否由call或者apply调用？如果是，则绑定到第一个参数指定的对象身上。<br>③ 是有作为对象的方法调用？如果是，则绑定到这个引用的对象身上。<br>④ 默认普通函数调用，如果是严格模式则绑定到undefined，否则绑定到全局对象。</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/this_02.png?raw=true"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20[01]-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 同源策略和跨域请求</title>
    <link href="https://weibo.com/u/3800117445/2018/05/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>https://weibo.com/u/3800117445/2018/05/11/网络编程系列 同源策略和跨域请求/</id>
    <published>2018-05-11T02:05:13.000Z</published>
    <updated>2018-05-11T04:53:53.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-同源策略"><a href="#1-1-同源策略" class="headerlink" title="1.1 同源策略"></a>1.1 同源策略</h3><h4 id="1-1-1-同源策略说明"><a href="#1-1-1-同源策略说明" class="headerlink" title="1.1.1 同源策略说明"></a>1.1.1 同源策略说明</h4><p><strong>同源策略(Same Origin Policy)</strong>是一种约定，它是浏览器最核心也最基本的安全策略。可以说web是构建在同源策略的基础上的，浏览器只是针对同源策略的一种具体实现。</p><p>同源策略是浏览器实施的一种关键机制，主要用于防止不同来源的内容相互干扰产生安全问题。简单说，就是某个站点(源)可以读写从该站点(源)收到的信息，但是不得访问从其它站点(源)收到的信息，浏览器只允许相同来源的内容进行交互。</p><div class="tip">不使用同源策略的安全问题？</div><p>若不使用同源策略，那么当不知情的用户访问恶意网站的时候，该网站上运行的脚本将能够通过一定方式来访问这名用户同时访问的任何其他网站的数据和功能。<code>[用户在浏览器当前打开的其他页面中可能已经处理登录状态，脚本可以直接获取对应的Cookie数据或登录令牌发送对应网络请求。]</code> 这样的话，该恶意网站将可以操作用户的账户转账、阅读邮件列表等信息，存在巨大的安全风险。</p><p><strong>同源策略</strong>的主要特点</p><blockquote><p> ❐  指定域的页面可以向另一个域提出任意数量的请求，但是该页面本身无法处理返回的数据。<br> ❐  指定域的页面可以通过某些标签加载其它域的脚本并执行该脚本。<br> ❐  指定域的页面无法读取或修改其它域的cookie或DOM数据。</p></blockquote><p>目前，同源策略限制以下三种行为</p><blockquote><p> ❐  DOM  的读取操作。<br> ❐  AJAX 请求的发送。<br> ❐  Cookie、LocalStorage 和 IndexDB 的读取操作。</p></blockquote><p><strong>注意  </strong>Ajax在发送跨域请求的时候，其实请求是发出去的，只是服务器返回的响应(response)被浏览器阻塞了，即使是返回码也获取不到。</p><p><span style="color:red">同源策略其实是限制了不同源的读，但是并不限制不同源的写。</span></p><div class="tip">为什么不限制不同源的写操作？</div><p>因为如果连请求都发不出去，相当于在源头上就限制死各网站间无法共享资源了,而且仅仅限制读操作，也就是浏览器拦截跨域网络请求的响应结果一般来说就足够了,限制读但是不限制写这样的处理方式更灵活。</p><h4 id="1-1-2-同源策略和Ajax请求"><a href="#1-1-2-同源策略和Ajax请求" class="headerlink" title="1.1.2 同源策略和Ajax请求"></a>1.1.2 同源策略和Ajax请求</h4><p><div class="tip">如何确定是否同源？</div></p><blockquote><p> ❐  协议相同<br> ❐  域名相同<br> ❐  端口相同<br><code>协议 + 域名 + 端口号</code>完全相同则认为是同源的，否则认为是不同源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">http://www.baidu.com/123.png            target</div><div class="line">http://www.baidu.com/456.png            同源</div><div class="line">http://www.baidu.com:800/login.html     跨域(端口号不同)</div><div class="line">https://www.baidu.com/456.png           跨域(协议不同)</div><div class="line">http://bbs.baidu.com   跨域(子域名不同)</div><div class="line">http://www.taobao.com 跨域(域名不同)</div></pre></td></tr></table></figure></p></blockquote><p>下面给出示例代码发送跨域网络请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当前路径：http://localhost:63342/..demo.html</span></div><div class="line"><span class="comment">//请求路径：http://www.baidu.com</span></div><div class="line">$.ajax(&#123;</div><div class="line">       <span class="string">"url"</span>:<span class="string">"http://www.baidu.com"</span>,</div><div class="line">       <span class="string">"type"</span>:<span class="string">"get"</span>,</div><div class="line">       <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res,status,xhr</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(res);</div><div class="line">       &#125;,</div><div class="line">       <span class="string">"error"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(res);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p><p><strong>网络请求结果</strong><br><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_01.png?raw=true" height="200"><br>通过调试发现，该请求确实发送出去甚至收到了服务器返回的响应头信息，但无法获取响应体数据。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_02.png?raw=true"><br>具体报错信息显示：<span style="color:#F44">No ‘Access-Control-Allow-Origin’ header …`</span>意思就是当前域名无法跨域向<a href="http://www.baidu.com" target="_blank" rel="external">www.baidu.com</a>请求数据。</p><h3 id="1-2-跨域请求"><a href="#1-2-跨域请求" class="headerlink" title="1.2 跨域请求"></a>1.2 跨域请求</h3><p>在开发中，有时候我们自己的站点需要向其他站点发送网络请求获取服务或某些特定的资源，这就需要跨域发送网络请求。</p><p>跨域网络请求有多种方式来实现，比较常见的是：<code>跨域资源共享( CORS )和jsonP</code>。</p><h4 id="1-2-1-跨域资源共享-CORS"><a href="#1-2-1-跨域资源共享-CORS" class="headerlink" title="1.2.1 跨域资源共享(CORS)"></a>1.2.1 跨域资源共享(CORS)</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨域的服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信，实现方式非常简单，只需要在请求的响应头中设置<code>Access-Control-Allow-Origin</code>字段即可。该字段的值可以设置为指定的域，表明允许该指定的域向服务器发送跨域网络请求，也可以设置为*，表示允许任何的域向服务器发送网络请求。</p><p>下面给出php服务器端的响应头设置代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 允许所有其他域名访问</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: *"</span>);</div><div class="line"></div><div class="line"><span class="comment"># 允许指定域名跨域访问</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.wendingding.com"</span>);</div></pre></td></tr></table></figure></p><p>实现细节请参考：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">阮一峰：跨域资源共享 CORS 详解</a></p><p><strong>特别注意</strong> <span style="color:red">跨域请求的时候，请求和响应都不包含Cookie数据</span>。</p><h4 id="1-2-2-JSONP"><a href="#1-2-2-JSONP" class="headerlink" title="1.2.2 JSONP"></a>1.2.2 JSONP</h4><p>jsonP是<code>JSON with padding</code>(参数式JSON)的简写，是一种常见的跨域网络请求方案。jsonP和JSON类似，只是把真正要返回给客户端的json数据以特定的方式放在函数调用中作为参数传递。</p><p>jsonP方案利用了script标签可以跨越的特点，通过设置script标签的src属性为特定的请求路径来绕过同源访问策略。</p><p>jsonP由两部分组成：<span style="color:red">回调函数参数、特定的JSON数据</span></p><p><strong>jsonP的基本结构</strong></p><blockquote><p>① 在页面的script标签中声明回调函数，该回调函数接收参数（需要和响应对应）。<br>② 在页面中动态的创建script标签，并为标签的src属性指定跨域的URL路径。<br>③ 跨域的URL路径中应该附带回调函数参数，例如 <code>http://www.xx.com?cb = fn</code><br>④ 服务器端接收到响应后返回特定格式的数据,例如：<code>fn({&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18})</code><br>⑤ 客户端script标签加载跨域路径对应的数据，其实是执行了函数调用，把服务器返回的<code>真正数据</code>作为参数传递给声明的回调函数。</p></blockquote><p>代码示例（使用百度搜索结果）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"oText"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(obj);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> oUl = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>)||<span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span></div><div class="line"><span class="javascript">        oUl.innerHTML = <span class="string">""</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> arrM = obj[<span class="string">"s"</span>];</span></div><div class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arrM.length;i++)</span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> oLi = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></div><div class="line"><span class="undefined">            oLi.innerText = arrM[i];</span></div><div class="line"><span class="undefined">            oUl.appendChild(oLi);</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(oUl);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> oText = <span class="built_in">document</span>.querySelector(<span class="string">"#oText"</span>);</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(oText);</span></div><div class="line"><span class="javascript">    oText.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> temp = <span class="built_in">document</span>.querySelector(<span class="string">"#jsonP"</span>);</span></div><div class="line"><span class="javascript">        <span class="keyword">if</span>(temp) <span class="built_in">document</span>.body.removeChild(temp);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> text = oText.value;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> url = <span class="string">"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd="</span>+text+<span class="string">"&amp;cb=fn"</span>;</span></div><div class="line"><span class="javascript">        oScript.setAttribute(<span class="string">"src"</span>,url);</span></div><div class="line"><span class="javascript">        oScript.setAttribute(<span class="string">"id"</span>,<span class="string">"jsonP"</span>);</span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(oScript);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_03.png?raw=true"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1-同源策略&quot;&gt;&lt;a href=&quot;#1-1-同源策略&quot; class=&quot;headerlink&quot; title=&quot;1.1 同源策略&quot;&gt;&lt;/a&gt;1.1 同源策略&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-同源策略说明&quot;&gt;&lt;a href=&quot;#1-1-1-同源策略说明&quot; cla
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络编程" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [005]-牧羊少年奇幻之旅</title>
    <link href="https://weibo.com/u/3800117445/2018/05/08/%E7%89%A7%E7%BE%8A%E5%B0%91%E5%B9%B4%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/"/>
    <id>https://weibo.com/u/3800117445/2018/05/08/牧羊少年奇幻之旅/</id>
    <published>2018-05-08T00:08:18.000Z</published>
    <updated>2018-05-11T03:52:35.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无疑，这是一本非常牛B的📚，至少在我的阅读经验里如此。此时，我将写下一篇冗长的阅读笔记，记录我对它的感觉以及探索。在这篇文章里，我将以<code>基本故事</code>、<code>奇幻之旅</code>、<code>后记</code>的结构来进行组织，另外，致敬保罗·柯艾略。</p></blockquote><h4 id="第一部分-基本故事"><a href="#第一部分-基本故事" class="headerlink" title="第一部分 基本故事"></a>第一部分 基本故事</h4><p><strong>书籍信息</strong></p><p>作品：<a href="https://book.douban.com/subject/3608208/" target="_blank" rel="external">牧羊少年奇幻之旅</a><br>作者：[保罗·柯艾略]<br>翻译：<a href="https://book.douban.com/subject_search?search_text=%E4%B8%81%E6%96%87%E6%9E%97" target="_blank" rel="external">丁文林</a><br>定价：RMB 35：00<br>出版社：北京十月文艺出版社</p><p>全书结构：<code>自序 - 引子 - 上部 - 下部 -尾声</code><br>特别说明：<code>献给J. 一位通晓并利用元精秘密的炼金术士。</code><br>全书人物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">圣地亚哥（牧羊人）</div><div class="line">纺织店老板和他的女儿</div><div class="line">爆米花少年</div><div class="line">撒冷之王</div><div class="line">吉普赛老妇人</div><div class="line">水晶店老板</div><div class="line">英国人</div><div class="line">港口遇到的骗子少年</div><div class="line">法蒂玛（沙漠中的女人）</div><div class="line">200多岁的炼金术士</div><div class="line">部落军队首领</div><div class="line">金字塔前的俩流氓</div><div class="line">赶驼人</div><div class="line">商队领队...等</div></pre></td></tr></table></figure></p><p>全书地名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">西班牙地区（安达卢西亚）（塔里法镇）</div><div class="line">非洲（丹吉尔港口）（沙漠）（绿洲）（埃及金字塔）</div></pre></td></tr></table></figure></p><p><strong>重要标记 ✤</strong> 破庙  羊群 宝石 书籍 宝剑 绿洲 水井 水晶店 鹰 眼镜蛇 财宝 金子 无花果树 炉子 骆驼 马…</p><p><span style="color:#74B884">（自序部分）</span></p><p>开篇第一句：《牧羊少年奇幻之旅》是一部具有象征意义的作品。保罗花了些笔墨说明自己炼金术士的身份，并直接写明该部作品转述了自己所学到的一切，顺带向其他理解了宇宙语言的作家们致敬。在最后的篇幅中，有一个很有意思的故事，是关于圣母怀抱小耶稣降临人间并造访一座修道院的，最后圣母把手伸向了一位很不起眼的神甫，让他抱了抱小耶稣。</p><p><span style="color:#74B884">（引子部分）</span></p><p>引子部分讲述了炼金术士读到的一个关于水仙花的故事。湖泊和山林女神有一段关于水仙少年的对话，精彩至极。这部分的故事，其实我没有完全弄清楚。</p><p><span style="color:#74B884">（正文部分）</span></p><p>正文部分讲解了牧羊人因为一个重复的梦，进而一步一步踏上未知的旅程，追寻财宝的奇幻之旅。牧羊人圣地亚哥总是赶着羊群在一座长着棵巨大无花果树的破庙中过夜，起初他因为总是重复同一个梦而困惑，原计划到四天路程远的小镇去撸羊毛卖顺便见见心仪的女孩，在中途的时候他请求一个吉普赛老妇人给自己解梦并付出了未来财富1/10的代价，继而又遇见了撒冷之王…踏上了寻找财富的奇幻之旅。</p><p>圣地亚哥的旅途主要分几个阶段：<br><img src="https://github.com/flowerField/Source/blob/master/Blog/muyangren.png?raw=true"></p><h4 id="第二部分-奇幻之旅（摘要）"><a href="#第二部分-奇幻之旅（摘要）" class="headerlink" title="第二部分 奇幻之旅（摘要）"></a>第二部分 奇幻之旅（摘要）</h4><div style="color:green; font-size:18px">※※   自序  ※※</div><p>《牧羊少年奇幻之旅》是一部具有象征意义的作品。</p><p>我结识了许多自诩为炼金术士的人，他们拥有自己的实验室，并许诺教给我炼金术的秘诀，条件是向他们支付大笔的金钱。现在我才明白，他们打算教给我的东西，他们自己却一窍不通。</p><p>我所有的努力都付诸东流。<br><span style="color:red; ">上帝有时很严厉，却也无限慷慨。</span><br>很显然，元精并非总装在一只小瓶子里，以泡在液体中的卵状物形式出现，毫无疑问，我们大家都能够探摸到世界灵魂。</p><div style="color:green; font-size:18px">※※   牧羊·云游四方   ※※</div><p><span style="border:1px solid #000"><code>牧羊人 羊群 教堂 无花果树 书 梦 商人的女儿</code></span></p><p>这个男孩名叫<span style="border:1px solid #666">圣地亚哥</span>。夜幕降临时，圣地亚哥赶着羊群来到一座废弃的老教堂前。很久以前，教堂的屋顶就塌掉了。原来圣器室的位置长出了一棵高大的无花果树。</p><p>读书能消磨更多的时间，夜间当枕头用也更舒服。</p><p>“我以前以为牧羊人不会读书。”一个<span style="border:1px solid #666">少女</span>的声音在他的身旁响起。<br>“既然会读书识字，为什么还要当牧羊人呢？”<br>男孩随便岔开了话题，没有回答。他确信这个问题女孩永远无法理解。</p><p>天刚破晓，圣地亚哥便赶着羊群朝日出的方向走去。这些羊永远不需要拿什么主意。他想，也许这就是它们一直跟在我身边的原因。<span style="color:red; ">羊群唯一需要的就是食物和水。只要他知道安达卢西亚最好的草场，羊群就将永远跟随他。即使日复一日在日出日落之间苦熬，即使在其短暂的一生中从未读过一本书，也不懂人的语言，听不懂人们讲述的新鲜事，只要有水和食物，它们就心满意足。作为回报，他们慷慨地献出羊毛，心甘情愿的陪伴着牧羊人，时不时还奉献出自己的肉。</span><br> 如果我变成魔鬼，决定把它们一只接一只杀死，它们也只在整个羊群几乎被杀光的时候才会有所察觉，男孩想。因为它们相信我，而忘记了它们自己的本能。这只是因为我能引领它们找到食物。</p><p>男孩对自己的这些念头感到惊讶。</p><p>父母希望他称为神甫，称为一个普通农家的骄傲，而他们一生只为吃喝忙碌，就像圣地亚哥的羊群。他学过拉丁文、西班牙文和神学。<span style="color:#195; ">但是，从孩提时代起，他就梦想着了解世界，这远比了解上帝以及人类的罪孽来得重要。</span></p><p>“拿去买一群羊，云游四方吧。总有一天，你会懂得，我们的家园才最有价值，我们这儿的女人才最漂亮。” <span style="border:1px solid #666">父亲</span>祝福了他。从父亲的目光中，男孩看出，父亲也想云游四方。</p><p><span style="border:1px solid #195;color:red">All ※ ※</span>他有一群羊，一件外衣和一本书，用这本书可以换来另外一本书。不过最重要的是，他每天都在实现自己人生的最大梦想：云游四方。</p><p>圣地亚哥望着冉冉升起的太阳想，不知道神学院的人是如何寻找上帝的。</p><p><span style="color:red; ">羊群不会察觉它们每天都在走新路，不会发现草场在变化，四季有区别。因为它们一门心思想着喝水吃草。</span></p><p>也许我们大家全都如此。圣地亚哥想，我就是这样，自从认识那个商人的女儿，我就再也没有想过别的女人。</p><p>恰恰是实现梦想的可能性，才使生活变得有趣。</p><p><span style="border:1px solid #000"><code>塔里法的老妇人 解梦</code></span></p><p>他突然想起一位住在塔里法的老妇人，她会解梦。</p><div style="color:green; font-size:18px">※※   解梦  ※※</div><p>“突然间，他抓住了我的手，带着我去了埃及金字塔。那个小孩当时对我说，假如你来到这里，将会找到一处隐秘的宝藏。”就在他要把藏宝的具体地点告诉我的时候，我却醒了。两次的梦都是如此。</p><p>“目前，我不收你任何费用。” <span style="border:1px solid #666">老妇人</span>开口道，“但是，如果你找到了那些财宝，我想要其中的十分之一。”男孩笑了，他很开心。仅仅由于那个梦涉及财宝，他眼下就不必破费了！老妇人大概是个吉普赛人。吉普赛人都很愚蠢。</p><p>“你得先发誓。发誓把财宝的十分之一给我作为交换，我就给你解梦。”<br>简单的事情往往最异乎寻常，只有智者才能看透。</p><p><span style="color:red; "><br>“那么，我怎样才能到埃及呢？”<br>“我只管解梦，不会把梦变成现实。”<br>“如果我到不了埃及呢？”<br>“那我就拿不到酬金了。这是常事”<br></span></p><p>圣地亚哥失望的走了，他决定永远不再相信梦。<br>他用手上的书换了一本更厚的书。</p><p>对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦，却不会把梦变成现实的老妇人。</p><p>他开始阅读那本从塔里法神甫手上换来的书。这是一本很厚的书，开卷第一页讲的是一场葬礼，人物的名字十分复杂。</p><div style="color:green; font-size:18px">※※   撒冷之王  ※※</div><p><span style="color:red; ">这本书和几乎所有的书一样，讲的是同一个道理，人们无法选择自己的命运。它要使大家相信这个世上最大的谎言。</span></p><p><span style="border:1px solid #000"><code>撒冷之王 广场 掘矿工人 爆米花少年 羊群的十分之一 天命 神秘力量</code></span></p><p>“什么是世界上最大的谎言？” 男孩吃惊的问道。<br>“在人生的某个时候，我们失去了对自己生活的掌控，命运主宰了我们的人生。这就是世界上最大的谎言。”</p><p>“你把十分之一的羊送给我，我就告诉你怎样找到宝藏。” <span style="border:1px solid #666">老人</span>说道。<br>男孩又想起了那个梦。突然之间，一切都明朗起来。</p><p><span style="color:red; ">“天命就是你一直期望去做的事情。”人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘力量开始企图证明，根本不可能实现天命。”</span></p><p>“那是表面看来有害无益的力量，但实际上它却在教你如何完成自己的天命，培养你的精神和毅力。因为在这个星球上，存在一个伟大的真理：不论你是谁，不论你做什么，当你渴望得到某种东西时，最终一定能够得到，因为这愿望来自于宇宙的灵魂。那就是你在世间的使命。”</p><p>完成自己的天命是人类无可推辞的义务。万物皆为一物。当你想要某种东西时，整个世界会合力助你实现愿望。</p><p>“你为什么要牧羊？”<br>“因为我喜欢四处游荡。”</p><p><span style="border:1px solid #000">爆米花少年</span>从来就不明白，人们总是有条件去实现自己的梦想。<br>总而言之，人们更重视对于卖爆米花的人和牧羊人的看法，甚至超过了对天命的重视。</p><p><span style="color:#195; "><br>“您为什么跟我讲这些事情？”<br>“因为你意欲履行自己的天命，并差一点就放弃了。”<br>“您总是在这种时刻出现吗？”<br>“一向如此，但是，不见得总以这种方式出现。有时候，可能是一条好出路，一个好主意，或者在关键时刻让事情变得更容易。”<br></span></p><p><span style="color:red; ">“如果东西还没到手，你就先许诺于人，那你就不会积极去争取了。”</span><br>生活中的一切都要付出代价。</p><p>圣地亚哥明白了，那老妇人说的是真话。<br>他考虑着是否应该把那位老人刚才说的话告诉小贩，有的时候最好让事情保持原样，想到这儿，男孩便没有开口。<span style="text-decoration: underline">（生活中我们是否好为人师）</span></p><p>地中海东风刮越刮越猛。面对羊群和宝藏，我现在进退两难，男孩想。<br>在已经习以为常的东西和意欲得到的东西之间，他必须做出抉择。还有那个商人的女儿。不过，她不像羊群那么重要，因为她并不依赖他。</p><p>实际上，每天一成不变，是因为人们已经失去了对美好事物的敏锐感觉。然而，只要有明媚的阳光，人们的生活中就会出现美好的事物。</p><p>第一次玩纸牌，多半会赢。这就是新手的运气。<br>“这是为什么？”<br>“因为生活希望你去实现自己的天命。”</p><p>“财宝在什么地方？”<br>“在埃及，金字塔附近。”</p><p>这两块宝石名叫乌凌和图明，代表着是和否。<br>智慧大师说，“如果你不了解一个人的家，就不能信任他。”</p><p>“这正是我要给你的唯一忠告。”智慧大师说，<span style="color:red; ">‘幸福的秘密就在于，既要看到世上的奇珍异宝，又要永远不忘记勺里的那两滴油。’</span>”</p><p>牧羊少年没说话，他听懂了老人讲述的故事。</p><p>在小城塔里法的制高点有一座旧城堡，那是当年摩尔人修建的。麦基洗德看了一眼正驶离港口的那条小船，神不该有欲望，因为神没有天命，但是他却由衷地祈愿牧羊少年得偿所愿。</p><div style="color:green; font-size:18px">※※   踏足非洲  ※※</div><p><span style="border:1px solid #000"><code>港口 小偷 酒吧老板 水晶商人 宝剑</code></span></p><p>非洲真是个奇怪的地方，男孩想。他坐在一家酒吧里，这家酒吧与他在这个城市狭窄的街巷中见到的其他酒吧没什么两样。</p><p><span style="color:red; ">东西未到手，不应轻易许下诺言。</span></p><p>“他想要你的钱。”<span style="border:1px solid #000">少年</span>说，“丹吉尔跟非洲其他的地方不同，这里是个港口，而港口总是有贼。”</p><p>在纷繁杂乱的商品中间，他突然看到一把剑，那是他见过的最漂亮的剑。包银的剑鞘，黑色的剑柄，柄上嵌有宝石。男孩暗暗发誓，从埃及回来的时候，一定要买下这把宝剑。<br><span style="color:#195"><br>太阳快要落山了。男孩望着太阳，望了许久，直到它隐落到广场周围那些白色的房屋后面。男孩想起早晨太阳升起的时候，他还在另一块大陆，还是个牧羊人，拥有六十只羊，而且要依约去见一个女孩。早晨，他走早田野上，那时，将会发生什么事情他全都知道。<br></span><br><span style="color:#195">然而，太阳落山的此时此刻，他却置身于异国他乡，身为异乡客，来到一个陌生的国度。在这里，他甚至听不懂人家说话。他已经不再是牧羊人，已经一无所有，甚至连回程的钱都没有，何谈实现心愿？<br></span><br><span style="color:#195">一切都发生在太阳东升和西落之间，男孩想。他为自己的处境感到难过。在生活中，事情有时会在一瞬间发生变化，人们根本来不及去适应这种变化。</span><br><span style="color:#195"><br>他一向羞于流泪，甚至从未在他的羊群面向哭过。但此时，集市已散，广场上空空荡荡，他独自一人身在异地，远离家乡。<br></span><br><span style="color:#195">男孩哭了。上帝如此不公平，竟以这种方式回报相信梦想的人。从前跟羊群在一起的时候，我很快乐，而且总是把快乐传达给周围的人。大家看到我出现，都会热情款待。但是现在，我既伤心又郁闷。我改怎么办呢？我会更加痛苦不堪，不再相信任何人，因为有人背叛了我。<br></span></p><p>他想到可以卖掉宝石，买一张回程的船票。</p><p><span style="color:red">凡是港口，总免不了充斥着盗贼。</span></p><p>现在，他明白了<span style="border:1px solid #000">酒吧老板</span>发脾气的原因，那老板试图告诉他不要轻信那个少年。我和别人没什么两样，<span style="color:red">总是以理想的眼光看待世界，以为事情会按照理想的方式发展，而不会用现实的眼光看到世界，看不到事情的真相。</span></p><p>有些事情是不应该问的，不能逃避自己的天命。</p><p>他想起了那把宝剑，看他一眼所付出的代价可谓高昂，但他比毕竟见到了他过去从未见识过的稀罕物。他突然觉得，被骗之后，他可以像个倒霉的受害者一样看待世界，也可以像个寻宝的冒险家那样观察世界。</p><p>在筋疲力尽，进入梦乡之前，男孩想：<span style="color:red">我是个寻宝的冒险家</span>。</p><p><span style="color:red">他身无分文，却对生活充满信心。</span></p><p>水晶店的老板眼瞅着天放亮了。每天早晨，他都会一如既往地感到心烦意乱。他的店铺在一座山丘的顶部，几乎三十年了，一直在这个地方，很少有人光顾。现在做任何改变都为时已晚，他这辈子唯一的本事就是做水晶生意。</p><p>三十年来，他一直靠卖水晶维持生计，现在改弦易辙为时太晚了。</p><p>他拿出外套，开始擦拭那些器皿。</p><p>水晶商人笑了。“哪怕你一整年都给我擦水晶，哪怕你从每一件卖出去的商品中都能挣到可观的佣金，仍然必须借一笔钱才能去埃及。从丹吉尔到金字塔，要穿过几千公里的沙漠呢。”</p><blockquote><p>◼（按：真正的认识清楚现实和理想间的差距）</p></blockquote><p>一时间，周围一片寂静，似乎整个城市都静止不动了。</p><p>“先生，我将给您打工。”他说。</p><p>又沉默了一阵之后，他说道：“我需要钱，好去买些羊。”</p><blockquote><p>◉ 梦想似乎遥不可及，或许重新回到以前的生活是最好的选择。</p></blockquote><div style="color:green; font-size:18px">※※   水晶店的生活  ※※</div><p><span style="border:1px solid #000"><code>麦加 学习 钱</code></span></p><p>直觉告诉他，男孩很快就会回去放羊。</p><p>“我不喜欢变化。” 水晶商人说。</p><p><span style="color:red">当好运降临时，我们必须抓住机会，顺应趋势，竭尽全力推动好运向前发展</span>。</p><p>我害怕实现我的梦想，实现之后，我就没有活下去的动力了。</p><p>你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想要保有去麦加的梦想。并非所有人都以一样的方式来对待梦想。</p><p>有一段时间，他曾经以为羊群能够教会他一切，但是，羊群不会教他阿拉伯语。</p><p>世界上一定还有其他一些东西是羊群教不了的，因为他们只是一味的寻找食物和水源。</p><p>我认为并不是羊群在教，而是我在学，他又想。</p><p><span style="text-decoration: underline">（按：水晶店这段经历其实是为寻宝之旅做准备工作，比如重新认识梦想以及学习阿拉伯语）</span></p><p>圣地亚哥在日出前醒来，从他踏上非洲大陆算起，已经过去了是一个月零九天。</p><p>他把手伸衣服的一个口袋里，然后端详了一会儿从兜里掏出来的东西。<br>那是厚厚的一沓钱，足够用来买上一百二十只羊，一张回家的船票和一张贸易许可证。有了许可证，他就能往来于西班牙和摩洛哥做生意。<br>他耐心地等到店主醒来，开门营业。</p><p>“我为你感到骄傲。”他说，“你为我的水晶店带来了生机。但是你知道，我不会去麦加，就像你知道自己不会回去买羊一样。”</p><p>“当你想要某种东西时，整个世界都会合力助你实现愿望。”老迈的撒冷之王这样说过。</p><p>但是，撒冷之王却没说过有人会骗取钱财，没说过大沙漠浩瀚无垠，没说过会有知道自己的梦想却不愿意去实现的人。</p><p>此处距离安达卢西亚平原仅仅两个小时的船程，但是在他与金字塔之间却横亘着一大片沙漠。但此种境况也让男孩意识到：他距离自己的宝藏近了两个小时的路程。尽管他几乎用了整整一年，才走完这两个小时的路。</p><p>如果找不到那些财宝，我随时可以返回家园，。但是生活突然给了我足够的金钱，而且又有足够的时间，为什么不去寻宝呢？</p><p>他没费什么力气就找到了那家客栈，他想知道金字塔是否真的非常遥远。</p><div style="color:green; font-size:18px">※※   穿越沙漠  ※※</div><br><span style="border:1px solid #000"><code>英国人 沙漠 商队 书 翡翠板 元精 炼金术</code></span><br><br>他显示对世界语产生了兴趣，然后是宗教，最后是炼金术。<br><br>一旦做出决定，实际上便坠入了一股巨大的洪流之中，这洪流会把人带到一个你做决定时从来没想到的地方去。<br><br>“法尤姆就在埃及。” 货站老板说。<br><br>男孩和英国人也已买好了骆驼，他们有些费力地爬到骆驼背上。<br><br><span style="color:red">一个人越接近梦想，天命就越成为他生存下去的真正理由</span>。<br><br>我从羊群身上学到了东西，从水晶身上学到了东西，他心想。我也能沙漠身上学到东西。我觉得沙漠更沧桑，更智慧。<br><br>商队永远只朝着一个方向前进。克服所有障碍，循着那颗指示绿洲方位的星斗前进。<br><br>男孩也有一本书，但是他发现，观察商队和倾听风声比读书有意思多了。因此，当他对骆驼更加熟悉并且迷上这种动物之后，便把书扔掉了。书是不必要的负担，尽管男孩曾养成一种近乎迷信的观点：以书为友，开卷有益。<br><br>我们担心失去的，只是那些我们现在拥有的东西。<br><br>男孩读到有关炼金术最重要的文字，只有寥寥几行，据说写在一块普通的翡翠板上。<br><span style="color:#195"><br>“那还要这么多书干吗？”<br>“为了理解那几行文字。”<span style="border:1px solid #000">英国人</span>说。<br></span><br><br>炼金术士把这种东西称为元精，它由液体和固体构成。元精的液体部分叫做长生不老液，除了能防止炼金术士衰老，还能医治百病，固体部分则叫点金石。<br><br>男孩越来越坚信，在日常生活中就能把炼金术学到手。<br><span style="color:#195"><br>“他们为什么把事情搞的这么难懂？”<br>“为的是只让那些有责任心的人读懂它们。”<br></span><br>只有那些坚持不懈的人，只有那些不断钻研的人，才能够获取元精。<br><br>每个人都有自己的学习方式，他在心中反复对自己说。他的方式不属于我，我的方式也不属于他。但是我们俩都在追寻各自的天命，为此，我尊重他。<br><br>商队开始日夜兼程。戴风帽的报信人频繁的出现。<br><br><br><div style="color:green; font-size:18px">※※   绿洲和战争  ※※</div><br><span style="border:1px solid #000"><code>绿洲 法蒂玛 战争 预兆 鹰 顾问</code></span><br><br>人们由于迷恋图画和文字，忘记了宇宙的语言。<br><br>他们将在绿洲驻扎下来，直到部落间的战争结束。<br><br><span style="color:red">离自己的梦想越近，事情就变得越困难</span>。撒冷之王口中所谓“新手的运气”不再起作用。男孩明白，现在需要的是毅力和勇气。<br><br>不要失去耐心，男孩想，就像<span style="border:1px solid #000">赶驼人</span>说的，该吃饭时吃饭，该睡觉时睡觉。<br><br>此时，时间仿佛在刹那间停止，世界之魂蓦然出现在圣地亚哥面前。当男孩看见少女那双黑色的眼睛，看见她似笑非笑的面容，似启非启的双唇，他明白了世界上最重要和最智慧的表达方式，也就是人类能理解的语言。这就是所谓的爱情。<br><span style="color:#195"><br>“你叫什么名字？” 他问。<br>“我叫法蒂玛。”<span style="border:1px solid #000">少女</span>俩眼看着地面回答。<br></span><br>他已经爱上了她，并且明白了凭着他对少女的爱，就能找到世上所有的宝藏。<br><br>他只是对我说：去试试看吧。<br>男孩沉默不语。英国人长途跋涉来到此地，听到的却是毫无意义的东西。男孩想起自己送给撒冷之王六只羊，也得到一样的结果。<br><br>沙丘会随风改变形状，但沙漠永远都在。我们的爱情也是如此。<br><br>正是由于害怕失败，我至今都没有尝试获取元精。现在，我已经开始做十年前就可以开始做的事情了。到那时我很高兴，因为毕竟没等上二十年才做这件事。<br><br>实际上，并不是事物本身在揭示什么，而是观察事物的人发现了探究世界之魂的方法。<br><br>我卜算未来的方式，是通过当前的预兆。秘密就在当前。如果关注现在，你就能改善它。如果改善了现在，那么将来也会变得更好。<br><br>卫兵把圣地亚哥叫进帐篷。眼前的景象令圣地亚哥惊叹不已。他简直想不到，在沙漠中还会有这样的帐篷。<br><br><span style="border:1px solid #000">神秘骑士</span>抽出栓在马鞍上的一把巨大弯刀，刀刃在月光下闪着寒光。<br><br>对于寻求宇宙语言的人，勇气是最重要的素质。<br><br><span style="color:red">“你必须永不松懈，哪怕已经走了很远的路。” </span>骑士继续说，“你必须热爱沙漠，但是绝不要完全相信沙漠。因为沙漠对所有人都是一个考验：考验你迈出的每一步，杀死心猿意马的人。”<br><br>男孩见到的，正是炼金术士。<br><br>部落的最高头领说，他为那些死去的士兵感到痛心，但是传统绝不能随意改变。<br><br>圣地亚哥成为了绿洲的顾问。<br><br><div style="color:green; font-size:18px">※※   炼金术士  ※※</div><p>月上中天之时，炼金术士翩然而至 ，肩头搭着两只死去的鹰。</p><p>“我已经找到宝藏了。我有一头骆驼，有再水晶店打工挣到的钱，还有在这里得到的五十枚金币。在我的家乡，我可以算富翁了。”<br>“不过，这其中没有一样来自金字塔。” 炼金术士说。</p><p>你必须找到你的宝藏，否则你在途中发现的一切便全都失去了意义。</p><p>明天卖掉你的骆驼，去买一匹马。</p><p>只有发现生命的人，才能找到宝藏。</p><p>你将永远不明白，爱情从来不会阻止一个男人去追寻天命。如果会阻止，一定因为那不是真正的爱情。</p><p>这天晚上，他们看着圆圈中的毒蛇时，那位肩头停着猎鹰的神秘骑士谈到了爱情、财宝、沙漠的女人和他的天命。<br>“我跟你走。”男孩说完，内心立刻平静下来。</p><p>倾听你的心声，心了解所有的事物。</p><p>为一个梦想而失去已经到手的一切，有点担心也是情有可原。</p><p><span style="color:red">害怕遭受痛苦比遭受痛苦本身还要糟糕</span>。</p><p>追寻梦想的每一刻，都与上帝和永恒同在。</p><p><span style="color:red">夜色之浓，莫过于黎明前的黑暗</span>。</p><div style="color:green; font-size:18px">※※  用心和世界对话  ※※</div><p>“您为什么要那样说呢？”<br>“为了向你证实一个简单的真理。” 炼金术士回答，“当巨大的财富就在我们眼前时，我们却从来都觉察不到。你知道为什么？因为人们不相信财宝存在。”</p><p>万物讲很多种语言。</p><p>此前沙漠是一片广袤的天地，现在却变成了一道无法逾越的坚壁。</p><p>“如果你必死无疑，它们对你又有什么用处呢？”炼金术士回答说，“你的钱救了你，还能多活三天。钱能用来推迟死期，这种事并不多见。”</p><p>你不要陷入绝望而不能自拔，这样会使你无法和自己的新沟通。</p><p>风一向无所不知。</p><p>上帝的灵魂就是他自己的灵魂。</p><p>所有人都被这种魔法吓坏了，只有两个人脸上露出了微笑：一个是炼金术士，因为他找对了弟子；另一个是<span style="border:1px solid #000">指挥官</span>，因为他理解了上帝的荣耀。</p><p>夜幕降临，他们来到一座科普特人的修道院前。</p><p><span style="color:#195"><br>“这块金子给你，因为你对待路人十分慷慨。”<br>“我得到的报酬远胜于我的慷慨。”<span style="border:1px solid #000">修士</span>回答。<br>“永远别再这么说，生活会听在耳内，下一次就会少给你。”<br></span></p><p><span style="color:red">所有发生过一次的事，可能永远不会再发生；但所有发生过两次的事，肯定还会发生第三次</span>。</p><p>炼金术士准备策马离去。<br>“做什么并不重要，世界上的每个人都在历史中扮演着重要的角色，但通常懵然不知。”</p><p>一轮满月悬在中天，星光灿烂。</p><p>他终于到达了藏宝之地。只有目标实现了，一项事业才算圆满成功。</p><p>圣地亚哥在他圈定的地方挖了整整一夜，结果一无所获。</p><p>“你在这儿干什么？”<br>“我们是躲避战乱的难民。” 其中<span style="border:1px solid #000">一个人</span>说。</p><p>“我们走吧。”<span style="border:1px solid #000">领头的</span>说，然后转向男孩。“你不会死的。”他说，“你将活下去，还会明白人不能太愚蠢。<span style="color:red">差不多两年前，就在你待着的这个地方，我也重复做过同一个梦。我梦见自己应该到西班牙的田野上去，寻找一座残破的教堂，一个牧羊人经常待着羊群在那里过夜。圣器室所在的地方有一棵无花果树。如果我在无花果树下挖掘，一定能找到一笔宝藏。但是我可没有那么蠢，不会因为重复做了同一个梦就去穿越一大片沙漠。</span>”</p><p>说完，他扬长而去。</p><p>圣地亚哥吃力的爬起来，他对金字塔报以微笑，心中无比幸福。他已经找到自己的宝藏了。</p><div style="color:green; font-size:18px">※※  尾声  ※※</div><p>圣地亚哥在夜幕将至的时候，赶到了那座废弃的小教堂。</p><p>现在他又来到了这里，没有带着羊群，而是带了把铁锹。</p><p>“如果我事先告诉你，你就看不到金字塔了。它们很壮美，不是吗？”</p><p><span style="color:red">生活对追随自己天命的人真的很慷慨。</span></p><h4 id="第三部分-后记"><a href="#第三部分-后记" class="headerlink" title="第三部分 后记"></a>第三部分 后记</h4><p>“多美的故事啊！” 我读完之后发出了和炼金术士一样的感慨。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;无疑，这是一本非常牛B的📚，至少在我的阅读经验里如此。此时，我将写下一篇冗长的阅读笔记，记录我对它的感觉以及探索。在这篇文章里，我将以&lt;code&gt;基本故事&lt;/code&gt;、&lt;code&gt;奇幻之旅&lt;/code&gt;、&lt;code&gt;后记&lt;/code&gt;的结构来进
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [05]-javaScript和JSON</title>
    <link href="https://weibo.com/u/3800117445/2018/04/16/javaScript%E7%B3%BB%E5%88%97%20%5B05%5D-javaScript%E5%92%8CJSON/"/>
    <id>https://weibo.com/u/3800117445/2018/04/16/javaScript系列 [05]-javaScript和JSON/</id>
    <published>2018-04-16T12:20:13.000Z</published>
    <updated>2018-05-08T07:00:42.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文输出和JSON有关的以下内容<br>❐  JSON和javaScript<br>❐  JSON的语法介绍<br>❐  JSON的数据类型<br>❐  JSON和XMLHTTPRequest<br>❐  JSON的序列化和反序列化处理</p></blockquote><h3 id="1-1-JSON和javaScript"><a href="#1-1-JSON和javaScript" class="headerlink" title="1.1 JSON和javaScript"></a>1.1 JSON和javaScript</h3><p><span style="color:red">JSON是一种数据交换格式。</span></p><p>JSON的全称是JavaScript Object Notation，翻译为JavaScript对象表示法。JSON的这个全称，无疑让很多人既兴奋又困惑，兴奋的人直接认为这就是JavaScript中的对象，困惑的人觉察出JSON数据和JavaScript对象好像有些不一样。接下来我们先谈一谈JSON数据和JavaScript的关系。</p><p>诚然，从JSON的全称可以看出JSON和JavaScript语言必定有种某种神秘关联，至少能够确定的是JSON的命名确实来源于JavaScript这门语言。</p><p>JSON基于JavaScript对象字面量，但JSON本身是一种数据交换格式，因此它是独立于语言的。JSON全称为JavaScript对象表示法，在理解的时候可以认为<span style="color:red">JSON ==&gt; JavaScript &amp;&amp; 对象 &amp;&amp; 表示法</span></p><p>JavaScript我们知道是一门动态脚本语言，那么<code>对象表示法</code>是什么？</p><p>对象是面向对象编程语言中一种常见的数据类型，表示键值对的集合，那么<code>表示法</code>是什么？</p><p><strong>表示法</strong>:是指一个可以表示诸如数字或单词等数据的字符系统。</p><p>JSON起源于JavaScript（灵感来源于JavaScript的对象语法），但真正重要的是具体的表示法本身。JSON不仅独立于语言，而且使用了一种在许多编程语言中能够找到共同元素的表达方式。基于这种简洁的表达方式，JSON迅速成为一种流行的数据交换格式。目前，客户端和服务器端在进行数据通信的时候，常见的数据格式就是JSON和XML。</p><h3 id="1-2-JSON的语法介绍"><a href="#1-2-JSON的语法介绍" class="headerlink" title="1.2 JSON的语法介绍"></a>1.2 JSON的语法介绍</h3><h4 id="1-2-1-JSON的语法"><a href="#1-2-1-JSON的语法" class="headerlink" title="1.2.1 JSON的语法"></a>1.2.1 JSON的语法</h4><p> JSON因为基于JavaScript的字面量，所以我们先来看下JavaScript字面量的样子，下面给出简单的代码示例，描述了一个书对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  book = &#123;</div><div class="line">      name:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">      price:<span class="number">42.00</span>,</div><div class="line">      author:<span class="string">"福柯"</span>,</div><div class="line">      press:<span class="string">"北京大学出版社"</span>,</div><div class="line">      read:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p>顺便贴出一个简短的JSON数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="attr">"name"</span>:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">      <span class="attr">"price"</span>:<span class="number">42.00</span>,</div><div class="line">      <span class="attr">"author"</span>:<span class="string">"福柯"</span>,</div><div class="line">      <span class="attr">"press"</span>:<span class="string">"北京大学出版社"</span>,</div><div class="line">      <span class="attr">"content"</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="number">123</span>]</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p> 我们可以对比下上面的JavaScript对象和JSON数据，会发现它们的结构和语法形式很像，都是键值对的集合，接下来我们做更详细的说明。JSON数据在表达上和对象保持一致，但因为数据交换格式的核心是数据，所以<code>JSON并不会保存函数等信息</code>。JSON数据所基于的JavaScript对象字面量单纯指对象字面量以及其属性的语法表示。</p><p><strong>JSON的主要语法特点</strong></p><blockquote><p>① 以键值对的方式来保存数据<br>② 标准的JSON数据的key必须要使用双引号包裹<br>③ { } 用于表示和存放对象，[ ] 用于表示和存放数组数据</p></blockquote><p>JSON数据的读取，在读取JSON的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; 表示开始读取对象，&#125; 表示对象读取结束</div><div class="line">[ 表示开始读取数组，] 表示数组读取结束</div><div class="line">：用于分隔键值对中的key和value</div><div class="line">, 用于分隔对象中的多个键值对或者是数组中的多个元素</div></pre></td></tr></table></figure></p><p><div class="tip"><br>JavaScript对象字面量中的key可以使用单引号，可以使用双引号，可以不必加上引号包裹，但是在JSON中，所有的key必须要加上双引号。</div></p><div><h4 id="1-2-2-JSON的验证和格式化工具"><a href="#1-2-2-JSON的验证和格式化工具" class="headerlink" title="1.2.2 JSON的验证和格式化工具"></a>1.2.2 JSON的验证和格式化工具</h4><p>下面列出一些能够对JSON数据进行校验和格式化的在线地址<br><a href="https://jsonlint.com/" target="_blank" rel="external">https://jsonlint.com/</a><br><a href="http://tool.oschina.net/codeformat/json" target="_blank" rel="external">http://tool.oschina.net/codeformat/json</a><br><a href="https://jsonformatter.curiousconcept.com/" target="_blank" rel="external">https://jsonformatter.curiousconcept.com/</a></p><h4 id="1-2-3-JSON文件和MIME类型"><a href="#1-2-3-JSON文件和MIME类型" class="headerlink" title="1.2.3 JSON文件和MIME类型"></a>1.2.3 JSON文件和MIME类型</h4><p>在开发中我们经常需要处理大量的JSON数据，JSON这种数据交换格式可以作为独立的文件存在于文件系统中，文件扩展名为    <code>.json</code></p><p>JSON的MIME类型是<code>application/json</code>, 详细信息请参考<a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">IANA官网维护的所有媒体类型列表</a>。</p><h3 id="1-3-JSON的数据类型"><a href="#1-3-JSON的数据类型" class="headerlink" title="1.3 JSON的数据类型"></a>1.3 JSON的数据类型</h3><p>JSON中（作为value值）的数据类型包括<code>对象、字符串、数字、布尔值、null和数组六种</code>。</p><p><code>① 字符串</code><br>JSON中的字符串可以由任何的Unicode字符构成，字符串的两边必须被双引号包裹。需要注意的是：<span style="color:#195">虽然在JavaScript语言中字符串可以使用单引号来包裹，但是在JSON中的字符串必须使用双引号包裹。</span></p><p>如果字符串中存在以下特殊字符，那么需要在它们的前面加上一个反斜线（\）来进行转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- &quot;  双引号</div><div class="line">- \  反斜线</div><div class="line">- \/ 正斜线</div><div class="line">- \b 退格符</div><div class="line">- \f 换页符</div><div class="line">- \t 制表符</div><div class="line">- \n 换行符</div><div class="line">- \r 回车符</div><div class="line">- \u 后面跟16进制字符</div></pre></td></tr></table></figure></p><p><code>② 数字</code><br>JSON中的数字可以是整数、小数、负数或者是指数。</p><p><code>③ 布尔类型</code><br>JSON数据仅仅支持小写形式的布尔类型值：true 和 false。</p><p><code>④ null类型</code><br>JSON中没有undefined这种数据类型，它使用null表示空，并且必须小写。<br>在JavaScript语言中，var obj = null 表示把obj这个对象清空，它和undefined不太一样，null表示什么都没有，undefined表示未定义。</p><p><code>⑤ 对象类型</code><br>对象类型是使用逗号分隔的键值对的集合，使用大括号(<code>{}</code>)裹。</p><p><code>⑥ 数组类型</code><br>数组类型是元素的集合，每个元素都可以是字符串、数字、布尔值、对象或者数组中的任何一种。元素与元素之间使用逗号隔开，所有的元素被方括号（<code>[]</code>）包裹，建议数组中所有的元素都应该是相同数据类型的。</p><h3 id="1-4-JSON和XMLHTTPRequest"><a href="#1-4-JSON和XMLHTTPRequest" class="headerlink" title="1.4 JSON和XMLHTTPRequest"></a>1.4 JSON和XMLHTTPRequest</h3><p>在前端开发中有一种发送网络请求的技术Ajax，它可以实现异步处理网络通信而不刷新页面。</p><p>Ajax的全称为Asynchronous JavaScript and XML，即异步的JavaScript和XML。我们知道JSON的定位是轻量级的数据交互格式，客户端在和服务器端进行网络通信的时候，服务器端返回给我们的数据大多数是JSON或者是XML。也就是说JSON数据在Ajax网络通信中可能扮演重要的角色，<code>那什么Ajax不叫异步的JSON而叫做异步的XML呢？</code> 答案是：因为刚提出这种网络请求技术的时候，XML相比JSON更流行。</p><p>在Ajax网络请求中用到的核心对象XMLHTTPRequest也是如此，其实这个对象命名中包含XML也仅仅是因为对于当时而言，XML是网络请求中最常用的数据交换格式。如果放在今天，那么它们的名字应该叫做AjaJ(Asynchronous JavaScript and JSON)和JSONHTTPRequest更合适一些。</p><h3 id="1-5-JavaScript中JSON数据的序列化和反序列化处理"><a href="#1-5-JavaScript中JSON数据的序列化和反序列化处理" class="headerlink" title="1.5 JavaScript中JSON数据的序列化和反序列化处理"></a>1.5 JavaScript中JSON数据的序列化和反序列化处理</h3><p>在网络请求中，如果服务器返回给我们的数据是JSON数据，那么为了方便对数据的操作，通常我们在网络请求成功拿到JSON数据之后会先对JSON数据进行反序列化操作。<br>在前端开发中，早期的JSON解析基本上由eval函数来完成，ECMAScript5对解析JSON的行为进行了规范，定义了全局对象JSON。目前IE8+、FireFox 3.5+、Opera 10.5、Safari 4+和Chrome等浏览器均支持原生的JSON全局对象。</p><p><strong>JSON数据的处理主要涉及到两方面：<span style="color:#f55">序列化处理和反序列化处理</span></strong></p><h4 id="1-5-1-使用eavl函数来处理JSON数据"><a href="#1-5-1-使用eavl函数来处理JSON数据" class="headerlink" title="1.5.1 使用eavl函数来处理JSON数据"></a>1.5.1 使用eavl函数来处理JSON数据</h4><p><strong>eavl函数说明</strong></p><p>JavaScript语言中eavl函数可以把字符串转换为js的代码并且马上执行，使用情况和Function构造函数用法类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"var a = 123;"</span>);</div><div class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>);  <span class="comment">//输出结果为124</span></div></pre></td></tr></table></figure></p><p>因为从某种程度上来讲，json其实是JavaScript语言的严格子集，所以我们可以直接通过eval函数来对json数据进行解析。需要注意的是，使用eavl函数来对json数据结构求值存在风险，因为可能会执行一些恶意代码。</p><p><strong>eavl函数解析JSON</strong></p><p>服务器返回给前端的json数据可能是<code>{...}</code>形式的，也可能是<code>[...]</code>形式的，分别对应js中的对象和数组。如果是<code>{...}</code>形式的，那么在解析的时候，如果直接以eval(json)的方式处理会报错，因为js中不允许直接写{name:”zs”}类似的语句。遇到这种结构的json数据，通常我们有两种方式进行处理：<span style="color:#f22">① 包装成表达式 ② 赋值给变量。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//001 [...] 格式的json数据</span></div><div class="line"><span class="keyword">var</span> arrJson= <span class="string">'[&#123;"name":"zs","age":18&#125;,&#123;"name":"lisi","age":28&#125;]'</span>;</div><div class="line"><span class="keyword">var</span> jsonArr = <span class="built_in">eval</span>(arrJson);</div><div class="line"></div><div class="line"><span class="comment">//002 &#123;...&#125; 格式的json数据</span></div><div class="line"><span class="keyword">var</span> objJson = <span class="string">`&#123;"name":"wendingding","age":18,"contentAbout":["JavaScript","CSS","HTML"],"car":&#123;"number":"粤A6666","color":"red"&#125;&#125;`</span>;</div><div class="line"></div><div class="line"><span class="comment">//eval(json);  错误的演示：报错</span></div><div class="line"><span class="comment">//处理方式(1)：以拼接的方式赋值给变量</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"var jsonObj1 = "</span> + objJson);</div><div class="line"><span class="comment">//处理方式(2)：包装成表达式</span></div><div class="line"><span class="keyword">var</span> jsonObj2 = <span class="built_in">eval</span>(<span class="string">"("</span> + objJson +<span class="string">")"</span>);</div><div class="line"></div><div class="line"><span class="comment">//打印转换后得到的数组|对象</span></div><div class="line"><span class="built_in">console</span>.log(jsonArr);</div><div class="line"><span class="built_in">console</span>.log(jsonObj1);</div><div class="line"><span class="built_in">console</span>.log(jsonObj2);</div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_10.png?raw=true" height="250"></p><h4 id="1-5-2-使用JSON全局对象来处理JSON数据"><a href="#1-5-2-使用JSON全局对象来处理JSON数据" class="headerlink" title="1.5.2 使用JSON全局对象来处理JSON数据"></a>1.5.2 使用JSON全局对象来处理JSON数据</h4><p>JSON全局对象拥有两个方法：stringify()和parse()，其中parse方法用于把json数据反序列化为原生的js，stringify方法用于把js对象序列化为json字符串。</p><p><strong>parse方法的使用</strong><br><span style="color:#f55">语法：JSON.parse(jsonString,[fn])</span></p><p>参数说明</p><blockquote><p>第一个参数：jsonString为要解析的json字符串<br>第二个参数：fn是一个可选参数，该参数为函数类型，接收两个参数，分别是每个键值对的key和value。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//json字符串</span></div><div class="line"><span class="keyword">var</span> objJson = <span class="string">`&#123;"name":"wendingding","age":18,"contentAbout":["JavaScript","CSS","HTML"],"car":&#123;"number":"粤A6666","color":"red"&#125;&#125;`</span>;</div><div class="line"></div><div class="line"><span class="comment">//把json字符串转换为js数组</span></div><div class="line"><span class="keyword">var</span> arrJson= <span class="string">'[&#123;"name":"zs","age":18&#125;,&#123;"name":"lisi","age":28&#125;]'</span>;</div><div class="line"></div><div class="line"><span class="comment">//把json字符串转换为js对象</span></div><div class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(objJson);</div><div class="line"><span class="keyword">var</span> jsonArr = <span class="built_in">JSON</span>.parse(arrJson);</div><div class="line"><span class="built_in">console</span>.log(jsonObj);</div><div class="line"><span class="built_in">console</span>.log(jsonArr);</div><div class="line"></div><div class="line"><span class="comment">//演示parse方法中函数参数的使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">"name"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="string">"++"</span>         <span class="comment">//在原有value值的基础上拼接++字符串</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"age"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>            <span class="comment">//如果返回undefined，则表示删除对应的键值对</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> value                <span class="comment">//正常返回对应的value值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(objJson, fn));</div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_11.png?raw=true" height="250"></p><p><strong>stringify方法使用说明</strong><br><span style="color:#f55">语法：JSON.stringify(Obj,[fn|arr],[space])</span></p><p>参数说明</p><blockquote><p>第一个参数：Obj为要进行序列化操作的JavaScript对象<br>第二个参数：过滤器，可以是函数或者是一个数组<br>第三个参数：是否在生成的json字符串中保留缩进，用于控制缩进的字符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js中的普通对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"zs"</span>,</div><div class="line">    age:<span class="number">18</span>,</div><div class="line">    friends:[<span class="string">"小霸王"</span>,<span class="string">"花仙子"</span>,<span class="string">"奥特曼"</span>],</div><div class="line">    other:<span class="literal">undefined</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//把js中的对象转换为json字符串</span></div><div class="line"><span class="comment">//注意：</span></div><div class="line"><span class="comment">//001 如果键值对中存在value值为undefined的数据，那么会被跳过</span></div><div class="line"><span class="comment">//002 对象中的方法以及该对象的原型成员数据在进行转换的时候，会被有意忽略</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj));</div><div class="line"></div><div class="line"><span class="comment">//控制缩进，该参数的值可以是数字也可以是字符串，自动换行</span></div><div class="line"><span class="comment">//001 如果是字符串那么会把对应的字符拼接在键值对前面，超过10个字符的省略</span></div><div class="line"><span class="comment">//002 如果是数字那么会设置对应的缩进，最多为10，超过则默认为10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">"@@"</span>));</div><div class="line"></div><div class="line"><span class="comment">//过滤器（数组）：表示只处理key为name和age这两个键值对</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, [<span class="string">"name"</span>,<span class="string">"age"</span>]));</div><div class="line"></div><div class="line"><span class="comment">//过滤器（函数）：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">key,value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">"age"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="number">20</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"name"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;       <span class="comment">//过滤掉key为name这个键值对</span></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj,fn));</div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_12.png?raw=true" height="300" width="600"></p><p><strong>JSON数据总结</strong></p><blockquote><p>❐  JSON全称是JavaScript Object Notation基于JavaScript，是JavaScript的子集。<br>❐  JSON虽然是JavaScript的子集，但并不从属于JavaScript，它独立于语言。<br>❐  JSON是用来表示和传输数据的格式，比XML更轻量级，现已成为web数据交换的事实标准。<br>❐  JSON的优势在于其可以方便的把JSON字符串数据转换为对应的对象，比XML更方便且数据更小。<br>❐  JSON语法可以表示：字符串、数值、布尔值、null、对象和数组6种类型的值，不支持undefined。<br>❐  JSON中的”键”区别于JavaScript，必须要加上双引号。<br>❐  JSON解析可以使用传统的eval函数，或ECMAScript5推出的全局对象来处理。</p></blockquote><p><strong>参考资料</strong></p><p>JSON官网：<a href="http://json.org/" target="_blank" rel="external">http://json.org/</a><br>JSON维基百科：<a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">https://en.wikipedia.org/wiki/JSON</a><br>JSON作者简介：<a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="external">https://en.wikipedia.org/wiki/Douglas_Crockford</a><br>JSON必知必会:<a href="https://book.douban.com/subject/26789960/" target="_blank" rel="external">https://book.douban.com/subject/26789960/</a><br>JavaScript高级程序设计：<a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">https://book.douban.com/subject/10546125/</a></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文输出和JSON有关的以下内容&lt;br&gt;❐  JSON和javaScript&lt;br&gt;❐  JSON的语法介绍&lt;br&gt;❐  JSON的数据类型&lt;br&gt;❐  JSON和XMLHTTPRequest&lt;br&gt;❐  JSON的序列化和反序列化处理&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [04]-javaScript的原型链</title>
    <link href="https://weibo.com/u/3800117445/2018/04/15/javaScript%E7%B3%BB%E5%88%97%20%5B04%5D-javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://weibo.com/u/3800117445/2018/04/15/javaScript系列 [04]-javaScript的原型链/</id>
    <published>2018-04-14T17:20:13.000Z</published>
    <updated>2018-04-16T11:23:45.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。</p></blockquote><h4 id="1-1-理解原型链"><a href="#1-1-理解原型链" class="headerlink" title="1.1 理解原型链"></a>1.1 理解原型链</h4><p>JavaScript中几乎所有的东西都是对象，我们说数组是对象、DOM节点是对象、函数等也是对象，创建对象的Object也是对象（本身是构造函数），那么有一个重要的问题：<code>对象从哪里来？</code></p><p>这是一句废话，对象当然是通过一定方式创建出来的，根据实际类型不同，对象的创建方式也千差万别。比如函数，我们可以声明函数、使用Function构造函数创建等，比如数组，我们可以直接通过var arr  = [] 的方式创建空数组，也可以通过new Array的方式创建，比如普通的对象，我们可以字面量创建、使用内置构造函数创建等等，花样太多了，以至于我们学习的时候头昏脑涨、不得要领。</p><p><span style="color:red">其实，归根结底所有“类型”的对象都可以认为是由相应构造函数创建出来的。</span> 函数由Function构造函数实例化而来，普通对象由Object构造函数实例化而来，数组对象由Array构造函数实例化而来，至于Object | Array | Function等他们本身是函数，当然也有自己的构造函数。</p><p>理解了上面一点，那么接下来我们在理解原型链的时候就会容易得多。</p><blockquote><p>请看刺激的推导过程</p><p>前提 所有对象都由构造函数实例化而来，构造函数默认拥有与之相关联的原型对象<br>❒  ① 构造函数的原型对象也是对象，因此也有自己的构造函数<br>❒  ② 构造函数原型对象的构造函数，也有与之相关连的原型对象<br>❒  ③ 构造函数原型对象的原型对象（<code>__proto__</code>）也有自己的构造函数，其也拥有关联的原型对象<br>☞ 以上就形成了一种链式的访问结构，是为<code>原型链</code>。</p></blockquote><p><div class="tip"><br>其实构造函数也是对象，所以构造函数本身作为对象而言也有自己的构造函数，而这个构造函数也拥有与之相关联的原型对象，以此类推。那么，这就是另一条原型链了。综上，我们可以得出<code>原型链并不孤单</code>的结论。<div></div></div></p><h4 id="1-2-原型链结构"><a href="#1-2-原型链结构" class="headerlink" title="1.2 原型链结构"></a>1.2 原型链结构</h4><p>现在我们基本上把原型链的由来说清楚了，那么接下来通过具体的代码来分析原型链的整体结构。</p><p>示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 自定义构造函数Person和Animal</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();</div><div class="line"></div><div class="line"> <span class="comment">//03 创建数组对象</span></div><div class="line"><span class="keyword">var</span> arrM = [<span class="string">"demoA"</span>,<span class="string">"demoB"</span>];</div></pre></td></tr></table></figure></p><p>上面的代码非常简单，其中p1，p2和a它们是自定义构造函数的实例化对象。其次，我们采用快捷方式创建了arrM数组，arrM其实是内置构造函数Array的实例化对象。另外，Person和Animal这两个构造函数其实是Function构造函数的实例对象。理解以上几点后，我们就可以来看一下这几行代码对应的原型链结构图了。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_07.png?raw=true"></p><p>原型链结构图说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 因为复杂度关系，arrM对象的原型链结构图单独给出。</div><div class="line">② Object.prototype是所有原型链的顶端，终点为null。</div></pre></td></tr></table></figure></p><p>验证原型链相关的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证p1、p2的原型对象为Person.prototype</span></div><div class="line"><span class="comment">//    验证a    的原型对象为Animal.prototype</span></div><div class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p2.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a.__proto__ == Animal.prototype);  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 获取Person.prototype|Animal.prototype构造函数</span></div><div class="line"><span class="comment">//    验证Person.prototype|Animal.prototype原型对象为Object.prototype</span></div><div class="line"><span class="comment">//    先删除实例成员，通过原型成员访问</span></div><div class="line"><span class="keyword">delete</span>  Person.prototype.constructor;</div><div class="line"><span class="keyword">delete</span>  Animal.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[3] 验证Person和Animal的构造函数为Function</span></div><div class="line"><span class="comment">//    验证Person和Animal构造函数的原型对象为空函数</span></div><div class="line"><span class="built_in">console</span>.log(Person.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[4] 验证Function.prototype的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor == <span class="built_in">Function</span>);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[5] 验证Function和Object的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>);              <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[6] 验证Function.prototype的原型对象为Object.prototype而不是它自己</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[7] 获取原型链的终点</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);                    <span class="comment">//null</span></div></pre></td></tr></table></figure></p><p>下面贴出数组对象的原型链结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_08.png?raw=true"></p><p>验证数组对象原型链结构的代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证arrM的构造函数为Array</span></div><div class="line"><span class="comment">//方法1</span></div><div class="line"><span class="built_in">console</span>.log(arrM.constructor == <span class="built_in">Array</span>);                 <span class="comment">//true</span></div><div class="line"><span class="comment">//方法2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arrM));      <span class="comment">//[object Array]</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 验证Array的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>);             <span class="comment">//true</span></div><div class="line"><span class="comment">//[3] 验证Array构造函数的原型对象为Function.prototype(空函数)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype);     <span class="comment">//true</span></div><div class="line"><span class="comment">//[4] 验证Array.prototype的构造函数为Object,原型对象为Object.prototype</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">Array</span>.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor == <span class="built_in">Object</span>);         <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><h4 id="1-3-原型链的访问"><a href="#1-3-原型链的访问" class="headerlink" title="1.3 原型链的访问"></a>1.3 原型链的访问</h4><p><strong>原型链的访问规则</strong><br><span style="color"><br>对象在访问属性或方法的时候，先检查自己的实例成员，如果存在那么就直接使用，如果不存在那么找到该对象的原型对象，查找原型对象上面是否有对应的成员，如果有那么就直接使用，如果没有那么就顺着原型链一直向上查找，如果找到则使用，找不到就重复该过程直到原型链的顶端，此时如果访问的是属性就返回undefined，方法则报错。<br></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"wendingding"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    name:"自来熟",</div><div class="line">    showName:function () &#123;</div><div class="line">        <span class="keyword">this</span>.name.lastIndexOf()</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">//访问的是实例成员上面的name属性：wendingding</span></div><div class="line">p.showName();          <span class="comment">//打印wendingding</span></div><div class="line"><span class="built_in">console</span>.log(p.age);    <span class="comment">//该属性原型链中并不存在，返回undefined</span></div><div class="line">p.showAge();           <span class="comment">//该属性原型链中并不存在，报错</span></div></pre></td></tr></table></figure><blockquote><p>概念和访问原则说明<br>❐ 实例成员：实例对象的属性或者是方法<br>❐ 原型成员：实例对象的原型对象的属性或者是方法<br>❐ 访问原则：就近原则</p></blockquote><h4 id="1-4-getPrototypeOf、isPrototypeOf和instanceof"><a href="#1-4-getPrototypeOf、isPrototypeOf和instanceof" class="headerlink" title="1.4 getPrototypeOf、isPrototypeOf和instanceof"></a>1.4 getPrototypeOf、isPrototypeOf和instanceof</h4><p><strong>Object.getPrototypeOf方法</strong>用于获取指定实例对象的原型对象，用法非常简单，只需要把实例对象作为参数传递，该方法就会把当前实例对象的原型对象返回给我们。说白了，Object的这个静态方法其作用就是<span style="color:red">返回实例对象<code>__proto__</code>属性指向的原型prototype。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数F</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 使用构造函数F获取实例对象f</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</div><div class="line"></div><div class="line"><span class="comment">//03 测试getPrototypeOf方法的使用</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f));  <span class="comment">//打印的结果为一个对象，该对象是F相关联的原型对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === f.__proto__);  <span class="comment">//true</span></div></pre></td></tr></table></figure><p><strong>isPrototypeOf方法</strong>用于检查某对象是否在指定对象的原型链中，如果在，那么返回结果true，否则返回结果false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf(arr));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(arr));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(Person));<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>上述代码的原型链<br> ① p–&gt;Person.prototype –&gt;Object.prototype –&gt;null<br> ② arr–&gt;Array.prototype –&gt;Object.prototype –&gt;null<br>Object.prototype因处于所有原型链的顶端，故所有实例对象都继承于Object.prototype</p></blockquote><p><strong>instanceof运算符</strong>的作用跟isPrototypeOf方法类似，左操作数是待检测的实例对象，右操作数是用于检测的构造函数。<span style="color:red">如果右操作数指定构造函数的原型对象在左操作数实例对象的原型链上面，则返回结果true，否则返回结果false。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//04 Object构造函数的原型对象在Function这个实例对象的原型链中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="comment">//05 Function构造函数的原型对象在Object这个实例对象的原型链中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p><div class="tip"><br>注意：不要错误的认为instanceof检查的是<code>该实例对象是否从当前构造函数实例化创建的</code>,其实它检查的是实例对象是否从当前指定构造函数的原型对象继承属性。</div></p><div><p>我们可以通过下面给出的代码示例来进一步理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//04 替换Person默认的原型对象</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    showInfo:function () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"xxx"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//05 重置了构造函数原型对象之后，因为Person</span></div><div class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="comment">//06 在Person构造函数重置了原型对象后重新创建实例化对象</span></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//==&gt; 建议开发中，总是先设置构造函数的原型对象，之后在创建实例化对象</span></div></pre></td></tr></table></figure></p><p>贴出上面代码的原型链结构图（部分）<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_09.png?raw=true"></p><h4 id="1-5-原型链相关的继承"><a href="#1-5-原型链相关的继承" class="headerlink" title="1.5 原型链相关的继承"></a>1.5 原型链相关的继承</h4><p>继承是面向对象编程的基本特征之一，JavaScript支持面向对象编程，在实现继承的时候，有多种可行方案。接下来，我们分别来认识下<code>原型式继承、原型链继承以及在此基础上演变出来的组合继承</code>。</p><p><strong>原型式继承基本写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 提供超类型|父类型构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div></pre></td></tr></table></figure></p><p>贴出原型式继承结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/10.png?raw=true"></p><p><div class="tip">提示 该方式可以继承超类型中的原型成员，但是存在和超类型原型对象共享的问题<div></div></div></p><p><strong>原型链继承</strong></p><p>实现思想</p><blockquote><p>核心：把父类的实例对象设置为子类的原型对象 SubClass.prototype = new SuperClass();<br>问题：无法为父构造函数（SuperClass）传递参数</p></blockquote><p><strong>原型链继承基本写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> SuperClass();</div><div class="line">SubClass.prototype = sup;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//SuperClass的名称</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//SuperClass的名称</span></div></pre></td></tr></table></figure></p><p>贴出原型链继承结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/11.png?raw=true"></p><p><strong>组合继承</strong></p><p>实现思想</p><blockquote><p>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例成员的继承，并且解决了父构造函数传参问题</p></blockquote><p><strong>组合继承基本写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    SuperClass.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//(1)获取父构造函数的实例成员  Person.call(this,name);</span></div><div class="line"><span class="comment">//(2)获取父构造函数的原型成员  SubClass.prototype = SuperClass.prototype;</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub_one = <span class="keyword">new</span> SubClass(<span class="string">"zhangsan"</span>);</div><div class="line"><span class="keyword">var</span> sub_two = <span class="keyword">new</span> SubClass(<span class="string">"lisi"</span>);</div><div class="line"><span class="built_in">console</span>.log(sub_one);</div><div class="line"><span class="built_in">console</span>.log(sub_two);</div></pre></td></tr></table></figure><p>最后，贴出实例对象sub_one和sub_two的打印结果<br><img src="https://github.com/flowerField/Source/blob/master/Blog/12.png?raw=true" height="200"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-1-理解原型链&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [03]-javaScript原型对象</title>
    <link href="https://weibo.com/u/3800117445/2018/04/14/javaScript%E7%B3%BB%E5%88%97%20%5B03%5D-javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://weibo.com/u/3800117445/2018/04/14/javaScript系列 [03]-javaScript的原型链/</id>
    <published>2018-04-14T13:05:13.000Z</published>
    <updated>2018-04-16T11:23:45.659Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>引用： javaScript是一门基于原型的语言，它允许对象通过原型链引用另一个对象来构建对象中的复杂性，JavaScript使用原型链这种机制来实现动态代理。当试图去引用某一个属性时，它会遍历整个原型链，直到最后的节点。<a href="https://book.douban.com/subject/26583722/" target="_blank" rel="external">JavaScript专家编程·P24</a></p></blockquote><h4 id="1-1-原型对象说明"><a href="#1-1-原型对象说明" class="headerlink" title="1.1  原型对象说明"></a>1.1  原型对象说明</h4><p>在JavaScript中除了基本数据类型外的其它数据都是对象类型，包括对象、函数、数组等,它们跟原型对象密不可分。</p><p>JavaScript语言中有一个非常重要的概念，叫做<code>原型对象</code>，理解原型对象是进一步理解这门语言的基础，因为它是一门基于原型的语言，也因为所有的代码几乎都和原型对象有关，接下来我们先了解下原型对象是什么。</p><p><strong>原型对象</strong></p><p>在上一篇文章<a href="http://wendingding.cn/2018/04/13/javaScript%E7%B3%BB%E5%88%97%20[02]-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/" target="_blank" rel="external">JavaScript系列 [02]-javaScript对象探析</a>中，我们介绍了使用自定义构造函数创建对象的方式，<span style="color:red">在构造函数被创建出来的时候，系统会默认帮构造函数创建并关联一个Object类型的新对象，我们称该对象就是这个构造函数的原型对象，构造函数的原型对象默认是一个空对象。</span></p><h4 id="1-2-原型对象的性质"><a href="#1-2-原型对象的性质" class="headerlink" title="1.2  原型对象的性质"></a>1.2  原型对象的性质</h4><p>构造函数相关联的原型对象的成员（属性和方法），可以被使用该构造函数创建出来的对象访问，即以自定义构造函数方式创建出来的所有实例对象，都自动拥有和共享该构造函数原型对象中的所有属性和方法(<code>想一想为什么空对象可以使用toString方法，所有的数组都可以使用push等方法</code>)。</p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 打印构造函数相关联的原型对象</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype);  <span class="comment">//Objec类型的空对象</span></div><div class="line"></div><div class="line"><span class="comment">//03 给构造函数原型对象添加方法</span></div><div class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p.showName();       <span class="comment">//文顶顶</span></div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>代码说明</p><blockquote><p>☞ 上面的代码先提供了Person构造函数，该函数声明后，我们通过Person.prototype访问其原型对象打印得到一个Object类型的空对象，说明所有的构造函数创建后默认拥有prototype属性，即构造函数默认有一个相关联的原型对象（Object类型空对象）。</p><p>☞ 随后我们通过对象的动态特性给Person的原型对象添加了showName方法，通过打印结果可以验证构造函数的实例化对象(p)可以访问其原型对象上面的成员。</p></blockquote><p>通过对代码和其运行结果分析，我们不难得出构造函数（Person）、原型对象(Person.prototype)、实例对象（p）之间的关系图，如下。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_05.png?raw=true"></p><p><code>代码说明</code></p><blockquote><p><strong>① 实例对象p由Person构造函数实例化而来。</strong></p><p><strong>② Person构造函数可以通过prototype属性访问其原型对象。</strong></p><p><strong>③ 实例对象p可以通过<strong>proto</strong>属性访问其构造函数的原型对象</strong>（可以简称为p的原型对象，我们在说原型对象的时候，应该先确定主语是构造函数还是实例对象，如果主语是构造函数，那么指的是构造函数.prototype，如果主语是实例对象，那么指的是创建该实例对象的构造函数相关联的原型对象，表示为实例对象.<strong>proto</strong>）。</p><p><strong>④ 原型对象（Person.prototype）可以通过constructor(构造器)属性来访问其关联的构造函数，无法访问实例对象。</strong></p></blockquote><p>下面贴出上面代码更详细的原型结构关系图。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_06.png?raw=true"></p><p><strong>原型对象的访问</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//获取原型对象的方式</span></div><div class="line"><span class="comment">//01 构造函数访问原型对象：构造函数.prototype</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype);</div><div class="line"><span class="comment">//02 构造函数的实例对象访问原型对象：实例对象.__proto__</span></div><div class="line"><span class="built_in">console</span>.log(p.__proto__);</div><div class="line"><span class="built_in">console</span>.log(p.__proto__ == Person.prototype);</div><div class="line"><span class="comment">//03 通过Object.getPrototypeOf方法传递实例对象作为参数访问</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(p));</div></pre></td></tr></table></figure></p><p>总结一下，原型对象的访问方式如下</p><pre style="color:red">① 构造函数.prototype② 实例对象.__proto__③ Object.getPrototypeOf(实例对象)</pre><p><strong>原型对象总结</strong></p><blockquote><p>❐  <strong>所有的对象都拥有<code>__proto__</code>属性，函数既拥有prototype属性又拥有<code>__proto__</code>属性。</strong><br>❐  对象的<code>__proto__</code>属性指向其构造函数相关联的原型对象（<code>函数的__proto__属性也一样，指向其构造函数Function相关的原型对象，是一个空函数</code>）。<br>❐  函数的prototype属性指向默认相关联的原型对象（函数和构造函数本质无差别）。</p></blockquote><p><div class="tip"><br> <code>__proto__</code>是一个非标准属性，即ECMAScript中并不包含该属性，这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性，不具备通用性。建议在调试的时候可以使用该属性,但不能出现在正式的代码中，开发中可以使用Object.getPrototypeOf方法来替代。</div></p><div><h4 id="1-3-设置原型对象"><a href="#1-3-设置原型对象" class="headerlink" title="1.3  设置原型对象"></a>1.3  设置原型对象</h4><p>所谓设置原型对象就是给构造函数的原型对象添加成员（属性和方法），具体的方式有两种</p><blockquote><p>① 利用对象的动态特性设置<br>② 替换原有的原型对象</p></blockquote><p>代码示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 给构造函数原型对象添加方法</span></div><div class="line"><span class="comment">//设置原型对象的第一种方法</span></div><div class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名 "</span>+<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">Person.prototype.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄 "</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p1.showName();       <span class="comment">//姓名 文顶顶</span></div><div class="line">p1.showAge();        <span class="comment">//年龄 18</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"章飞一绝"</span>,<span class="number">99</span>);</div><div class="line">p2.showName();       <span class="comment">//姓名 章飞一绝</span></div><div class="line">p2.showAge();        <span class="comment">//年龄 99</span></div></pre></td></tr></table></figure><p>像上面代码这样直接利用对象的动态特性来设置原型对象，在原有原型对象的基础上添加属性和方法非常简单，但是如果要添加的方法或属性比较多，那么冗余代码会比较多，这种情况推荐直接替换原有的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 给构造函数原型对象添加方法</span></div><div class="line"><span class="comment">//设置原型对象的第二种方法：直接替换原先的原型对象</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    showName:function () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名 "</span>+<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    showAge:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"年龄 "</span>+<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p.showName();       <span class="comment">//姓名 文顶顶</span></div><div class="line">p.showAge();        <span class="comment">//年龄 18</span></div><div class="line"><span class="built_in">console</span>.log(p.constructor); <span class="comment">//Person函数</span></div></pre></td></tr></table></figure><p><code>注意</code> 如果是直接替换原型对象，那么需要修正构造器属性，让constructor指向构造函数。<br><code>说明</code> 因为替换的时候其实是用字面量的方式重新创建了新的对象，该对象作为Object构造函数的原型对象，内部没有constructor属性。这个时候如果要通过实例对象（比如p）的构造器属性判断其类型，那么会先在p身上找，没有则查找原型对象发现也没有，最终得到的Object.prototype身上的构造器属性，结果为Object 。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;引用： javaScript是一门基于原型的语言，它允许对象通过原型链引用另一个对象来构建对象中的复杂性，JavaScript使用原型链这种机制来实现动态代理。当试图去引用某一个属性时，它会遍历整个原型链，直到最后的节点。&lt;a href=&quot;http
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [02]-javaScript对象探析</title>
    <link href="https://weibo.com/u/3800117445/2018/04/13/javaScript%E7%B3%BB%E5%88%97%20%5B02%5D-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>https://weibo.com/u/3800117445/2018/04/13/javaScript系列 [02]-深入浅出javaScript中的对象/</id>
    <published>2018-04-13T06:05:13.000Z</published>
    <updated>2018-04-16T11:23:45.683Z</updated>
    
    <content type="html"><![CDATA[<p><div class="tip"><code>题记：</code>多年前，以非常偶然的方式关注了微信<code>公众号“面向对象”</code>，本以为这个公众号主要以分享面向对象编程的干货为主，不料其乃实实在在的猿圈相亲平台。通过查看公开资料，发现该公众号俨然是在以自己的方式来帮助广大单身程序猿们通往一条真真正正的面向对象编程之路，相对而言，编程和语言特性这些破事又算得了什么呢，先“找到对象”似乎才是更高层面的话题。这篇文章，我们不谈如何”面向对象”，只着力于JavaScript中对象特征、创建以及访问。<br>本文作为纯粹的技术文章，和“面向对象”公众号利益无关。</div></p><p><div></div></p><h4 id="1-1-javaScript中对象的个人档案"><a href="#1-1-javaScript中对象的个人档案" class="headerlink" title="1.1  javaScript中对象的个人档案"></a>1.1  javaScript中对象的个人档案</h4><p>javaScript是一门基于<code>弱类型、支持面向对象编程且基于原型继承的脚本语言</code>。</p><p><strong>对象说明</strong></p><p>在JavaScript语言中，对象是可变的键值对集合（或者称为属性的容器），通过对象我们可以方便的管理一组变量和函数。</p><p>用通俗的话来说，对象其实就是一堆变量和函数的集合。只是“定义”在对象中的变量，我们称为属性，“定义”在对象中的函数，我们称之为方法。</p><p><strong>数据类型和对象</strong></p><p>JavaScript中的数据类型可以分为<code>基本数据类型和复杂数据类型</code>。<br>其中基本数据类型有：数字(number)、字符串(string)、布尔值(boolean)、undefined值和null。</p><p>复杂数据类型可以简单理解为对象类型。在JavaScript中，数组是对象、函数是对象、正则表达式是对象，对象自然也是对象，它们在使用typeof 运算符时得到的结果为object，即对象类型。</p><p><div class="tip"><br>typeof对函数运算的结果为function，对null运算的结果为object，但这被认为是一个错误。</div></p><div><p><span style="red">JavaScript语言中的对象是无类型的</span>，对象可以拥有属性和方法，属性和方法都是以key-value的方式存储的。我们可以笼统的把方法和属性统一归类为属性（因为方法名其实和属性名没有任何本质的区别，属性和方法的分类方式只是对它们存储的内容进行人为区分），所以<code>对象其实就是键值对的集合</code>。</p><p><span style="red">对象通过引用来传递，它们永远不会被复制。</span></p><p><strong>对象的检查</strong></p><p>① 可以使用typeof来对对象类型进行简单的检查，但需要注意排除null的情况。</p><p>② 在开发中，经常会用到hasOwnProperty方法来过滤对象原型成员。</p><h4 id="1-2-javaScript中对象的获取方式"><a href="#1-2-javaScript中对象的获取方式" class="headerlink" title="1.2  javaScript中对象的获取方式"></a>1.2  javaScript中对象的获取方式</h4><p>JavaScript中对象的创建有多种方式，根据特定的应用场景，我们可以选择不同的更合适的方式来创建对象，简单可以归纳为以下情况：</p><blockquote><p>① 字面量的方式创建对象<br>② 内置构造函数创建对象<br>③ 封装工厂函数创建对象<br>④ 定义构造函数创建对象<br>⑤ 调用系统方法创建对象</p></blockquote><p>下面分别对上面列出的这些方式进行逐一介绍。</p><p><strong>字面量的方式创建对象</strong></p><p>基本写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  bookObj = &#123;</div><div class="line">       name:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">       price:<span class="number">42.00</span>,</div><div class="line">       author:<span class="string">"福柯"</span>,</div><div class="line">       press:<span class="string">"北京大学出版社"</span>,</div><div class="line">       read:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure></p><p>上面的代码中通过字面量的方式创建了bookObj对象，该对象拥有name、price、author和press属性，还拥有read方法。</p><p>对象字面量提供了一种非常方便的创建新对象的表示方法，一个对象就是包围在{}中的N(N&gt;=0)个键值对。对象字面量可以出现在任何允许表达式出现的地方。</p><p><strong>内置构造函数创建对象</strong></p><p>JavaScript中的内置构造函数主要有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span></div><div class="line"><span class="built_in">Number</span></div><div class="line"><span class="built_in">Boolean</span></div><div class="line"><span class="built_in">Date</span></div><div class="line"><span class="built_in">Array</span></div><div class="line"><span class="built_in">Function</span></div><div class="line"><span class="built_in">Object</span></div><div class="line"><span class="built_in">RegExp</span></div></pre></td></tr></table></figure></p><p><div class="tip">注意：(String Number Boolean 是区别于string number boolean的基本包装类型)</div></p><div><p>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">   book.name = <span class="string">"声名狼藉者的生活"</span>;</div><div class="line">   book.price = <span class="number">42.00</span>;</div><div class="line">   book.author = <span class="string">"福柯"</span>;</div><div class="line">   book.press = <span class="string">"北京大学出版社"</span>;</div><div class="line">   book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">   &#125;;</div></pre></td></tr></table></figure><p>这种写法相对字面量创建方式而言不够简洁和直观，而且本身的代码复用性不好，不推荐。</p><p><strong>工厂函数创建对象</strong></p><p>工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装，适用于大规模“批量生产”同类型的对象。<br>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提供工厂函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBookNew</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用工厂函数来创建对象</span></div><div class="line"><span class="keyword">var</span> book1 = createBookNew(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book2 = createBookNew(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book3 = createBookNew(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"></div><div class="line"><span class="comment">//打印对象的属性,调用对象的方法</span></div><div class="line"><span class="built_in">console</span>.log(book1.name);</div><div class="line"><span class="built_in">console</span>.log(book2.name);</div><div class="line"><span class="built_in">console</span>.log(book3.name);</div><div class="line"></div><div class="line">book1.read();</div><div class="line">book2.read();</div><div class="line">book3.read();</div></pre></td></tr></table></figure><p>总结工厂函数创建对象的实现过程</p><blockquote><p>① 提供一个创建对象的函数（参数）<br>② 在函数内使用new 关键字和构造器创建对象<br>③ 设置对象的属性和方法<br>④ 返回加工过的对象</p></blockquote><p><strong>自定义构造函数创建对象</strong></p><p>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//提供构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//使用new调用该构造函数时,默认在内部会先创建Object类型的实例对象</span></div><div class="line">   <span class="comment">//并把该对象关联到当前构造函数的原型对象上，并把函数内的this绑定到该对象</span></div><div class="line">   <span class="comment">//通过this来给实例对象设置属性和方法</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">    <span class="keyword">this</span>.author = author;</div><div class="line">    <span class="keyword">this</span>.press = press;</div><div class="line">    <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+<span class="keyword">this</span>.name+<span class="string">",作者为"</span>+<span class="keyword">this</span>.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//默认总是把新创建的实例对象返回</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new + 函数名() 的方式来调用</span></div><div class="line"><span class="keyword">var</span> bookObj = <span class="keyword">new</span> CreateBook(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div></pre></td></tr></table></figure><p><div class="tip"><br>构造函数和普通函数没有本质区别，约定使用new调用的构造函数的首字母应该大写。<br>构造函数的作用在于完成对象的初始化，对象的创建等工作由new关键字完成，组合使用。</div></p><div><p><code>工厂函数和构造函数创建对象过程简单对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 函数的首字母大写(用于区别构造函数和普通函数)</div><div class="line">② 创建对象的过程是由new关键字实现</div><div class="line">③ 在构造函数内部会自动的创建新对象,并赋值给this指针</div><div class="line">④ 自动返回创建出来的对象</div></pre></td></tr></table></figure><p><code>构造函数调用方式的返回值</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 如果在构造函数中没有显示的return，则默认返回的是新创建出来的对象</div><div class="line">② 如果在构造函数中显示的return，则依照具体的情况处理</div><div class="line">❐ return 的是对象类型数据，则直接返回该对象</div><div class="line">❐ return 的是null或其他基本数据类型数据，则返回新创建的对象（即this）</div></pre></td></tr></table></figure></p><p><span style="color:red">提示 </span>在开发中我们通过把自定义构造函数和原型对象结合在一起使用，这样可以充分的利用JavaScript原型链继承的特性并解决方法的共享问题。下面给出基本的代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//（1）提供Person构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//（2）替换Person默认的原型对象</span></div><div class="line">Person.prototype =&#123;</div><div class="line">    <span class="comment">//修正构造器属性 Object --&gt; Person</span></div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    //提供实例对象的初始化方法</div><div class="line">    init:function(name,age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name || <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//所有实例对象都需要访问的原型方法</span></div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//（3）使用new来调用构造函数以创建实例对</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//（4）调用init方法对实例对象进行初始化操作</span></div><div class="line">p.init(<span class="string">"文顶顶"</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure></p><p><strong>使用Object.create方法创建对象</strong></p><p>ES5提供了Object.create法来创建一个新对象，该方法在使用的时候会把传入的指定对象连接为新对象的原型对象。</p><p><code>语法</code><br><code>Object.create(proto, [propertiesObject])</code></p><p>参数说明<br>第一个参数proto：新创建对象的原型对象。<br>第二个参数propertiesObject：可选的参数，如果没有指定为 undefined，则表示要添加到新创建对象的可枚举属性信息，存放对象的属性描述符以及相应的属性名称。</p><blockquote><p>如果传入的参数为null，则创建出来的空对象不会继承Object原型成员，没有基础方法。<br>如果传入的参数为Object.prototype，那么创建出来的对象等同于{}空对象。</p></blockquote><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 字面量方式创建对象obj</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"wendingding"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//02 使用Object.create方法来创建新对象</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj);</div><div class="line"><span class="comment">//o是一个空对象，o.__proto__指向obj对象</span></div><div class="line"><span class="built_in">console</span>.log(o);</div><div class="line"><span class="comment">//wendingding 访问原型对象obj上面的name属性</span></div><div class="line"><span class="built_in">console</span>.log(o.name);</div><div class="line"></div><div class="line"><span class="comment">//03 测试传入null的情况</span></div><div class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">//打印结果为空对象，No properties 该对象身上没有任何成员</span></div><div class="line"><span class="built_in">console</span>.log(o1);</div><div class="line"></div><div class="line"><span class="comment">//04 测试传入Object.prototype的情况</span></div><div class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</div><div class="line"><span class="comment">//o2 是空对象，等价于&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(o2);</div></pre></td></tr></table></figure></p><h4 id="1-3-javaScript中对象的操作"><a href="#1-3-javaScript中对象的操作" class="headerlink" title="1.3  javaScript中对象的操作"></a>1.3  javaScript中对象的操作</h4><p>我们知道对象可以简单理解为键值对的集合，通过前面的阅读我们已经了解到如何创建对象，接下来我们接着探讨对象内部键值对的相关操作。</p><p>对象属性和方法的访问方式：点语法或者是[]语法。<br>对象属性和方法的操作方式：对象的操作方式和数据的操作方式保持一致，可以简单总结为<code>增删改查和遍历</code>操作。</p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//00 提供obj对象</span></div><div class="line"><span class="comment">//通过字面量方式创建obj对象，该对象现在拥有name属性和showName方法</span></div><div class="line"><span class="comment">//因使用字面量方式创建，所有obj的原型对象(__proto__)指向object.prototype</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"wendingding"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//01 添加属性或方法</span></div><div class="line"><span class="comment">//a 使用点语法来为obj对象添加age属性和showAge方法</span></div><div class="line">obj.age = <span class="number">18</span>;</div><div class="line">obj.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//b 使用中括号语法来为obj对象添加age属性和showAge方法</span></div><div class="line">obj[<span class="string">"class-name"</span>] = <span class="number">41</span>;</div><div class="line">obj[<span class="string">"showClassName"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>[<span class="string">"class-name"</span>]);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//02 修改属性或方法</span></div><div class="line"><span class="comment">//如果对象的属性已经存在，那么设置该属性的时候表示修改</span></div><div class="line">obj.age = <span class="number">20</span>;</div><div class="line">obj.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄"</span> + <span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 查询属性或者调用方法</span></div><div class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">//wendingding</span></div><div class="line"><span class="built_in">console</span>.log(obj[<span class="string">"age"</span>]);    <span class="comment">//20</span></div><div class="line">obj.showName();             <span class="comment">//wendingding</span></div><div class="line">obj[<span class="string">"showName"</span>]();          <span class="comment">//注意，不推荐使用这种方法</span></div><div class="line"></div><div class="line"><span class="comment">//04 删除对象中的属性或方法</span></div><div class="line"><span class="comment">//语法形式：delete 对象.属性 | delete 对象[属性]</span></div><div class="line"><span class="keyword">delete</span> obj.name;</div><div class="line"><span class="keyword">delete</span> obj[<span class="string">"showName"</span>];</div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line"></div><div class="line"><span class="comment">//05 对象的遍历</span></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">     <span class="built_in">console</span>.log(key, obj[<span class="string">"key"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>delete关键字说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">01 具体使用:</div><div class="line">        (1) 可以用来删除对象中指定的属性</div><div class="line">        (2) 用来删除没有使用var关键字声明的变量  delete 变量名|window.变量</div><div class="line">02 使用注意点</div><div class="line">        (1) 关键字在使用的时候有返回值,true|false 删除成功返回true</div><div class="line">        (2) 删除对象中不存在的属性,返回true</div><div class="line">        (3) 使用var声明的变量不能被直接删除</div><div class="line">        (4) 不能删除使用var声明的全局变量但是可以删除直接添加在window上面的属性</div><div class="line">        (5) 如果删除数组中的元素（数组也是对象）则数组中对应的元素内容被替换为undefined，索引保留。</div></pre></td></tr></table></figure></p><p><strong>对象属性说明</strong></p><blockquote><p>❐ 对象的属性名可以是任意字符串，包括空字符。<br>❐ 对象的属性名如果是合法的JavaScript标识符，则不必强制要求使用双引号括住属性名。<br>❐ 属性值可以是任何值（包括undefined）。<br>❐ 如果对象的属性名并非合法标识符，则建议使用[]语法来访问对象。<br>❐ 标识符规范：字母开头，后面跟1个或多个下划线、数字或字母。</p></blockquote><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;div class=&quot;tip&quot;&gt;&lt;code&gt;题记：&lt;/code&gt;多年前，以非常偶然的方式关注了微信&lt;code&gt;公众号“面向对象”&lt;/code&gt;，本以为这个公众号主要以分享面向对象编程的干货为主，不料其乃实实在在的猿圈相亲平台。通过查看公开资料，发现该公众号俨然是在以自己的
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [01]-javaScript函数基础</title>
    <link href="https://weibo.com/u/3800117445/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20%5B01%5D-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/"/>
    <id>https://weibo.com/u/3800117445/2018/04/11/javaScript系列 [01]-javaScript函数基本/</id>
    <published>2018-04-11T14:05:13.000Z</published>
    <updated>2018-04-16T11:23:45.718Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-函数的创建和结构"><a href="#1-1-函数的创建和结构" class="headerlink" title="1.1  函数的创建和结构"></a>1.1  函数的创建和结构</h4><p><strong>函数的定义</strong>：函数是JavaScript的基础模块单元，包含一组语句，用于代码复用、信息隐蔽和组合调用。</p><p><strong>函数的创建</strong>：在javaScript语言中，可以说函数是其最重要也最成功的设计。我们可以通过三种方式来创建函数。</p><p><code>① 函数声明</code><br><code>② 字面量方式创建</code><br><code>③ 使用Function构造函数创建</code></p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 函数声明</span></div><div class="line"><span class="comment">//函数名称为：f1,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 字面量创建函数</span></div><div class="line"><span class="comment">//使用字面量创建匿名函数并赋值给f2,可以通过f2来调用,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 构造函数创建</span></div><div class="line"><span class="comment">//f3函数为Function这个构造函数的实例化对象，如果不传递参数，那么创建出来的函数没有任何用处。</span></div><div class="line"><span class="comment">//在创建实例对象的时候我们可以通过参数列表的方式来指定f3的结构。</span></div><div class="line"><span class="comment">//构造函数的参数中最后一个参数为函数体的内容，其余均为函数的形参。</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数的调用</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f2(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div></pre></td></tr></table></figure></p><p><strong>函数的结构</strong><br>函数的一般表现形式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1,n2</span>) </span>&#123;</div><div class="line">    <span class="comment">//函数体的内容</span></div><div class="line">    <span class="keyword">return</span> n1 + n2; <span class="comment">//返回值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通常，函数包括四个部分：<br>（1）保留字，function。<br>（2）函数名，这里为fn。<br>（3）圆括号以及包围在圆括号中的一组参数。<br>（4）包括在花括号中的一组语句。</p><blockquote><p>❐ 函数名可以被省略（称为匿名函数），函数名可用于函数调用或者是递归调用，另外函数名可以被调试器和开发工具识别。</p><p>❐ 函数声明时的参数为形参，可以有多个，多个参数之间使用逗号进行分隔。<code>形参将在函数调用的时候被定义为函数中的局部变量，[注意]形参并不会像普通变量一样被初始化为undefined，它们的值根据函数调用时传入的实际参数值设置。</code>另外，函数调用的时候并不会对实参的类型进行检查。</p><p>❐ 函数体是一组语句，它们在函数<code>被调用</code>的时候执行。函数执行完毕后，会返回一个值。</p></blockquote><p> <strong>函数的调用</strong>：函数声明后可以通过（）运算符来进行调用，JavaScript语言中，只有函数可以被调用。当函数被调用的时候，如果存在参数传递，那么会把实参的值传递给形参，并按照从上到下的顺序逐条执行函数体内部的代码。</p><h4 id="1-2-函数和对象的关系"><a href="#1-2-函数和对象的关系" class="headerlink" title="1.2  函数和对象的关系"></a>1.2  函数和对象的关系</h4><p>JavaScript中的函数本质上就是对象。<br>在使用typeof 关键字对数据进行类型检查的时候，得到的结果可能会让我们产生错觉。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">   <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);      <span class="comment">//object</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);      <span class="comment">//function</span></div></pre></td></tr></table></figure></p><p>实际上，函数和对象没有质的区别，函数是特殊的对象。</p><blockquote><p>函数的特殊性<br>① 函数可以被（）运算符调用[最重要]。<br>② 函数可以创建独立的作用域空间。<br>③ 函数拥有标配的prototype属性。</p></blockquote><p>因为函数本身就是对象，所以在代码中函数可以像对象一样被使用，凡是对象可以出现的地方函数都可以出现。</p><blockquote><p>❐ 函数可以拥有属性和方法。<br>❐ 函数可以保存在变量、对象和数组中。<br>❐ 函数可以作为其它函数的参数（称为函数回调）。<br>❐ 函数可以作为函数的返回值进行返回。</p></blockquote><p><strong>函数和对象的原型链结构</strong><br>我们可以通过下面列出的简单示例代码来分析对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//字面量方式创建普通的对象</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">age</span>:<span class="string">"18"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//关于普通对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印o对象\n"</span>,o);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印o.__proto__\n"</span>,o.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印o.__proto__ === Object.prototype\n"</span>,o.__proto__ === <span class="built_in">Object</span>.prototype)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印o.constructor\n"</span>,o.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印o.constructor === Object\n"</span>,o.constructor === <span class="built_in">Object</span>);</div></pre></td></tr></table></figure></p><p>通过对该代码的运行和打印分析，可以得到下面的图示。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_01.png?raw=true"></p><p>我们也可以使用同样的方式来分析函数对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//使用构造函数Function 来创建函数(对象)</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"><span class="comment">//调用函数，证明该函数是合法可用的</span></div><div class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">//得到打印结果5</span></div><div class="line"></div><div class="line"><span class="comment">//关于函数对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印函数对象\n"</span>,f);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印f.__proto__\n"</span>,f.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印f.__proto__===Function.prototype\n"</span>,f.__proto__===<span class="built_in">Function</span>.prototype);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印f.constructor\n"</span>,f.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印f.constructor === Function\n"</span>,f.constructor === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意</span></div><div class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">"constructor"</span>));   <span class="comment">//检查constructor是否为函数f的实例成员(false)</span></div><div class="line"><span class="built_in">console</span>.log(f.__proto__.hasOwnProperty(<span class="string">"constructor"</span>)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>顺便贴出研究Function原型结构的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//说明：下面三行代码表明Function的原型对象指向一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);  <span class="comment">//ƒ () &#123; [native code] &#125;  是一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Function</span>.prototype));  <span class="comment">//[object Function]</span></div><div class="line"></div><div class="line"><span class="comment">//检查Function.prototype的原型链结构</span></div><div class="line"><span class="comment">//Function.prototype是一个空函数，是一个对象，而对象均由构造函数实例化产生</span></div><div class="line"><span class="comment">//检查Function.prototype的构造函数以及原型对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor  === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意：按照一般逻辑实例对象的__proto__(原型对象)应该指向创建该实例对象的构造函数的原型对象</span></div><div class="line"><span class="comment">//即此处应该表现为Function.prototype.__proto__---&gt;Function.prototype.constructor.prototype</span></div><div class="line"><span class="comment">//似乎可以得出推论：Function.prototype.__proto__ === Function.prototype == 空函数 但这是错误的</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</div></pre></td></tr></table></figure></p><p>通过对函数对象原型结构的代码探索，可以得到下图的原型链结构图（<code>注</code>：原型链并不完整）</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_02.png?raw=true"></p><p><strong>函数的其它隐藏细节</strong></p><p><span style="color:#ff3333">① 函数天生的prototype属性<span></span></span></p><p>每个函数对象在创建的时候会随配一个prototype属性，即每个函数在创建之后就天生拥有一个与之相关联的原型对象，这个关联的原型对象中拥有一个constructor属性，该属性指向这个函数。<br>简单描述下就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function f()&#123; //......&#125;  //声明函数</div><div class="line">//函数声明被创建后，默认拥有prototype属性---&gt;原型对象（空对象）</div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_03.png?raw=true"></p><p><div class="tip"><br>这里需要注意的是，很多人容易被自己的经验误导，认为新创建的函数对象身上除prototype实例属性外，还拥有constructor这个实例属性，因为我们经常看到<code>f.constructor类似的代码</code>，其实这里使用的constructor属性是从原型链中获取的，其实是f构造函数关联原型对象上面的属性，即Function.prototype.constructor。</div></p><div><p style="border: 1px solid #666;">备注：在<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-13.2" target="_blank" rel="external">ECMAScript标准中函数创建相关章节</a>有这样一句话：NOTE A prototype property is automatically created for every function, to allow for the possibility that the function will be used as a constructor.解释了给新创建函数添加prototype属性的意义在于便于该函数作为构造函数使用。</p><p><span style="color:#ff3333">② 函数何以能够被调用<span></span></span></p><p>我们已经理解了函数本身就是对象，但又区别于普通对象，最大的区别在于函数可以被调用，（）被称为调用运算符。</p><blockquote><p>❗️ 函数可以被调用的原因在于JavaScript创建一个函数对象时，会给该对象设置一个“调用”属性。当JavaScript调用一个函数时，可以理解为调用该函数的“调用”属性。</p></blockquote><h4 id="1-3-函数的调用和this参数"><a href="#1-3-函数的调用和this参数" class="headerlink" title="1.3  函数的调用和this参数"></a>1.3  函数的调用和this参数</h4><p>函数名后面跟上（）表明这是一个函数调用。<br><code>调用运算符：</code>是跟在任何产生一个函数值的表达式之后的一对圆括号。圆括号内可以包含N（N&gt;=0）个用逗号分隔开的表达式，每个表达式产生一个参数值。每个参数值被赋予函数声明时定义的形式参数名。</p><p><strong>函数的调用</strong><br>JavaScript中有四种调用函数的模式</p><p><code>① 对象方法调用模式</code><br><code>② 普通函数调用模式</code><br><code>③ 构造函数调用模式</code><br><code>③ 上下文的调用模式</code></p><p>除了声明函数时定义的形参外，每个函数还接收两个附加的参数，分别是this和arguments。其中arguments用于存储函数调用时接收到的实际参数，this的值则取决于函数的调用模式，下面分别讲解。</p><p><strong>普通函数调用模式</strong></p><p>当函数并不作为其他对象的属性，直接使用调用运算符来调用时，我们认为它使用<code>普通函数调用模式</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 声明函数fn</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//02 以普通函数调用模式来调用fn函数</span></div><div class="line">    fn(); <span class="comment">//this被绑定到全局对象window</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><p style="border: 1px solid #666;">备注：在我们看来上面的调用方式非常简单清楚，而且this的指向也没有任何问题。但<a href="http://json.org/" target="_blank" rel="external">JSON</a>的作者<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9" target="_blank" rel="external">Douglas Crockford</a>指出这是JavaScript语言设计上的一个错误。因为把this直接绑定给全局变量的方式没有考虑到函数作为内部函数（在其它函数内部声明的函数）使用过程中需要共享外部对象访问权的问题。<br>他指出正确的语言设计应该是，<code>当内部函数被调用时，函数内的this应该和外部函数的this保持一致，即这个this应该被绑定到外部函数的this变量。</code>无疑，这值得思考和讨论。</p><p><strong>对象方法调用模式</strong></p><p>对象是键值对的集合，对象可以拥有属性和方法。<br>当函数被保存为对象的属性时，我们称之为方法。<br>对象的方法需要通过<code>对象.方法（）</code>或者是<code>对象[方法]（）</code>的方式进行调用。<br>以对象方法的模式来对函数进行调用，函数内部的this被绑定给该对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 字面量的方式创建对象</span></div><div class="line">   <span class="comment">//02 o对象中拥有name属性和showName方法</span></div><div class="line">   <span class="keyword">var</span> o = &#123;</div><div class="line">       name:<span class="string">"文顶顶"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);   <span class="comment">//文顶顶</span></div><div class="line">       &#125;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">//03 以对象方法调用模式来调用showName函数</span></div><div class="line">   o.showName(); <span class="comment">//this被绑定到o对象</span></div></pre></td></tr></table></figure></p><p>❗️ this到对象的绑定发生在方法调用的时候。</p><p><strong>构造函数调用模式</strong></p><p><code>构造函数：</code>如果一个函数创建出来之后，我们总是希望使用new 前缀来调用它，那这种类型的函数就被称为构造函数。构造函数和普通函数本质上没有任何区别，开发者总是约定以函数名首字母大写的方式来人为进行区分。</p><p>如果以构造函数的方式来调用函数，那么在调用时，默认会创建一个连接到该构造函数原型对象上面的新对象，同时让this绑定到该新对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 声明构造函数Person</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//02 以构造函数的方式来调用Person</span></div><div class="line">   <span class="keyword">new</span> Person();  <span class="comment">//this被绑定到Person的实例化对象</span></div></pre></td></tr></table></figure><p>❗️ 构造函数调用方式也会改变函数中return语句的行为，如果显示的return语句后面跟着的不是对象类型的数据，那么默认返回this绑定的新对象。</p><p><strong>上下文的调用模式</strong></p><p>上下文的调用模式，即使用apply或则call方法来调用函数。<br>因为JavaScrip是一门函数式的面向对象编程语言，所有JavaScript中的函数本质上是对象，也因此函数也可以拥有方法。使用上下文模式对函数进行调用的时候，函数内部的this根据参数传递的情况进行绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明函数f</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(a, b, a+b);</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);       <span class="comment">//使用上下文模式调用时，this被绑定给o对象</span></div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//wendingding</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">//字面量的方式创建对象</span></div><div class="line">   <span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"wendingding"</span>&#125;;</div><div class="line"></div><div class="line">   <span class="comment">//使用apply和call方法来调用函数</span></div><div class="line">   f.apply(o, [<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line">   f.call(o,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">"apply"</span>));                 <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">"apply"</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>❐  apply和call方法调用函数，函数内部的this绑定给第一个参数。<br>❐  apply和call方法定义于Function的原型对象上，所以所有的函数都可访问。<br>❐  apply和call方法作用基本相同，参数传递的形式有所差别。</p></blockquote><h4 id="1-4-函数的参数（arguments）"><a href="#1-4-函数的参数（arguments）" class="headerlink" title="1.4  函数的参数（arguments）"></a>1.4  函数的参数（arguments）</h4><p>函数调用时，会完成实际参数对形式参数的赋值工作。<br>当实际参数的个数和形式参数的个数不匹配时，并不会导致运行错误。</p><blockquote><p>如果实际参数的数量过多，那么超出的那些参数会被忽略。<br>如果实际参数的数量不足，那么缺失的那些参数会被设置为undefined。<br>JavaScript在进行函数调用时不会对参数进行任何的类型检查。</p></blockquote><p>在函数的内部，我们总是可以获得一个免费配送的arguments参数。<br>arguments用于接收函数调用时传入的实际参数，它被设计成一个类似于数组的结构，拥有length属性，但因为它不是一个真正的数组所以不能使用任何数组对应的方法。</p><p>arguments参数的存在，使得我们可以编写一些无须指定形参个数的函数。<br>下面提供一份示例代码用于对传入的所有参数进行累加计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">var</span> count = <span class="built_in">arguments</span>.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            sum += <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">89</span>));   <span class="comment">//125</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h4 id="1-5-函数的返回值"><a href="#1-5-函数的返回值" class="headerlink" title="1.5  函数的返回值"></a>1.5  函数的返回值</h4><p><strong>函数的调用</strong>：调用一个函数会暂停当前代码的执行，把控制权和参数传递给正被调用的函数。当一个函数被调用的时候，它会先根据实际参数来对函数的形式参数进行初始化，然后从函数体中的第一个语句开始执行并遇到关闭函数体的 } 时结束。然后把控制权交还给调用该函数的上下文。</p><p><strong>函数的返回值</strong>：函数体中return语句可以用来让函数提前返回。当retun语句被执行时，函数会立即返回而不再执行余下的语句，return语句后面跟上返回的具体数据，可以是任意类型（包括函数）。</p><blockquote><p>❐ 函数总是会有一个返回值，如果没有使用return语句指定，那么将总是返回<code>undefined</code>。</p><p>❐ 函数的返回值还和它的调用方式有关系，如果使用new也就是也构造函数的方式来调用，若函数体中没有通过return语句显示的返回一个对象类型的数据，则<code>默认返回this（新创建的实例对象）</code>。</p><p>❗️ JavaScript不允许在return关键字和表达式之间换行。</p></blockquote><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-1-函数的创建和结构&quot;&gt;&lt;a href=&quot;#1-1-函数的创建和结构&quot; class=&quot;headerlink&quot; title=&quot;1.1  函数的创建和结构&quot;&gt;&lt;/a&gt;1.1  函数的创建和结构&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;函数的定义&lt;/strong&gt;：函数是Ja
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 Mac系统中Tree的使用</title>
    <link href="https://weibo.com/u/3800117445/2018/04/11/Mac%E7%B3%BB%E7%BB%9FTree%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/04/11/Mac系统Tree的使用/</id>
    <published>2018-04-11T11:45:13.000Z</published>
    <updated>2018-04-16T11:23:45.707Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作中需要以树状图的方式列出当前目录下面的文件结构，因此花了几分钟时间研究了下Tree的使用，故有此文。</p><p>如果是在Linux和Windows系统下，可以直接使用tree命令来查看目录的文件树，但是Mac OSX系统中提示没有相应的命令。</p><p>Mac OSX系统中想以文件树的方式查看目录，有两种方式；</p><p><span style="color: red">① 执行下面的shell命令</span></p><p><code>$ find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39;</code></p><p>上面的命令行可以帮助我们完成需求，但这种方式相对不太友好，所以不推荐。</p><p><span style="color: red">② 下载Tree组件使用（推荐）</span></p><p>在Mac OSX系统中，我们可以通过brew来下载Tree使用，下载后使用的方式和linux下保持一致。</p><p><div class="tip"><br>说明：如果系统中没有brew，那么需要先自行安装。<br><a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a>是一个包管理器，用于在Mac上安装一些OS X没有的UNIX工具。<br>Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。<br>Homebrew基于Ruby，安装过程请参考官网示例。</div></p><div><p>brew安装好之后，使用下面的命令来安装Tree组件。</p><p><code>$ brew install tree</code></p><p>Tree组件安装完成之后，可以通过    <code>$ tree --version</code>命令来查看版本并验证安装是否成功。<br>目前，最新的版本为v1.7.0，更详细的信息请移步<a href="http://mama.indstate.edu/users/ice/tree/" target="_blank" rel="external">Tree组件官网</a>。</p><p>另外，Tree提供了很多的命令选项来帮助我们对目录打印进行更精细的控制，可以通过<code>$ tree --help</code>命令来查看具体信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">usage: tree [-acdfghilnpqrstuvxACDFJQNSUX] [-H baseHREF] [-T title ]</div><div class="line">[-L level [-R]] [-P pattern] [-I pattern] [-o filename] [--version]</div><div class="line">[--help] [--inodes] [--device] [--noreport] [--nolinks] [--dirsfirst]</div><div class="line">[--charset charset] [--filelimit[=]#] [--si] [--timefmt[=]&lt;f&gt;]</div><div class="line">[--sort[=]&lt;name&gt;] [--matchdirs] [--ignore-case] [--] [&lt;directory list&gt;]</div><div class="line">  ------- Listing options -------</div><div class="line">  -a            All files are listed.</div><div class="line">  -d            List directories only.</div><div class="line">  -l            Follow symbolic links like directories.</div><div class="line">  -f            Print the full path prefix for each file.</div><div class="line">  -x            Stay on current filesystem only.</div><div class="line">  -L level      Descend only level directories deep.</div><div class="line">  -R            Rerun tree when max dir level reached.</div><div class="line">  -P pattern    List only those files that match the pattern given.</div><div class="line">  -I pattern    Do not list files that match the given pattern.</div><div class="line">  --ignore-case Ignore case when pattern matching.</div><div class="line">  --matchdirs   Include directory names in -P pattern matching.</div><div class="line">  --noreport    Turn off file/directory count at end of tree listing.</div><div class="line">  --charset X   Use charset X for terminal/HTML and indentation line output.</div><div class="line">  --filelimit # Do not descend dirs with more than # files in them.</div><div class="line">  --timefmt &lt;f&gt; Print and format time according to the format &lt;f&gt;.</div><div class="line">  -o filename   Output to file instead of stdout.</div><div class="line">  -------- File options ---------</div><div class="line">  -q            Print non-printable characters as &apos;?&apos;.</div><div class="line">  -N            Print non-printable characters as is.</div><div class="line">  -Q            Quote filenames with double quotes.</div><div class="line">  -p            Print the protections for each file.</div><div class="line">  -u            Displays file owner or UID number.</div><div class="line">  -g            Displays file group owner or GID number.</div><div class="line">  -s            Print the size in bytes of each file.</div><div class="line">  -h            Print the size in a more human readable way.</div><div class="line">  --si          Like -h, but use in SI units (powers of 1000).</div><div class="line">  -D            Print the date of last modification or (-c) status change.</div><div class="line">  -F            Appends &apos;/&apos;, &apos;=&apos;, &apos;*&apos;, &apos;@&apos;, &apos;|&apos; or &apos;&gt;&apos; as per ls -F.</div><div class="line">  --inodes      Print inode number of each file.</div><div class="line">  --device      Print device ID number to which each file belongs.</div><div class="line">  ------- Sorting options -------</div><div class="line">  -v            Sort files alphanumerically by version.</div><div class="line">  -t            Sort files by last modification time.</div><div class="line">  -c            Sort files by last status change time.</div><div class="line">  -U            Leave files unsorted.</div><div class="line">  -r            Reverse the order of the sort.</div><div class="line">  --dirsfirst   List directories before files (-U disables).</div><div class="line">  --sort X      Select sort: name,version,size,mtime,ctime.</div><div class="line">  ------- Graphics options ------</div><div class="line">  -i            Don&apos;t print indentation lines.</div><div class="line">  -A            Print ANSI lines graphic indentation lines.</div><div class="line">  -S            Print with CP437 (console) graphics indentation lines.</div><div class="line">  -n            Turn colorization off always (-C overrides).</div><div class="line">  -C            Turn colorization on always.</div><div class="line">  ------- XML/HTML/JSON options -------</div><div class="line">  -X            Prints out an XML representation of the tree.</div><div class="line">  -J            Prints out an JSON representation of the tree.</div><div class="line">  -H baseHREF   Prints out HTML format with baseHREF as top directory.</div><div class="line">  -T string     Replace the default HTML title and H1 header with string.</div><div class="line">  --nolinks     Turn off hyperlinks in HTML output.</div><div class="line">  ---- Miscellaneous options ----</div><div class="line">  --version     Print version and exit.</div><div class="line">  --help        Print usage and this help message and exit.</div><div class="line">  --            Options processing terminator.</div></pre></td></tr></table></figure><p>常用的命令参数列出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">-------清单选项-------</div><div class="line">  -a 列出所有文件和目录。</div><div class="line">  -d 仅仅列出目录名称。</div><div class="line">  -f 打印显示每个文件的完整路径前缀。</div><div class="line">  -L 后面跟数字，控制列出几级目录。</div><div class="line">  --------文件选项---------</div><div class="line">  -q 用<span class="string">"?"</span>号取代控制字符，列出文件和目录名称。</div><div class="line">  -N 直接列出文件和目录名称，包括控制字符。</div><div class="line">  -Q 用双引号引用文件名。</div><div class="line">  -p 列出文件的权限标示。</div><div class="line">  -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</div><div class="line">  -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</div><div class="line">  -s 打印每个文件的字节大小。</div><div class="line">  -------排序选项-------</div><div class="line">  -v 按文本字母数字排序文件。</div><div class="line">  -t 按上次修改时间对文件进行排序。</div><div class="line">  -c 按上次状态更改时间对文件进行排序。</div><div class="line">  -U 保留文件未排序。</div><div class="line">  -r 反转排序的顺序。</div><div class="line">  --dirsfirst列出文件之前的目录（-U禁用）。</div><div class="line">  -------图形选项------</div><div class="line">  -i 不要打印缩进线。</div><div class="line">  -A 打印ANSI线图形缩进线。</div><div class="line">  -S 使用CP437（控制台）图形缩进线打印。</div><div class="line">  -n 始终关闭着色（-C覆盖）。</div><div class="line">  -C 总是打开彩色。</div><div class="line">  ------- XML / HTML / <span class="built_in">JSON</span>选项-------</div><div class="line">  -X 打印树的XML表示。</div><div class="line">  -J 打印出树的<span class="built_in">JSON</span>表示。</div><div class="line">  -H baseHREF以baseHREF作为顶层目录打印HTML格式。</div><div class="line">  ----其他选项----</div><div class="line">  --version打印版本并退出。</div></pre></td></tr></table></figure><p>使用示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">wendingding:wendingdingDemo wendingding$ cd /Users/文顶顶/Desktop/wendingdingDemo</div><div class="line">wendingding:wendingdingDemo wendingding$ tree -L <span class="number">1</span></div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── demo</div><div class="line">├── demo.html</div><div class="line">├── dist</div><div class="line">├── index.html</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line"></div><div class="line"><span class="number">4</span> directories, <span class="number">5</span> files</div></pre></td></tr></table></figure></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近工作中需要以树状图的方式列出当前目录下面的文件结构，因此花了几分钟时间研究了下Tree的使用，故有此文。&lt;/p&gt;
&lt;p&gt;如果是在Linux和Windows系统下，可以直接使用tree命令来查看目录的文件树，但是Mac OSX系统中提示没有相应的命令。&lt;/p&gt;
&lt;p&gt;Ma
      
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 前端开发Ajax简单介绍</title>
    <link href="https://weibo.com/u/3800117445/2018/01/26/Ajax%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://weibo.com/u/3800117445/2018/01/26/Ajax简单介绍/</id>
    <published>2018-01-26T09:05:13.000Z</published>
    <updated>2018-04-16T11:23:45.710Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-Ajax技术简单介绍"><a href="#1-1-Ajax技术简单介绍" class="headerlink" title="1.1 Ajax技术简单介绍"></a>1.1 Ajax技术简单介绍</h4><p><code>Ajax是一门异步的用于发送网络请求的技术。</code></p><p>全称为：Async javascript and XML。</p><p>简单说明：Ajax 这个概念是由 Jesse James Garrett 在 2005 年发明的。它本身不是单一技术，是一串技术的集合。</p><p>技术特点：通常情况下，每次提交表单的时候，都会刷新整个界面，而使用ajax发送请求可以实现异步发送请求获取数据而不需要刷新整个页面。</p><a id="more"></a><p><strong><code>Ajax的优点</code></strong></p><p> （1）不需要插件支持(一般浏览器且默认开启 JavaScript 即可);<br> （2）用户体验极佳(不刷新页面即可获取可更新的数据);<br> （3）提升 Web 程序的性能(在传递数据的时候不必整体提交);<br> （4）减轻服务器和带宽的负担(将服务器的一些操作转移到客户端);</p><p><strong><code>Ajax 的不足</code></strong></p><p> （1）不同版本的浏览器度XMLHttpRequest 对象支持度不同(比如IE5之前);<br> （2）前进、后退的功能被破坏;<br> （3）搜索引擎的支持度不够(引擎爬虫还不能理解JS引起变化数据的内容);<br> （4）开发调试工具缺乏</p><h4 id="1-2-Ajax发送GET请求"><a href="#1-2-Ajax发送GET请求" class="headerlink" title="1.2 Ajax发送GET请求"></a>1.2 Ajax发送GET请求</h4><p><strong><code>① 使用Ajax发送GET请求的基本步骤</code></strong></p><p>01 创建请求对象（XMLHTTPRequest<br>02 设置请求对象（open）请求方式为GET<br>03 发送请求（send）<br>04 监听请求的状态（onreadystatechange）<br>05 处理请求结果</p><p><strong><code>② 使用Ajax发送GET请求的注意点</code></strong></p><p><strong>兼容性问题</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//javascript创建请求对象的兼容性处理：</span></div><div class="line"><span class="keyword">if</span>（<span class="built_in">window</span>.XMLHTTPRequest）</div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHTTPRequest();</div><div class="line">&#125;<span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>缓存问题</strong></p><p>问题说明：在IE浏览器中如果发送的是GET请求，只要URL没有发生变化，那么IE浏览器就会认为网页的内容也没有发生变化，因此会优先使用缓存数据。<br>解决方式：如果在IE浏览器中想让数据实时更新（获取到最新的数据），那么<code>可以让每次请求的URL都不一样（即每次请求的URL地址不一样）</code>。</p><p>具体思路：在开发中可以使用<code>随机数因子</code>或者是<code>时间戳</code>来添加一个额外的参数给url路径。</p><ul><li>获取时间戳：var date = new Date();date.valueOf()</li><li>获取随机数因子 Math.radom()</li></ul><p>补充说明</p><p>① 加随机数或者是时间戳的目的在于让每次请求的时候url的内容都不一样<br>② 参数变化的作用就是让每次发送网络请求的时候URL都不相同，以让服务器总是把最新的数据返回。</p><p><strong>监听请求状态</strong></p><p>onreadystatechange的几种状态</p><p>（1）请求未初始化 - 0<br>（2）服务器连接已经建立 - 1<br>（3）请求已经接收 -2<br>（4）请求处理中 -3<br>（5）请求已经完成，且响应已经就绪 -4</p><p><strong>判断请求结果</strong></p><p>网络请求发送之后，可能成功，也可能失败。在代码中，我们可以通过响应状态码来判断请求成功还是失败，并最终做出相应的处理。</p><p>（1）当请求完成的时候再进行处理，readyState == 4<br>（2）通过响应码判断请求成功还是失败，status == 200<br>（3）请求成功解析服务器返回的响应体：response.Text</p><p><strong>请求超时</strong></p><p>在开发中可能需要对请求的时间进行限制，例如要求设置网络请求的超时时间为10秒，如果超过了该时间那么就提示用户检查网络。</p><p>在具体的代码实现中，该需求可以使用定时器配合abort方法来实现。</p><p><strong>中文转码</strong><br>在发送GET请求的时候，如果请求路径中存在中文，那么在发送网络请求之前应该先对请求路径进行中文转码处理，使用<code>encodeURI</code>方法来完成。</p><p><strong><code>③ 使用Ajax发送GET请求的代码示例</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数据处理方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">json2str</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</div><div class="line">        arr.push(key+<span class="string">"="</span>+data[key]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 不能直接将中文提交给服务器, 中文需要编码之后再提交</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">encodeURI</span>(arr.join(<span class="string">"&amp;"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 发送请求方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">url, data,timeout,success, error</span>) </span>&#123;</div><div class="line">    <span class="comment">// 0.对参数进行处理</span></div><div class="line">    <span class="keyword">var</span> res = json2str(data);</div><div class="line"></div><div class="line"><span class="comment">// 1.创建异步对象</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2.设置URL</span></div><div class="line">xhr.open(<span class="string">"get"</span>, url+<span class="string">"?"</span>+res, <span class="literal">true</span>);</div><div class="line"><span class="comment">// 3.发送请求</span></div><div class="line">xhr.send();</div><div class="line"><span class="comment">// 4.监听状态</span></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 5.处理返回结果</span></div><div class="line">    <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</div><div class="line">        <span class="comment">// 清空定时器</span></div><div class="line">        clearTimeout(timer);</div><div class="line">        <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</div><div class="line">            success(xhr.responseText);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            error(xhr.status);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 6.对超时时间处理</span></div><div class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="string">"超时了"</span>);</div><div class="line">    <span class="comment">// 中断请求</span></div><div class="line">    xhr.abort();</div><div class="line">&#125;, timeout);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="1-3-Ajax发送POST请求"><a href="#1-3-Ajax发送POST请求" class="headerlink" title="1.3 Ajax发送POST请求"></a>1.3 Ajax发送POST请求</h4><p><strong><code>① 使用Ajax发送POST请求的基本步骤</code></strong></p><p>01 创建请求对象（XMLHTTPRequest）<br>02 设置请求对象（open）请求方式为POST<br>03 设置请求头信息 </p><ul><li>xhr.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);</li></ul><p>04 发送请求（send），参数以查询字符串的方式传递<br>05 监听请求的状态（onreadystatechange）<br>06 处理请求结果</p><p><strong><code>② 使用Ajax发送POST请求的代码示例</code></strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">   <span class="comment">//001 创建请求对象</span></div><div class="line">    <span class="keyword">var</span> xhr;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)</div><div class="line">    &#123;</div><div class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//02 设置请求方法和请求路径</span></div><div class="line">    xhr.open(<span class="string">"post"</span>,<span class="string">"php/04-post.php"</span>,<span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">//++ 设置请求头信息</span></div><div class="line">    xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">    <span class="comment">//03 发送请求</span></div><div class="line">    <span class="comment">//++ 把提交的参数存放在请求体中提交</span></div><div class="line">    xhr.send(<span class="string">"username=zs&amp;password=123"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//04 监听网络请求的状态</span></div><div class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">//05 解析服务器返回的数据</span></div><div class="line">            <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"请求成功"</span> + xhr.responseText);</div><div class="line">            &#125;<span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"请求失败"</span> + xhr.status);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-Ajax技术简单介绍&quot;&gt;&lt;a href=&quot;#1-1-Ajax技术简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 Ajax技术简单介绍&quot;&gt;&lt;/a&gt;1.1 Ajax技术简单介绍&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Ajax是一门异步的用于发送网络请求的技术。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;全称为：Async javascript and XML。&lt;/p&gt;
&lt;p&gt;简单说明：Ajax 这个概念是由 Jesse James Garrett 在 2005 年发明的。它本身不是单一技术，是一串技术的集合。&lt;/p&gt;
&lt;p&gt;技术特点：通常情况下，每次提交表单的时候，都会刷新整个界面，而使用ajax发送请求可以实现异步发送请求获取数据而不需要刷新整个页面。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络编程" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 网络基础知识和HTTP协议</title>
    <link href="https://weibo.com/u/3800117445/2018/01/17/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>https://weibo.com/u/3800117445/2018/01/17/网络基础知识和HTTP协议/</id>
    <published>2018-01-17T09:05:29.000Z</published>
    <updated>2018-04-16T11:23:45.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-网络编程基本概念"><a href="#第一章-网络编程基本概念" class="headerlink" title="第一章 网络编程基本概念"></a>第一章 网络编程基本概念</h3><h4 id="1-1-客户端和服务器的基本概念"><a href="#1-1-客户端和服务器的基本概念" class="headerlink" title="1.1 客户端和服务器的基本概念"></a>1.1 客户端和服务器的基本概念</h4><p><code>客户端（Client）</code>能从服务器获取资源为客户提供服务的程序(设备)。<br><code>服务器（Server）</code>为客户端提供服务、提供数据、提供资源的机器。</p><p>说明：我们作为前端开发工程师，主要的精力都放在前端开发部分。</p><a id="more"></a><h4 id="1-2-服务器简单介绍"><a href="#1-2-服务器简单介绍" class="headerlink" title="1.2 服务器简单介绍"></a>1.2 服务器简单介绍</h4><h5 id="1-2-1-服务器简单说明"><a href="#1-2-1-服务器简单说明" class="headerlink" title="1.2.1 服务器简单说明"></a>1.2.1 服务器简单说明</h5><p>服务器其实本身也是电脑，只不过比我们的电脑配置更高，且一般要求24小时不断电，不关机。服务器是专门用于存储数据电脑， 访问者可以访问服务器获得服务器上存储的资源。</p><p>服务器其实就是一台”提供了某种服务功能”的电脑。</p><p><strong>思考</strong> 普通电脑如何能作为服务器使用？</p><h5 id="1-2-2-HTTP服务器"><a href="#1-2-2-HTTP服务器" class="headerlink" title="1.2.2 HTTP服务器"></a>1.2.2 HTTP服务器</h5><p>（1）<code>如何让电脑可以聊天?听歌?浏览网页?</code></p><p>【1】 想让电脑提供聊天服务, 可以安装相应的<strong>聊天软件</strong>，比如QQ、微信等</p><p>【2】 想让电脑可以提供听歌服务, 可以安装相应<strong>音乐播放软件</strong>，比如QQ音乐、网易云音乐等。</p><p>【3】 想让电脑可以提供浏览网页服务, 可以安装相应<strong>浏览网页软件</strong>，比如谷歌浏览器、IE浏览器等。</p><p>（2）<code>如何让电脑提供HTTP服务？</code></p><p>服务器有很多种类型和分类方式，如果按照类型来划分大概可以分成：<br><strong>文件服务器、数据库服务器、邮件服务器、Web 服务器</strong>等多种，我们经常接触到的是web服务器，也称为HTTP服务器；</p><p>如果想让电脑为我们提供HTTP服务，那么可以安装HTTP服务相关软件, 例如: Apache、IIS、Tomcat、Nginx、NodeJS等；</p><p>安装了HTTP服务软件的电脑, 我们称之<code>HTTP服务器(Web服务器)</code>。</p><p><code>补充</code>：常见的服务器软件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">文件服务器软件（Server-U、FileZilla、VsFTP等）；</div><div class="line">数据库服务器软件（Oracle、MySQL、PostgreSQL、MSSQL等）；</div><div class="line">邮件服务器软件（Postfix、Sendmail等）；</div><div class="line">HTTP 服务器软件（Apache、IIS、Tomcat、Nginx、NodeJS等）；</div></pre></td></tr></table></figure></p><h5 id="1-2-3-本地服务器和外网服务器"><a href="#1-2-3-本地服务器和外网服务器" class="headerlink" title="1.2.3 本地服务器和外网服务器"></a>1.2.3 本地服务器和外网服务器</h5><p>如果按照软件开发阶段来分，服务器可以分为远程服务器和本地服务器。</p><p>【1】 <strong>远程服务器</strong><br>        别名：外网服务器、正式服务器<br>        使用阶段：应用上线后使用的服务器<br>        使用人群：供全体用户使用<br>        速度：取决于服务器的性能、用户的网速</p><p>【2】 <strong>本地服务器</strong><br>        别名：内网服务器、测试服务器<br>        使用阶段：应用处于开发、测试阶段使用的服务器<br>        使用人群：仅供公司内部的开发人员、测试人员使用<br>        速度：由于是局域网，所以速度飞快，有助于提高开发测试效率</p><h4 id="1-3-访问网页的原理和过程。"><a href="#1-3-访问网页的原理和过程。" class="headerlink" title="1.3 访问网页的原理和过程。"></a>1.3 访问网页的原理和过程。</h4><p><code>Web的内容都是存储在Web服务器上面的。而Web服务器通常所使用的是HTTP协议，因此Web服务器有时也被称为“HTTP服务器”。客户端和Web服务器之间进行通信需要经历请求和响应两个过程。简单说，就是客户端向服务器发送一个请求索要数据，而服务器端需要对该请求作出响应，即把客户端索要的资源（数据）返回。</code></p><h5 id="1-3-1-浏览器访问网页原理"><a href="#1-3-1-浏览器访问网页原理" class="headerlink" title="1.3.1 浏览器访问网页原理"></a>1.3.1 浏览器访问网页原理</h5><p>【1】访问网页时是有真实的、物理的文件传输的。<br>【2】 网页不是一个文件，而是一堆文件组成，它们保存到Web服务器上。<br>【3】 客户端会先发送网络请求，向服务器端索要对应的文件。<br>【4】 服务器接收到请求后，根据请求查找对应的资源并传输给客户端。<br>【5】 客户端接收到响应后，会解析服务器返回的结果，将结果显示出来。</p><h5 id="1-3-2-浏览器请求数据的过程"><a href="#1-3-2-浏览器请求数据的过程" class="headerlink" title="1.3.2 浏览器请求数据的过程"></a>1.3.2 浏览器请求数据的过程</h5><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-01.png" width="400"></p><p>【1】 按下回车时浏览器根据输入的URL地址发送请求报文给服务器。<br>【2】 服务器接收到请求报文，会对请求报文进行处理。<br>【3】 服务器将处理完的结果通过响应报文返回给浏览器。<br>【4】浏览器解析服务器返回的结果，将结果显示出来。</p><hr><h3 id="第二章-HTTP协议"><a href="#第二章-HTTP协议" class="headerlink" title="第二章 HTTP协议"></a>第二章 HTTP协议</h3><h4 id="2-1-URL简单介绍"><a href="#2-1-URL简单介绍" class="headerlink" title="2.1 URL简单介绍"></a>2.1 URL简单介绍</h4><h5 id="2-1-1-客户端如何找到对应的服务器"><a href="#2-1-1-客户端如何找到对应的服务器" class="headerlink" title="2.1.1 客户端如何找到对应的服务器"></a>2.1.1 客户端如何找到对应的服务器</h5><p>网络中部署着各种各样的服务器，比如腾讯的服务器、百度的服务器，那么问题来了？<br><code>客户端如何找到想要连接的服务器?</code><br>答案是：<code>客户端通过URL找到想要连接的服务器。</code></p><h5 id="2-1-2-URI和URL"><a href="#2-1-2-URI和URL" class="headerlink" title="2.1.2 URI和URL"></a>2.1.2 URI和URL</h5><p><code>URI</code>：全称是Uniform Resource Identifier（统一资源标识符），用于标识某一互联网资源。</p><p><code>URL</code>：全称是Uniform Resource Location（统一资源定位符），用于表示资源的地点。通过1个URL，能找到互联网上唯一的1个资源，URL就是资源的地址、位置，互联网上的每个资源都有一个唯一的URL。</p><p><code>URN</code>:全称是Uniform Resource Name（统一资源名称），唯一标识一个实体的标识符，但是不能给出实体的位置。</p><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-03.png"></p><p><code>URL和URI的关系</code>：URL是URI的子集。</p><h5 id="2-1-3-URL的基本格式"><a href="#2-1-3-URL的基本格式" class="headerlink" title="2.1.3 URL的基本格式"></a>2.1.3 URL的基本格式</h5><p>URL的基本格式为： <code>协议://主机地址/资源路径</code></p><p>示例1：<a href="http://www.baidu.com/img/logo.png" target="_blank" rel="external">http://www.baidu.com/img/logo.png</a><br>示例2：<a href="http://202.108.22.5/img/bdlogo.gif" target="_blank" rel="external">http://202.108.22.5/img/bdlogo.gif</a></p><ul><li><strong>协议</strong>：不同的协议，代表着不同的资源查找方式、资源传输方式。</li><li><strong>主机地址</strong>：存放资源的主机（服务器）的IP地址（域名）。</li><li><strong>资源路径</strong>：资源在主机（服务器）中的具体位置。</li></ul><p>🌧 <strong>补充</strong><br>① 通用格式<code>协议://用户名:密码@主机地址:端口号/路径?查询字符串#资源片段</code><br>② 常见协议：</p><p>（1）<code>HTTP协议</code>访问的是远程的网络资源,网络开发中最常用的协议<br>（2）<code>file协议</code>访问的是本地计算机上的资源。<br>（3）<code>mailto协议</code>访问的是电子邮件地址。<br>（4）<code>FTP协议</code>访问的是共享主机的文件资源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">URL常见协议示例：</div><div class="line">http:<span class="comment">//www.baidu.com</span></div><div class="line">file:<span class="comment">//localhost/c:/path/fileName.png</span></div><div class="line">mailto:tone@glasscom.com</div></pre></td></tr></table></figure></p><h4 id="2-2-HTTP协议简单介绍"><a href="#2-2-HTTP协议简单介绍" class="headerlink" title="2.2 HTTP协议简单介绍"></a>2.2 HTTP协议简单介绍</h4><h5 id="2-2-1-协议就是规则"><a href="#2-2-1-协议就是规则" class="headerlink" title="2.2.1 协议就是规则"></a>2.2.1 协议就是规则</h5><p>在网络编程领域我们可能会用到各种不一样的协议，但<code>所有的协议本质上都是规则</code>。</p><p><strong>TCP/IP协议簇</strong></p><p>为了方便我们学习和理解HTTP协议，这里先介绍TCP/IP协议簇。<br>通常意义上，我们使用的网络服务是在TCP/IP协议簇的基础上运作的，而HTTP协议属于它内部的一个子集。</p><p>计算机与网络设备需要通信，双方就必须要基于相同的方法，比如具体应该如何探测通信目标，由哪一方面发起通信，使用什么语言进行沟通等等，所有的这一切都需要规则。<code>我们则把这些规则称之为协议（potocol）</code>。</p><p>在协议中规定了很多的各式各样的内容，如选址方法，双方建立通信的顺序等。这些协议如（ICMP DNS TCP FTP HTTP SNMP PPPoE IP FDDI）等，通常我们把TCP/IP认为是在IP协议的通信过程中，使用到的协议簇的统称。</p><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-04.png"></p><p>TCP 协议簇采用分层设计思想实现，其中，与HTTP关系密切的协议有TCP、IP、DNS等协议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">IP协议</div><div class="line">按照层次划分，IP网际协议位于网络层。IP协议的作用就是把各种数据包传送给对象。</div><div class="line"></div><div class="line">TCP协议</div><div class="line">按照层次划分，TCP协议位于传输层,提供了可靠的字节流服务。字节流服务指, 为了方便传输把大块的数据分割成以报文段为单位的数据包进行管理。并且TCP协议能够确认数据最终是否已经送达到对方。</div><div class="line"></div><div class="line">三次握手</div><div class="line">为了准确无误的将数据送到目的地，TCP采用了三次握手的策略。握手过程中使用TCP的标志(flag)-SYN(synchronize)和ACK(acknownledgement)。发送端首先发送一个带SYN标志的数据包给对方。接收端接收到后，回传一个带 有SYN/ACK标志的数据包，以示传达确认信息。最终发送端再回传一个带ACK标志的数 据包,表示『握手』过程结束。</div><div class="line"></div><div class="line">DNS</div><div class="line">DNS服务和HTTP协议一样位于应用层，它提供域名到IP地址之间的解析服务。</div></pre></td></tr></table></figure></p><h5 id="2-2-2-HTTP协议简单介绍"><a href="#2-2-2-HTTP协议简单介绍" class="headerlink" title="2.2.2 HTTP协议简单介绍"></a>2.2.2 HTTP协议简单介绍</h5><p>HTTP的全称是Hypertext Transfer Protocol，即<code>超文本传输协议</code>。客户端在访问网络资源的时候，经常需要用到HTTP协议。</p><p>比如访问公司的主页，获取网易新闻数据，获取优酷的视频数据等都需要用到HTTP协议。</p><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-05.png"></p><p><strong><code>HTTP协议的作用</code></strong></p><p>① 规定客户端和服务器之间的数据传输格式<br>② 让客户端和服务器能有效地进行数据沟通</p><p><strong><code>HTTP协议的特点</code></strong></p><p>① 简单快速<br>因为HTTP协议简单，所以HTTP服务器的程序规模小，而且通信速度很快。</p><p>② 方便灵活<br>HTTP协议允许传输各种各样的数据，视频|音频|文本|图片等。</p><p>③ 明文传输<br>HTTP协议在进行请求和响应的时候数据以明文方式传输。</p><h4 id="2-3-HTTP协议的版本发展"><a href="#2-3-HTTP协议的版本发展" class="headerlink" title="2.3 HTTP协议的版本发展"></a>2.3 HTTP协议的版本发展</h4><p><strong>① HTTP协议 0.9版本</strong></p><p><code>HTTP协议0.9版本</code> 于1990年问世，那时的HTTP并没有作为正式的标准被建立。1991年 Tim Berners-Lee概述了该协议的动机，并罗列了几条宏观的涉及目标，如支持文件传输，能够请求对超文本文档的索引搜索，格式化协商机制以及能够把客户端引导 至不同的服务器等，他构建了简单原型并实现了部分功能。因为最终的成品只实现了部分预期的功能,因此相应的协议也被非官方的成为HTTP0.9。以1991年为起点，HTTP协议在随后的几年中得到了快速的发展。</p><p><code>HTTP0.9的主要功能和特点</code></p><ul><li>客户端|服务端,请求|响应协议;</li><li>ASCII协议,运行于TCP/IP链接之上;</li><li>涉及用来传输超文本文档(HTML) ;</li><li>服务器和客户端之间的连接在每次请求之后都会关闭。</li></ul><p><strong>② HTTP协议 1.0版本</strong></p><p>1996年，HTTP工作组发布了RFC 1945，解释和说明了当时很多HTTP1.0实现的 公共用法。不过,该RFC是参考性的，也就是说HTTP1.0 并不是一个正式的规范或者是互联网标准。</p><p>RFC1945 - Hypertext Transfer Protocol — HTTP/1.0<br><a href="http://www.ietf.org/rfc/rfc1945.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc1945.txt</a></p><p>HTTP协议1.0版本后，服务器的响应对象不再局限与超文本而可以是任意类型：如HTML文件、纯文本文件，图片等。</p><p><code>HTTP1.0 协议的关键变化</code></p><ul><li>请求可以由多行首部组成; </li><li>响应对象前面添加了响应状态行;</li><li>响应对象也拥有了自己的首部字段 ;</li><li>响应对象不再局限于超文本</li><li>服务器与客户端之间的连接在每次请求之后都会关闭。</li></ul><p><strong>③ HTTP协议 1.1版本</strong></p><p>1997年1月，定义了<code>HTTP协议1.1版本</code>标准的RFC 2068发布。在1999年6月RFC2626发布, 又在标准中集合了很多的更新和改进。HTTP/1.1标准厘清了之前版本中很多有歧义的地方，且加入了很多重要的性能优化：如持久连接，分块编码传输，字节范围请求，增强的缓存机制，传输编码以及请求管道等。</p><p>RFC2616 - Hypertext Transfer Protocol — HTTP/1.1<br><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">http://www.ietf.org/rfc/rfc2616.txt</a></p><p>HTTP/1.1 最关键的变化在于<code>改变了HTTP协议的语义,默认使用持久连接，该版本是目前广泛使用的版本。</code></p><p><strong>④ HTTP协议 2.0版本</strong></p><p>RFC2626自发布以来，一直都是互联网大发展的基石。从最开始的HTTP0.9到今天，HTTP已经发展成为可以在任何领域使用的核心协议。今天，用户和开发者都迫切想通过HTTP协议来实现几乎实时的响应速度和传输性能，而要满足这样的需求仅仅对既有的HTTP1.1协议进行修补和更新是不够的。 因此，HTTP工作组于2012年宣布开发HTTP2.0 。</p><p>HTTP2.0版本的开发保证了与 HTTP 1.1 的完全语义兼 容,最初考虑的是 Google SPDY 协议、微软的 SM 协议和 Network-Friendly HTTP 更新。最终各方推荐了 SPDY 协议，并在此基础上进行了相应更新。对于HTTP2.0 而言，其主要目标是改进传输性能,实现低延迟和高吞吐量。</p><p>官方设置的重要里程碑:<br>2012年3月：征集HTTP2.0建议;<br>2012年9月：HTTP2.0 的第一个草案发布;<br>2013年7月：HTTP2.0 草案的第一个实现发布;<br>2014年4月：工作组最后征集HTTP2.0 的意见;<br>2014年11月：将HTTP2.0作为建议标准提交给IESG。</p><p><strong>备注</strong><br>HTTP2.0最新草案和状态，请参考<br><a href="https://tools.ietf.org/html/draft-ietf-httpbis-http2-17" target="_blank" rel="external">https://tools.ietf.org/html/draft-ietf-httpbis-http2-17</a><br>HTTP2.0 中文版本,请参考<br><a href="http://www.oschina.net/question/1397765_172789" target="_blank" rel="external">http://www.oschina.net/question/1397765_172789</a></p><p><code>HTTP2.0 关键设计和技术目标</code></p><ul><li>请求优先级；</li><li>服务器推送；</li><li>首部压缩；</li><li>二进制分帧层</li><li>多向请求和响应；</li></ul><hr><h3 id="第三章-请求-响应模式"><a href="#第三章-请求-响应模式" class="headerlink" title="第三章 请求-响应模式"></a>第三章 请求-响应模式</h3><h4 id="3-1-网络通信的请求-响应模式"><a href="#3-1-网络通信的请求-响应模式" class="headerlink" title="3.1 网络通信的请求-响应模式"></a>3.1 网络通信的请求-响应模式</h4><p><strong><code>完整的http通信可以分为两个部分：请求和响应。</code></strong></p><p><code>请求</code>：客户端向服务器索要数据的过程。<br><code>响应</code>：服务器把客户端索要数据返回的过程。</p><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-06.png"></p><p>网络通信过程中数据包的传输过程请参考下图<br><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-07.png"></p><h4 id="3-2-HTTP报文简单介绍"><a href="#3-2-HTTP报文简单介绍" class="headerlink" title="3.2 HTTP报文简单介绍"></a>3.2 HTTP报文简单介绍</h4><h5 id="3-2-1-HTTP报文的结构"><a href="#3-2-1-HTTP报文的结构" class="headerlink" title="3.2.1 HTTP报文的结构"></a>3.2.1 HTTP报文的结构</h5><p><strong><code>HTTP报文由两部分组成：报文首部和报文主体。</code></strong><br><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-08.png"></p><p>基于HTTP通信的请求-响应模式，我们又可以把HTTP报文区分为请求报文和响应报文，它们本身的结构和HTTP报文结构一致。</p><h5 id="3-2-2-请求报文"><a href="#3-2-2-请求报文" class="headerlink" title="3.2.2 请求报文"></a>3.2.2 请求报文</h5><p><strong><code>HTTP请求报文由两部分组成：请求首部（请求行 + 请求头）和请求主体。</code></strong></p><p><code>请求行</code>：表明请求的方法和资源等信息。<br><code>请求头</code>：存放的是对客户端以及请求本身的描述信息。<br><code>请求体</code>：如果是POST请求，则存放发送给服务器的参数。</p><p>请求头信息示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">User-Agent：浏览器的具体类型　　</div><div class="line">Accept：浏览器支持哪些数据类型　　</div><div class="line">Accept-Charset：浏览器采用的是哪种编码　</div><div class="line">Accept-Encoding：浏览器支持解码的数据压缩格式　　如： gzip</div><div class="line">Accept-Language：浏览器的语言环境</div><div class="line">Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</div><div class="line">Connection：表示是否需要持久连接。。如 Keep-Alive</div><div class="line">Content-Length：表示请求消息正文的长度。</div><div class="line">Content-Type：WEB服务器告诉浏览器自己响应的对象的类型和字符集。</div><div class="line">Content-Encoding：WEB服务器表明自己使用了什么压缩方法。</div><div class="line">Content-Language：WEB服务器告诉浏览器自己响应的对象的语言。</div><div class="line">Cookie：浏览器每次都会将cookie发送到服务器上，允许服务器在客户端存储少量数据。</div><div class="line">Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。服务器能知道你是从哪个页面过来的。</div></pre></td></tr></table></figure><h5 id="3-2-3-响应报文"><a href="#3-2-3-响应报文" class="headerlink" title="3.2.3 响应报文"></a>3.2.3 响应报文</h5><p><strong><code>HTTP响应报文由两部分组成：响应首部（状态行 + 响应头）和响应主体。</code></strong></p><p><code>状态行</code>：表明网络请求的状态。<br><code>响应头</code>：存放的是对服务器以及响应本身的描述信息。<br><code>响应体</code>：返回给客户端的具体数据。</p><p>响应头信息示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Server:服务器软件的信息和版本。</div><div class="line">Accept-Ranges:服务器表明是否接受获取其某个实体的一部分的请求。</div><div class="line">Content-Type:返回的响应体的数据类型。</div><div class="line">Allow:服务器支持哪些请求方法（如GET、POST等）</div><div class="line">Content-Base:解析主体中的相对URL时使用的基础URL。</div><div class="line">Content-Encoding:对响应体数据采用的压缩方式。</div><div class="line">Content-Language:告诉浏览器理解主体时最适宜使用的自然语言。</div><div class="line">Content-Length:表明响应体的大小，例如<span class="number">26012</span></div><div class="line">Content-Location:资源实际所处的位置。</div><div class="line">Content-MD5:主体的MD5校验和。</div><div class="line">Content-Range:表示传送的范围。</div><div class="line">Expires:过期相关信息。</div><div class="line">Last-Modified:WEB服务器认为对象的最后修改时间。</div></pre></td></tr></table></figure></p><h4 id="3-3-网络请求方法"><a href="#3-3-网络请求方法" class="headerlink" title="3.3 网络请求方法"></a>3.3 网络请求方法</h4><h5 id="3-3-1-网络请求方法介绍"><a href="#3-3-1-网络请求方法介绍" class="headerlink" title="3.3.1 网络请求方法介绍"></a>3.3.1 网络请求方法介绍</h5><p>在HTTP/1.1协议中，定义了多种发送http请求的方法，分别是：GET、POST、OPTIONS、HEAD、PUT、DELETE、TRACE、CONNECT、PATCH。</p><p>根据HTTP协议的设计初衷，不同的方法对资源有不同的操作方式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET方法：查询数据</div><div class="line">PUT方法 ：增加数据</div><div class="line">POST方法：修改数据</div><div class="line">DELETE方法：删除数据</div></pre></td></tr></table></figure></p><p>在实际的项目开发中，最常用的是<code>GET和POST请求</code>，其实实际上GET和POST都能办到增删改查。</p><p><strong>参数的概念</strong>：参数就是传递给服务器的具体数据，如登录的帐号和密码</p><h5 id="3-3-2-GET请求和POST请求"><a href="#3-3-2-GET请求和POST请求" class="headerlink" title="3.3.2 GET请求和POST请求"></a>3.3.2 GET请求和POST请求</h5><p><strong><code>GET和POST的主要区别表现在参数的处理方式不同</code></strong></p><p><code>GET请求</code>：提交的参数直接以查询字符串的方式跟在请求URL的后面。<br><code>POST请求</code>：参数存放在请求体中进行提交。</p><p><strong>GET请求和POST请求对比</strong></p><p>① 参数处理方式不同。<br>② 安全性不同。<br>③ 大小限制。</p><p>请求路径示例：<br>    <code>GET:http://www.wendingding.com?username=wen&amp;password=123456</code><br>    <code>POST:http://www.wendingding.com</code></p><h4 id="3-4-响应状态码"><a href="#3-4-响应状态码" class="headerlink" title="3.4 响应状态码"></a>3.4 响应状态码</h4><h5 id="3-4-1-HTTP响应状态码介绍"><a href="#3-4-1-HTTP响应状态码介绍" class="headerlink" title="3.4.1 HTTP响应状态码介绍"></a>3.4.1 HTTP响应状态码介绍</h5><p><code>响应状态码</code>的职责是当客户端向服务器端发送请求时,描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p><p><code>常见的状态码比如200 OK 或者404 not found等。</code></p><p>状态码以<code>3位数字+原因短语</code>组成。<br>数字中的第一位指定了响应的类别, 后两位无分类。</p><h5 id="3-4-2-HTTP响应状态码的类别"><a href="#3-4-2-HTTP响应状态码的类别" class="headerlink" title="3.4.2 HTTP响应状态码的类别"></a>3.4.2 HTTP响应状态码的类别</h5><p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/http-09.png"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章-网络编程基本概念&quot;&gt;&lt;a href=&quot;#第一章-网络编程基本概念&quot; class=&quot;headerlink&quot; title=&quot;第一章 网络编程基本概念&quot;&gt;&lt;/a&gt;第一章 网络编程基本概念&lt;/h3&gt;&lt;h4 id=&quot;1-1-客户端和服务器的基本概念&quot;&gt;&lt;a href=&quot;#1-1-客户端和服务器的基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 客户端和服务器的基本概念&quot;&gt;&lt;/a&gt;1.1 客户端和服务器的基本概念&lt;/h4&gt;&lt;p&gt;&lt;code&gt;客户端（Client）&lt;/code&gt;能从服务器获取资源为客户提供服务的程序(设备)。&lt;br&gt;&lt;code&gt;服务器（Server）&lt;/code&gt;为客户端提供服务、提供数据、提供资源的机器。&lt;/p&gt;
&lt;p&gt;说明：我们作为前端开发工程师，主要的精力都放在前端开发部分。&lt;/p&gt;
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="网络编程" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编程语言系列 PHP基础语法（初级）</title>
    <link href="https://weibo.com/u/3800117445/2018/01/02/PHP%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/"/>
    <id>https://weibo.com/u/3800117445/2018/01/02/PHP基础语法（初级）/</id>
    <published>2018-01-02T09:07:55.000Z</published>
    <updated>2018-04-16T11:23:45.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-PHP简单介绍"><a href="#第一章-PHP简单介绍" class="headerlink" title="第一章 PHP简单介绍"></a>第一章 PHP简单介绍</h3><h4 id="1-1-PHP和它的应用领域"><a href="#1-1-PHP和它的应用领域" class="headerlink" title="1.1 PHP和它的应用领域"></a>1.1 PHP和它的应用领域</h4><p><strong>简单介绍</strong></p><p><code>PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）</code>，是一种开源的多用途脚本语言，可以直接嵌入到 HTML中，尤其适合 web 开发。<br><a id="more"></a><br><strong>吉祥物（elePHPant）</strong><br><img src="https://github.com/flowerField/Source/blob/master/Blog/php.png?raw=true"></p><p><strong>PHP主要应用在以下三个领域：</strong></p><p>（1）服务器端编程，PHP设计的初衷是用于创建动态的web内容。<br>（2）命令行编程<br>（3）客户端图形界面编程</p><p><strong>PHP的其他说明：</strong></p><ul><li>PHP可以运行在所有主流的操作系统上（Linux、Unix、window、OSX）。</li><li>PHP语言非常灵活，几乎可以生成任何形式的文件。</li><li>PHP支持所有主流的数据库（MySQL、Oracle、Sybase、SQLite等）</li></ul><h4 id="1-2-PHP的版本发展"><a href="#1-2-PHP的版本发展" class="headerlink" title="1.2 PHP的版本发展"></a>1.2 PHP的版本发展</h4><p>1994 年 Rasmus Lerdorf(勒多夫) 设计了第一版本的PHP，并于1995年发布。<br>1997 年 11 月PHP 2.0 官方版本正式发布。<br>1998 年 06 月PHP 3.0 官方版本正式发布，Andi Gutmans 和 Zeev Suraski参与并重写了底层的解析器引擎，拥有了强大的可扩展性。<br>2000 年 05 月PHP 4.0 官方版本正式发布。<br>2004 年 07 月PHP 5.0 官方版本正式发布，使用Zend2代引擎并引入了新的对象模型和大量新功能。<br>2015年 12 月PHP 7.0 官方版本正式发布。<br>2017年 11 月发布的PHP 7.2.0是最新版本 。<br><code>PS</code>: 目前PHP官方对5.6之前的版本已经停止维护，之前的很多方法已经被废弃（不推荐使用），另外6.X版本从未正式发布。</p><h4 id="1-3-PHP相关参考资料"><a href="#1-3-PHP相关参考资料" class="headerlink" title="1.3 PHP相关参考资料"></a>1.3 PHP相关参考资料</h4><p>官方网站：<a href="https://secure.php.net/" target="_blank" rel="external">https://secure.php.net/</a><br>安装配置：<a href="http://php.net/manual/zh/install.php" target="_blank" rel="external">http://php.net/manual/zh/install.php</a><br>中文手册：<a href="http://php.net/manual/zh/index.php" target="_blank" rel="external">http://php.net/manual/zh/index.php</a><br>其他参考：<a href="http://www.w3school.com.cn/php/index.asp" target="_blank" rel="external">http://www.w3school.com.cn/php/index.asp</a></p><hr><h3 id="第二章-PHP语言基础"><a href="#第二章-PHP语言基础" class="headerlink" title="第二章 PHP语言基础"></a>第二章 PHP语言基础</h3><h4 id="2-1-PHP的词法结构"><a href="#2-1-PHP的词法结构" class="headerlink" title="2.1 PHP的词法结构"></a>2.1 PHP的词法结构</h4><p><code>该部分将主要从注释、语句、标识符等方面介绍PHP这门语言的词法结构。</code></p><p><strong>① 注释</strong></p><p>PHP语言提供了多种在代码中包含注释的方式，而这些风格都是从其他语言（C、C++、UNIX shell）借鉴的。</p><p>（1）可以使用哈希标记字符（#）来实现单行注释。<br>（2）可以使用C++风格的//来实现单行注释。<br>（3）可以使用C风格的/**/来实现多行注释。</p><p><strong>② 标识符</strong></p><p><code>标识符</code>：标识符即程序中变量、函数、常量和类的名称。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。</p><p><code>语句</code>：PHP使用分号来分隔简单的语句（除结束标签之前和代码块右大括号之后的分号可不写外，其他所有语句都需要使用分号结尾）。</p><p><code>大小写</code>：用户定义的类和函数、内置的结构以及关键字（ex:while class等）不区分大小写，而变量区分大小写。</p><p><code>变量|函数|类名</code></p><p>[1]变量名总是以一个美元符号（\$）开始并区分大小写。<br>    变量名示例：$a、$_int、$bill、$Bill等</p><p>[2]函数名不区分大小写，以下函数调用都指向相同的函数。<br>    相同的函数名示例：fn() FN() Fn() fN()</p><p>[3]PHP中的类名遵循标识符的基本准则且不区分大小写。</p><p><code>关键字</code>：关键字是语言为了核心功能而预留的单词，在对变量或者函数等命名的时候，不能使用和关键字相同的名字，下面列出PHP中的关键字。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">xor</span>           <span class="keyword">abstract</span>     <span class="keyword">and</span>    <span class="keyword">array</span>()  <span class="keyword">as</span></div><div class="line"><span class="keyword">break</span>      callable      <span class="keyword">case</span>    <span class="keyword">catch</span> <span class="class"><span class="keyword">class</span></span></div><div class="line"><span class="class"><span class="title">clone</span>      <span class="title">const</span>         <span class="title">continue</span>   <span class="title">declare</span> <span class="title">or</span></span></div><div class="line">die()      protected     echo    elseif   else</div><div class="line"><span class="keyword">enddeclare</span>    <span class="keyword">endforeach</span>     <span class="keyword">empty</span>()    <span class="keyword">endfor</span>   <span class="keyword">endif</span>      </div><div class="line"><span class="keyword">endswitch</span>  <span class="keyword">endwhile</span>       extends    <span class="keyword">eval</span>()<span class="keyword">exit</span>()</div><div class="line"><span class="keyword">final</span>      <span class="keyword">finally</span>     <span class="function"><span class="keyword">function</span>   <span class="title">foreach</span>  <span class="title">for</span>   </span></div><div class="line"><span class="function"><span class="title">global</span>      <span class="title">goto</span>          <span class="title">implements</span><span class="title">if</span>     <span class="title">include</span></span></div><div class="line"><span class="function"><span class="title">list</span><span class="params">()</span>      <span class="title">namespace</span>      <span class="title">new</span>        <span class="title">default</span> <span class="title">print</span></span></div><div class="line"><span class="function"><span class="title">return</span>      <span class="title">static</span>     <span class="title">switch</span>    <span class="title">throw</span> <span class="title">trait</span> </span></div><div class="line"><span class="function"><span class="title">try</span>          <span class="title">unset</span><span class="params">()</span>     <span class="title">interface</span>  <span class="title">use</span>   <span class="title">require</span></span></div><div class="line"><span class="function"><span class="title">yield</span>         <span class="title">while</span>          <span class="title">public</span>     <span class="title">var</span>    <span class="title">isset</span><span class="params">()</span>  </span></div><div class="line"><span class="function"><span class="title">private</span>       <span class="title">include_once</span>  <span class="title">instanceof</span> <span class="title">insteadof</span></span></div><div class="line"><span class="function"><span class="title">do</span> <span class="title">__halt_compiler</span><span class="params">()</span>        <span class="title">require_once</span></span></div></pre></td></tr></table></figure></p><h4 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h4><p><img src="https://github.com/flowerField/Source/blob/master/Blog/php-02.png?raw=true"></p><p>PHP本身提供了八种数据类型。其中有四种是标量型的，分别为：<code>整型</code>、<code>浮点数</code>、<code>字符串</code>和<code>布尔值</code>；两种是复合类型的，分别为<code>数组</code>和<code>对象</code>；还有两种特殊类型的，分别是<code>资源</code>和<code>NULL</code>。</p><p><strong>① 布尔类型 (Boolean)</strong></p><p><code>布尔类型</code>有两个值，分别是true和false，不区分大小写。可以通过boolean来把数值转换为布尔类型的值。另外，可以使用is_bool( )函数来测试一个值是否是布尔类型的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex: </span></div><div class="line">$bool = (boolean)<span class="number">10</span>;</div><div class="line">$bool = (bool)<span class="number">1</span>;</div><div class="line"><span class="keyword">echo</span> is_bool($bool);</div></pre></td></tr></table></figure><p>在PHP中，以下值的计算结果为false：</p><ul><li>关键字 false</li><li>整型值 0</li><li>浮点型值 0.0</li><li>空字符串(“”)，以及字符串 “0”</li><li>空数组</li><li>空对象</li><li>特殊类型 NULL</li></ul><p><strong>② 整型 (Integer)</strong></p><p><code>整型</code>即整数，可以是正数，也可以是负数。可接受的数值范围通常为：-2147483648到+2147483647，相当于C中的长数据类型范围。可以使用is_int( )函数来测试一个值是否是整型的。</p><p>整型字面量可以用十进制数、八进制数、二进制数或者是十六进制数表示。</p><p><code>八进制数</code>由一个0和一个从0~7的数字序列组成。<br><code>二进制数</code>以0b开始，接着由一个数字（0和1）序列组成。<br><code>十六进制数</code>以0x开头，接着是数字（0~9）或者是字母（A~F）的序列。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex:</span></div><div class="line">$n = <span class="number">100</span>;         <span class="comment"># 十进制数</span></div><div class="line">$n = <span class="number">-123</span>;        <span class="comment"># 负数</span></div><div class="line">$n = <span class="number">0123</span>;        <span class="comment"># 八进制数 (等于十进制 83)</span></div><div class="line">$n = <span class="number">0x1A</span>;        <span class="comment"># 十六进制数 (等于十进制 26)</span></div><div class="line">$n = <span class="number">0b11111111</span>;  <span class="comment"># 二进制数字 (等于十进制 255)</span></div></pre></td></tr></table></figure></p><p><strong>③ 浮点数 (Float)</strong></p><p><code>浮点数</code>，通常简称为实数，是由十进制表示的数值，也叫作双精度数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex:</span></div><div class="line">$n = <span class="number">1.234</span>;  </div><div class="line">$n = <span class="number">1.2e3</span>;   <span class="comment">#1.2乘以10的3次方</span></div><div class="line">$n = <span class="number">8E-3</span>;    <span class="comment">#0.008</span></div></pre></td></tr></table></figure></p><p><strong>备注</strong></p><p>（1）浮点数只是数的近似表示，在写代码的时候应该避免假定浮点数是完全精确的。应该避免直接使用==符号来比较两个浮点数，建议比较前几位。另外，可以使用is_float( )函数来测试一个值是否是浮点型的。</p><p>（2）某些数学运算会产生一个由常量 NAN 所代表的结果。NAN代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 TRUE）进行比较的结果都是 FALSE。</p><p><strong>④ 字符串 (String)</strong></p><p><code>字符串</code>是一个任意长度的字符序列，字符串字面量由单引号或双引号分隔。PHP对创建和处理字符串等功能提供了核心级的支持。</p><p>在双引号的字符串中变量会被解析，而在单引号的字符号中，它们不会被解析。另外，双引号支持多种字符串转义。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># ex:</span></div><div class="line">$str = <span class="string">'hello world'</span>;  <span class="comment">#单引号字符串  </span></div><div class="line">$str = <span class="string">"hello world"</span>;  <span class="comment">#双引号字符串</span></div><div class="line"></div><div class="line"><span class="comment"># 关于变量的解析</span></div><div class="line">$name = <span class="string">"wen_dingding"</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">"Hi , $name"</span>;     <span class="comment">#输出结果为：Hi , wen_dingding</span></div><div class="line"><span class="keyword">echo</span> <span class="string">'Hi , $name'</span>;     <span class="comment">#输出结果为：Hi , $name</span></div></pre></td></tr></table></figure></p><p>在代码中，可以通过<code>==</code>符号来比较判断两个字符串是否相等，还可以使用is_string( )函数来判断一个值是否是字符串。</p><p><strong>⑤  数组 (Array)</strong></p><p><code>数组</code>是一个有序映射，即有序的把 value关联到对应 key的一种结构。<br>在PHP中存在两种数组：<code>索引数组</code>和<code>关联数组</code>。</p><p><code>索引数组</code>的key(键名)是整数并且从0开始依次递增，如果您需要通过索引来访问数组的元素，那么建议使用索引数组。</p><p><code>关联数组</code>的key(键名)是字符串，类似于JavaScript语言中的对象。</p><p><strong>备注</strong></p><p>在PHP的内部，其实所有的数组都被存储为关联数组，关联数组和索引数组的唯一区别只在于key的类型。另外，数组中的key具有唯一性，在代码中可以使用is_array( )函数来测试一个值是否是数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex:</span></div><div class="line">$arr1 = <span class="keyword">array</span>(<span class="string">"wc"</span>,<span class="number">18</span>,<span class="string">"red"</span>);  <span class="comment">#索引数组 </span></div><div class="line">$arr2 = <span class="keyword">array</span>(<span class="string">"name"</span>=&gt;<span class="string">"wc"</span>,<span class="string">"age"</span>=&gt;<span class="number">18</span>);  <span class="comment">#关联数组</span></div><div class="line"></div><div class="line"><span class="comment"># 可以通过key来访问数组中的元素</span></div><div class="line"><span class="keyword">echo</span> $arr1[<span class="number">0</span>];           <span class="comment">//wc</span></div><div class="line"><span class="keyword">echo</span> $arr1[<span class="number">1</span>];           <span class="comment">//18</span></div><div class="line"><span class="keyword">echo</span> $arr2[<span class="string">"name"</span>];      <span class="comment">//wc</span></div></pre></td></tr></table></figure><p>  <strong>⑥  对象 (Object)</strong></p><p>PHP支持面向对象编程。PHP语言的面向对象编程基于类(class)的实现。<br>类是一种包含<code>属性（变量）和方法（函数）</code>的特殊结构，使用关键字class进行定义。</p><p>类被定义之后，可以使用关键字new来创建该类的任意数量的对象，通过-&gt;结构来访问属性和方法。另外，我们可以使用is_object( ) 函数来测试对象。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex:</span></div><div class="line"><span class="comment"># 001 定义Person类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"><span class="comment"># 定义类的属性</span></div><div class="line"><span class="keyword">public</span> $name = <span class="string">"wen_dingding"</span>;</div><div class="line"><span class="comment"># 定义类的方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">echo</span> <span class="string">"姓名："</span>.<span class="keyword">$this</span>-&gt;name;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">#002 创建对象并访问属性和方法</span></div><div class="line">$p = <span class="keyword">new</span> Person;</div><div class="line"><span class="keyword">echo</span> $p-&gt;name;  <span class="comment">//访问属性,打印wen_dingding</span></div><div class="line">$p-&gt;showName(); <span class="comment">//访问方法,打印姓名：wen_dingding</span></div></pre></td></tr></table></figure><p> <strong>⑦  资源类型 (Resource) 和NULL</strong></p><p><code>资源类型</code>是一种特殊变量，它保存了对外部资源的一个引用。资源类型通过专门的函数来建立和使用。</p><p><code>NULL</code>表示一个变量没有值。该类型存在一个唯一对应的值，即 null（<strong>不区分大小写</strong>）。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ex:</span></div><div class="line">$name = <span class="string">"wen_dingding"</span>;   <span class="comment">#字符串变量</span></div><div class="line">$name = <span class="keyword">Null</span>;             <span class="comment">#变量的值已经没有了。</span></div></pre></td></tr></table></figure><h4 id="2-3-变量和常量"><a href="#2-3-变量和常量" class="headerlink" title="2.3 变量和常量"></a>2.3 变量和常量</h4><p><strong>① 变量</strong></p><p>PHP中的变量使用美元符号（\$）来作为前缀标识。<br>变量可以存储任意类型的数据，且不需要显示的进行声明，在第一次被赋值的时候，变量被创建。如果直接使用一个没有赋值的变量，那么它的值为NULL。</p><p>另外，可以通过&amp;操作符获取<code>变量的引用</code>。赋值后，两个变量拥有相同的值，修改某个变量的值，另外一个变量的值也会随之改变。（<code>注意</code>:销毁某个变量的值，对另一个变量不会有影响。）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ex:</span></div><div class="line">$name = <span class="string">"zhangsan"</span>;  <span class="comment">//字符串变量，值为"zhangsan"</span></div><div class="line">$bool = <span class="keyword">true</span>:        <span class="comment">//布尔型变量</span></div><div class="line">$number = <span class="number">123</span>;       <span class="comment">//整型变量</span></div><div class="line">$test;               <span class="comment">//该变量的值为NULL</span></div><div class="line"><span class="comment"># 变量的引用</span></div><div class="line">$demo1 = <span class="string">"wen_dingding"</span>;</div><div class="line">$demo2 = &amp; $demo1;</div><div class="line"></div><div class="line"><span class="keyword">echo</span> $demo1        <span class="comment">//输出结果为：wen_dingding</span></div><div class="line"><span class="keyword">echo</span> $demo2        <span class="comment">//输出结果为：wen_dingding</span></div><div class="line"></div><div class="line"><span class="comment">#修改某个变量的值</span></div><div class="line">$demo1 = <span class="string">"jack"</span>;</div><div class="line"><span class="keyword">echo</span> $demo1        <span class="comment">//输出结果为：jack</span></div><div class="line"><span class="keyword">echo</span> $demo2        <span class="comment">//输出结果为：jack</span></div><div class="line"></div><div class="line"><span class="comment">#销毁某个变量的值</span></div><div class="line"><span class="keyword">unset</span>($demo1);    <span class="comment">//销毁变量的值</span></div><div class="line"><span class="keyword">echo</span> $demo1;      <span class="comment">//变量被销毁</span></div><div class="line"><span class="keyword">echo</span> $demo2;      <span class="comment">//输出结果为：jack</span></div></pre></td></tr></table></figure><p><strong>变量的作用域</strong></p><p>变量声明的位置决定了其作用域，作用域即变量可以被访问的域（范围）。<br>PHP语言中存在四种类型的作用域：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/php-03.png?raw=true"></p><p>（1）局部作用域</p><ul><li>在函数内部声明的变量是局部变量。</li><li>局部变量只能在声明的函数内部进行访问，函数外部无法访问。</li><li>只有函数可以提供局部作用域。</li></ul><p>（2）全局作用域</p><ul><li>在函数外部声明的变量是全局变量。</li><li>全局变量可以在程序的任务部分被访问。</li><li>默认情况下，在函数内部不能直接访问全局变量，但可以通过global关键字或者是$GLOBAL数组访问。<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 全局变量</span></div><div class="line">$n = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment"># 函数的声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//echo $n;        //错误演示：内部不能直接访问全局变量</span></div><div class="line"></div><div class="line">    <span class="comment"># 函数内部访问全局变量的两种方式</span></div><div class="line">    <span class="comment"># [1] 使用global关键字来表明$n是全局变量</span></div><div class="line">    <span class="keyword">global</span> $n;        </div><div class="line">    <span class="keyword">echo</span> $n;          <span class="comment">//输出结果为：123</span></div><div class="line">    </div><div class="line">    <span class="comment"># [2] 使用$GLOBALS数组来访问全局变量</span></div><div class="line">    <span class="keyword">echo</span>  $GLOBALS[n];<span class="comment">//输出结果为：123</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 调用函数</span></div><div class="line">f();</div></pre></td></tr></table></figure></li></ul><p>（3）静态作用域</p><ul><li>在函数内部使用static关键字声明的变量是静态变量。</li><li>静态变量在函数执行完毕后并不会被释放，其值不会丢失。</li><li>静态变量只能在函数内部访问。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 函数的声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="comment"># 使用static关键字来声明静态变量</span></div><div class="line">    <span class="keyword">static</span> $n = <span class="number">100</span>;</div><div class="line">    $n ++;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.$n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># 调用函数</span></div><div class="line">f();       <span class="comment">//打印的结果为：101</span></div><div class="line">f();       <span class="comment">//打印的结果为：102</span></div><div class="line">f();       <span class="comment">//打印的结果为：103</span></div></pre></td></tr></table></figure><p>（4）函数参数</p><ul><li>函数的参数（形参）是局部的，只在函数内部有效。</li><li>函数外部无法访问函数的参数。</li></ul><p><strong>② 常量</strong></p><p><code>常量</code>是一个简单值的标识符，建议所有字符大写。<br>PHP中使用define来定义常量，常量的值不可改变。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 常量的声明</span></div><div class="line">define(<span class="string">"INDEX"</span>,     <span class="string">"100"</span>);</div><div class="line">define(<span class="string">"PAGE_COUNT"</span>,     <span class="number">200</span>);</div><div class="line"></div><div class="line"><span class="comment"># 打印常量的值</span></div><div class="line"><span class="keyword">echo</span> INDEX;            <span class="comment">//100   </span></div><div class="line"><span class="keyword">echo</span> PAGE_COUNT;       <span class="comment">//200</span></div></pre></td></tr></table></figure><h4 id="2-4-表达式和运算符"><a href="#2-4-表达式和运算符" class="headerlink" title="2.4 表达式和运算符"></a>2.4 表达式和运算符</h4><p><code>[1]算术操作符</code></p><p>加法（+）减法（-）乘法（*） 除法（/）求模（%）</p><p><code>[2]自动递增（++）和递减（- -）操作符</code><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ex:</span></div><div class="line">$n++;   <span class="comment">#运算后$n加1</span></div><div class="line">++$n;   <span class="comment">#运算前$n加1</span></div><div class="line"></div><div class="line">$n--;   <span class="comment">#运算后$n减1</span></div><div class="line">--$n;   <span class="comment">#运算前$n减1</span></div></pre></td></tr></table></figure></p><p><code>[3]字符串连接操作符</code></p><p>在JavaScript语言中，连接字符串使用+操作符，而PHP中使用.来连接。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ex:</span></div><div class="line"><span class="comment">#字符串连接</span></div><div class="line">$str1 = <span class="string">"天王盖地虎"</span>;</div><div class="line">$str2 = <span class="string">"宝塔镇河妖"</span>;</div><div class="line">$str = $str1.<span class="string">" "</span>.$str2;</div><div class="line"><span class="keyword">echo</span> $str;            <span class="comment">#输出结果为：天王盖地虎 宝塔镇河妖</span></div></pre></td></tr></table></figure></p><p><code>[4]比较操作符</code></p><p>等于（= =）：操作数相等则返回true，否则返回false。<br>全等（===）：操作数相等且类型相同则返回true，否则返回false。</p><p><code>[5]赋值操作符</code></p><p>基本赋值操作符：等号（=）表示给一个变量赋值。如\$n = 5;<br>其他赋值操作符：<br>相加赋值（+=）相减赋值（-=）<br>相除赋值（/=）取模赋值（%=）<br>相乘赋值（*=）拼接赋值（.=） </p><h4 id="2-5-控制输出语句"><a href="#2-5-控制输出语句" class="headerlink" title="2.5 控制输出语句"></a>2.5 控制输出语句</h4><p>在PHP中可以使用多种方式来向浏览器输出内容：echo、print（）等。</p><p><strong>① echo控制输出</strong></p><p>echo结构会把字符串输出到PHP生成的HTML页面中。它本身是一种特殊的语言结构并非真正的函数。<br><code>echo结构</code>允许一次输出多个值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#echo 的使用方式说明</span></div><div class="line"><span class="keyword">echo</span> <span class="string">"Rose"</span>;      <span class="comment">//向浏览器输出Rose</span></div><div class="line"><span class="keyword">echo</span>(<span class="string">"Rose"</span>);     <span class="comment">//向浏览器输出Rose</span></div><div class="line"><span class="comment"># 说明：上面的两种形式是等价的</span></div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">"Rose"</span>,<span class="string">"Jack"</span>,<span class="string">"Tom"</span>;  <span class="comment">//可以通过逗号分隔的方式来输出多个字符串</span></div><div class="line">$arrT = <span class="keyword">array</span>(<span class="string">"demoA"</span>,<span class="string">"demoB"</span>,<span class="string">"demoC"</span>);</div><div class="line"><span class="keyword">echo</span> $arrT;                <span class="comment">//注意：输出的结果为Array,并不能显示具体的元素</span></div></pre></td></tr></table></figure></p><p><strong>② print()控制输出</strong></p><p><code>print（）函数</code>也可以向浏览器输出内容，但是一次只能输出一个值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> (<span class="string">"向浏览器输出内容"</span>);</div></pre></td></tr></table></figure></p><p><strong>③ printf()控制输出</strong></p><p><code>printf()函数</code>能够根据模板格式化输出字符串。<br><code>printf()函数</code>的输出，是通过替换格式化字符串（即模板）中的值所生成的字符。使用方式同C语言中的同名函数用法几乎一致。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#printf函数的使用说明</span></div><div class="line"><span class="comment">//（1） 百分比输出</span></div><div class="line">printf(<span class="string">'%.2f%% 完成率'</span>,<span class="number">87.4</span>);  <span class="comment">//输出结果为：87.40% 完成率</span></div><div class="line"><span class="comment">//（2）截取浮点数的小数</span></div><div class="line">printf(<span class="string">'%.3f'</span>,<span class="number">23.23669684</span>);   <span class="comment">//输出结果为：23.237</span></div><div class="line"><span class="comment">//（3）输出某个数字的二进制数</span></div><div class="line">printf(<span class="string">'%d 的二进制数表示为 %b'</span>,<span class="number">4</span>,<span class="number">4</span>); <span class="comment">//输出结果为：4的二进制数表示为100</span></div></pre></td></tr></table></figure></p><p><strong>④ print_r()控制输出</strong></p><p>echo和print函数在处理的时候会把参数全都转换成字符串，而如果需要打印的是数组或者对象，那么直接使用echo或者print函数输出无法得知其内部细节。<br><code>print_r()函数</code>可以智能的打印数组或对象，方便我们调试。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#print_r函数的使用说明</span></div><div class="line">$arrT = <span class="keyword">array</span>(<span class="string">"demoA"</span>,<span class="string">"demoB"</span>,<span class="string">"demoC"</span>);</div><div class="line"><span class="keyword">echo</span> $arrT;                <span class="comment">#注意：输出的结果为Array,并不能显示具体的元素</span></div><div class="line">print_r($arrT);            </div><div class="line"><span class="comment">#输出的结果为：</span></div><div class="line"><span class="comment">//Array ( [0] =&gt; demoA [1] =&gt; demoB [2] =&gt; demoC )</span></div><div class="line"></div><div class="line"><span class="comment">#var_dump函数的打印对比</span></div><div class="line">var_dump($arrT);           </div><div class="line"><span class="comment">#输出的结果为：</span></div><div class="line"><span class="keyword">array</span>(<span class="number">3</span>) &#123; [<span class="number">0</span>]=&gt; string(<span class="number">5</span>) <span class="string">"demoA"</span> [<span class="number">1</span>]=&gt; string(<span class="number">5</span>) <span class="string">"demoB"</span> [<span class="number">2</span>]=&gt; string(<span class="number">5</span>) <span class="string">"demoC"</span> &#125;</div></pre></td></tr></table></figure></p><h3 id="第三章-控制结构"><a href="#第三章-控制结构" class="headerlink" title="第三章 控制结构"></a>第三章 控制结构</h3><p>PHP语言中的控制结构跟其它语言几乎一样，可以被分为分支型结构和循环型结构。分支结构主要有if…else语句和switch语句，而循环结构主要有for循环和while循环以及do…while循环。</p><h4 id="3-1-分支结构"><a href="#3-1-分支结构" class="headerlink" title="3.1 分支结构"></a>3.1 分支结构</h4><p><strong>① if..else语句</strong></p><p><code>if..else语句</code>会检测表达式的结果，如果结果为true，则执行if后面的语句，否则执行else后面的语句。</p><p>如果要执行的语句包含多条，可以使用{}来包括这些语句。</p><p><strong>备注</strong><br>（1）如果需要进行多条件的判断可以使用elseif语句。<br>（2）PHP提供了特殊的语法来替代代码块的大括号，可以使用冒号来替代左大括号({)，使用endif来替代右大括号(})。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># if..else的使用示范</span></div><div class="line">$score = <span class="number">67</span>;</div><div class="line"><span class="keyword">if</span>($score &gt;=<span class="number">80</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"优秀"</span>;</div><div class="line">&#125;<span class="keyword">elseif</span> ($score &gt;=<span class="number">60</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"及格"</span>;</div><div class="line">&#125;<span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"不及格"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># -----------------------------</span></div><div class="line"><span class="comment"># if...else的特殊语法</span></div><div class="line"><span class="keyword">if</span>($score &gt;=<span class="number">80</span>):</div><div class="line">    <span class="keyword">echo</span> <span class="string">"优秀"</span>;</div><div class="line"><span class="keyword">elseif</span> ($score &gt;=<span class="number">60</span>):</div><div class="line">    <span class="keyword">echo</span> <span class="string">"及格"</span>;</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">echo</span> <span class="string">"不及格"</span>;</div><div class="line"><span class="keyword">endif</span>;</div></pre></td></tr></table></figure></p><p><strong>② switch语句</strong></p><p><code>switch语句</code>会将表达式的值和switch中所有的情况(case)都进行比较，如果匹配到相等的case，那么该case下面所有的语句都会被执行，直到第一次遇到break关键字。</p><p>如果没有匹配到任何一个case，并且代码中提供了一个default，那么default关键字下面所有的语句都会被执行，直到第一次遇见break关键字。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#switch语句的使用示范</span></div><div class="line">$day = <span class="number">6</span>;</div><div class="line"><span class="keyword">switch</span> ($day)&#123;</div><div class="line">    <span class="keyword">case</span> (<span class="number">1</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Monday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">2</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Tuesday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">3</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Wednesday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">4</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Thursday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">5</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Friday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">6</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Saturday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> (<span class="number">7</span>):</div><div class="line">        <span class="keyword">echo</span> <span class="string">"Sunday"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">echo</span> <span class="string">"不支持当前变量的值"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>备注</strong><br>switch语句支持和if..else语句中相同的特殊语法，结尾使用endswitch;</p><h4 id="3-2-循环结构"><a href="#3-2-循环结构" class="headerlink" title="3.2 循环结构"></a>3.2 循环结构</h4><p><strong>① while循环</strong></p><p>while语句是最简单的循环。</p><p>语法结构为：</p><p><code>while（expression） statement</code></p><p>如果expression判断为true，则执行后面的statement语句。然后再次判断expression循环这个过程，直到表达式为false时循环退出。</p><p><strong>备注</strong><br>(1)  while支持类似if..else和switch的特殊语法，结尾使用endwhile。<br>(2)  在循环体中可以使用break和continue语句来跳出循环。</p><p><code>【1】break关键字用于结束循环。</code><br><code>【2】continue关键字用于跳出当前循环。</code><br><code>【3】它们都支持在后面放一个数字，表示要中断多少层的循环。</code></p><p><strong>代码演示</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$count = <span class="number">10</span>;</div><div class="line"><span class="keyword">while</span> ($count &gt;<span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>.$count;</div><div class="line">    $count--;</div><div class="line">&#125;</div><div class="line"><span class="comment">#输出结果为：10 9 8 7 6 5 4 3 2 1</span></div></pre></td></tr></table></figure></p><p><strong>② do while循环</strong></p><p>PHP语言中do…while循环和其他主流语言中的结构几乎没什么不同。<br>do…while循环的特点是可以保证循环体中的语句至少执行一次。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ex:</span></div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"循环体的打印"</span>;</div><div class="line">&#125;<span class="keyword">while</span>(<span class="keyword">false</span>);</div><div class="line"><span class="comment"># 输出结果为：循环体的打印</span></div></pre></td></tr></table></figure></p><p><strong>③ for循环</strong></p><p>for循环的语法结构为：</p><p><code>for（start；condition；increment）{statement(s)；}</code></p><p>在for循环刚开始前，会先判断表达式的值，如果满足条件则执行循环主体，然后执行increment，并再次判断表达式是否满足条件，重复这个过程直到不满足条件为止。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># for循环的使用</span></div><div class="line"><span class="keyword">for</span>($i = <span class="number">0</span>;$i&lt;<span class="number">5</span>;$i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> $i;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出的结果为：01234</span></div><div class="line"></div><div class="line"><span class="comment"># for循环的替代语法</span></div><div class="line"><span class="keyword">for</span>($i = <span class="number">0</span>;$i&lt;<span class="number">5</span>;$i++):</div><div class="line">    <span class="keyword">echo</span> $i;</div><div class="line"><span class="keyword">endfor</span>;</div><div class="line"><span class="comment">//输出的结果为L01234</span></div><div class="line"></div><div class="line"><span class="comment">#使用for循环来遍历数组</span></div><div class="line">$arrM = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>);</div><div class="line"><span class="keyword">for</span>($i = <span class="number">0</span>;$i&lt;count($arrM);$i++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"__"</span>;</div><div class="line">    <span class="keyword">echo</span> $arrM[$i];  <span class="comment">//输出结果为1，3，5，7，9</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一章-PHP简单介绍&quot;&gt;&lt;a href=&quot;#第一章-PHP简单介绍&quot; class=&quot;headerlink&quot; title=&quot;第一章 PHP简单介绍&quot;&gt;&lt;/a&gt;第一章 PHP简单介绍&lt;/h3&gt;&lt;h4 id=&quot;1-1-PHP和它的应用领域&quot;&gt;&lt;a href=&quot;#1-1-PHP和它的应用领域&quot; class=&quot;headerlink&quot; title=&quot;1.1 PHP和它的应用领域&quot;&gt;&lt;/a&gt;1.1 PHP和它的应用领域&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PHP（全称：PHP：Hypertext Preprocessor，即“PHP：超文本预处理器”）&lt;/code&gt;，是一种开源的多用途脚本语言，可以直接嵌入到 HTML中，尤其适合 web 开发。&lt;br&gt;
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>摄影作品 春风十里</title>
    <link href="https://weibo.com/u/3800117445/2017/11/26/%E6%98%A5%E9%A3%8E%E5%8D%81%E9%87%8C/"/>
    <id>https://weibo.com/u/3800117445/2017/11/26/春风十里/</id>
    <published>2017-11-26T04:35:18.000Z</published>
    <updated>2018-04-11T02:21:33.618Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/flowerField/Source/blob/master/Blog/flower.JPG?raw=true" alt=""></p><p>春水初生，春林初盛，春风十里不如你。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这张照片拍摄于2016年2月9日，沾益九龙湖，在萧瑟的季节里开始想念春天。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/flower.JPG?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;春水初生，春林初盛，春风十里不如你。&lt;/p&gt;
&lt;figure class
      
    
    </summary>
    
      <category term="摄影作品" scheme="https://weibo.com/u/3800117445/categories/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="摄影作品" scheme="https://weibo.com/u/3800117445/tags/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>摄影作品 熄灭了烟</title>
    <link href="https://weibo.com/u/3800117445/2017/11/25/%E7%86%84%E7%81%AD%E4%BA%86%E7%83%9F/"/>
    <id>https://weibo.com/u/3800117445/2017/11/25/熄灭了烟/</id>
    <published>2017-11-25T08:44:48.000Z</published>
    <updated>2018-04-11T02:21:33.614Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/flowerField/Source/master/Blog/psb.jpeg" alt=""></p><p>你熄灭了烟，说起从前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">这张照片拍摄于2014年，技术研究中心，如今昔日战友已经四散天涯。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/flowerField/Source/master/Blog/psb.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你熄灭了烟，说起从前。&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="摄影作品" scheme="https://weibo.com/u/3800117445/categories/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81/"/>
    
    
      <category term="摄影作品" scheme="https://weibo.com/u/3800117445/tags/%E6%91%84%E5%BD%B1%E4%BD%9C%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [004]-花田半亩</title>
    <link href="https://weibo.com/u/3800117445/2017/10/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B004%5D-%E8%8A%B1%E7%94%B0%E5%8D%8A%E4%BA%A9/"/>
    <id>https://weibo.com/u/3800117445/2017/10/14/读书笔记 [004]-花田半亩/</id>
    <published>2017-10-14T00:55:52.000Z</published>
    <updated>2018-04-16T11:23:45.673Z</updated>
    
    <content type="html"><![CDATA[<div class="tip"><br>题记：大概五六年前，我在博客园写作，不时的分享一些技术学习方面的心得。后来很多原因，我的写作一度中断。<br>时间长了之后再想提笔，竟没有继续在博客园写作的理由了。辗转多处，最后鼓捣了这么个小站，要给博客起个有意义的名字才好。这时候，我想到了差不多10年前读到的一本书，严格来说是博客文集，书名为<a href="https://book.douban.com/subject/3698217/" target="_blank" rel="external">花田半亩</a>，作者田维。<br>这不是一部文学性的作品，它是精神性的，教会我哪怕在绝望中也对生活心怀善意和热爱。<br><code>田维，明亮如水的女孩，愿你安宁，以为纪念。</code><br></div><div style="color:green; font-size:18px">※·2003</div><p>就在中考来临之前，我却突然被宣布不能喝咖啡了。<br>于是，我的世界很久不再见咖啡。取而代之的是弥漫在苍白里的药品的味道，消毒液的味道… 它们伴着刺眼的白色深深刺痛着我的心。<br><span style="color:red; ">春天明明已经来了，怎么却又被锁在了窗外呢？</span><br>当我怀着一颗简单的心去看这个世界，世界也就没有了那么多的烦恼，原来生活可以简单快乐地像一杯咖啡。<br>有人也曾问我为何不去咖啡店品尝一番那地道的咖啡呢？或许那才是真正的咖啡，却不是我的。我的咖啡是儿时那在精美中坏掉的咖啡，是在冷光里泛着热气的咖啡，是简单中苦甜苦甜的芳香。(<code>有关咖啡</code>)</p><p>※·※</p><p>不知道曾有多少个窗下听雨的午后，在初春，在夏末，在秋风乍起时，在未成雪的日子。<br>淡淡的记忆支持不了一颗未了的心。<br>在夜近更阑，在梦醒的清晨，在醉着的午后。(<code>耳畔的声</code>)</p><p>※·※</p><p>原来，夜依旧是夜，墙终归是墙。我挣不脱，梦也挣不脱。于是，便睡去吧。<br>白色，太单调，不是梦的居所。<br>没有梦的润色，光阴只不过是白纸一张，单薄没有重量。(<code>做梦的孩子</code>)</p><p>※·※</p><p>生活与梦总是差之千里。<br>很狭义的浪漫，不是花前月下，没有风花雪月，不过是麻木生活中的一点鲜活。（<code>浪漫·在一瞬间</code>）</p><p>※·※</p><p>在四月，我绝对自己的肉体是鲜活轻盈的，我觉得自己复活在阳光里。<br>在四月，我触摸到生命的轮廓，光滑却崎岖，笔直却蜿蜒。<br>四月，不再是欣喜和甜美。四月，突然变得离奇恐怖起来。<br>我依旧反复吟唱着自己的歌，在那一个个骤然风起的日子。（<code>曾经</code>）</p><p>※·※</p><p><span style="color:red; ">孤独在门外徘徊，我不让它进来。</span></p><p>有时你觉得孤独是一片汪洋，当人沉浮其中将迷失所有方向。<br>所以，孤独的人很怕黑。<br>如果你的灵魂不孤独，你便不会写作。<br>这世界，人山人海，庆幸自己在最美丽的日子里遇见他。</p><p><span style="color:red; ">生命是一片纯白的空地，孤独的人们反复徘徊。在这一片纯白之上，我哭了又笑，一点点明白所谓人世的道理。当生命终于也随浮华远去，我终于得到安宁。</span>（<code>流光的灰白浅影</code>）</p><div style="color:green; font-size:18px">※·2004</div><br><div class="tip"><br>按：这一年，田维考入北京语言大学中文系。<br></div><br>一切都好，只缺烦恼。<br>睡在高处，睡在挂了纱帐的高处，听来幸福莫名。<br>是时候一个人享受无声无息的静夜，是时候把种种意象的美妙重新整理回味。<br>我在高处，生活在高处。(<code>高处</code>)<br><br>※·※<br><br>读李商隐的”嫦娥应悔偷灵药，碧海青天夜夜心”，竟忍不住叹息感怀。<br>要读着令人唇齿留香的诗句，要枕着洒满清辉的高枕，要聆听夜空极远处隐隐的松涛，要梦飞翔的梦，要忆思念着的笑容。让句句珠玉在唇齿间滑过，让绵长延续的只属于月的所有思绪与怀想，都在这一个朗朗的夜晚注满心灵的小小池塘。<br>这一夜，是中秋，月正圆。(<code>那一端</code>)<br><br>※·※<br><br>我们是被拘于小小的天地，做自己的事情，读自己的心。<br>一切原本轻忽，只是自己肉身太重。(<code>片刻</code>)<br><br><div style="color:green; font-size:18px">※·2005</div><p>春初的湖，春水跌宕。<br>听那汨汨而去的丽声，清越悠长。<br>和莫一道漫步，不需要许多言语，只是默声而行，便已尽游兴。(<code>初</code>)</p><p>※·※</p><p>如果不去医院，人总很难想象世间有多少的悲苦与无常。<br>白灿灿的日光刺眼，照得万物光明。<br>人生天地间，忽如远行客。<br>没有人是不同的，我们殊途同归。(<code>苦味</code>)</p><p>※·※</p><p>云，是从哪里来的？<br>是我在你睡熟时，偷走被子里的棉花，挂到天上去啦？（<code>纤纤</code>）</p><div class="tip"><br>按：王小波在早期的小说《绿毛水怪》里，借陈辉和杨素瑶谈恋爱之口，写出了四句极好的诗，描写的是两人走在有雾的路灯下：<br>　　<pre><br>大团的蒲公英浮在街道的河流口 吞吐着柔软的针一样的光 我们好像在池塘的水底 从一个月亮走向另一个月亮.<br>    </pre><br>    读到这一段的时候，差不多有同样的感觉。<br></div><p>※·※</p><p>在山脚下，我的门前会开满迷醉的花朵，你只有穿过那团团的花丛，才能到达我天青色的门前。<br>请轻声敲门，或唤我的名字，我将居住在那，在生命赐予的或长或短的年华。<br>我将独居，或有一位爱人。（<code>山想</code>）</p><p>※·※</p><p>谁忍住悲伤，心疼的原谅。<br>一路洒泪，一路歌吟。<br>我感觉幸福，我感谢上天的眷顾。<br>如果，青春是白纸，我愿意，印上血红的足印。<br>我这么珍惜，生命里的偶遇和意外。（<code>穿梭</code>）</p><p>※·※</p><p>云霄飞车，降落时，我体会到无尽的失落。<br>天空是完满的，所以容不下人的肮脏。活着的时候，我们只可以下落，无无法飞升。人是属于地的，只有魂是属于天的。<br>把自己藏起来，有时会为了被寻找。<br>日子不书写，就会丢失，其实即便书写了也照样会丢失。都是没办法的事情，明知是徒劳，却又不好不做。（<code>零碎</code>）</p><p>※·※</p><p>一种女子，立在风雨斑驳的桥头，粲然微笑，任时光荏苒，任芳菲开落，不曾减却分毫她的风姿。她是坚立的花树，是勇敢，是永远的天真洁白，只是伫立，便成风景。</p><p>她是默默的，是不言语的深情。<br>她是水做的肌骨，是三分的童真，七分的善良。<br>她深信着爱，她读童话，却不相信美丽的结局。<br>她品自己的茶，读自己的书，守自己的日月，自己的年华。<br><span style="color:red; ">她立在风雨，无所畏惧。</span>(<code>一种女子</code>)</p><p>※·※</p><p>我将把上天的恩赐，说给睡了的夜晚，让雨天里湿掉的月亮在我的梦境中开成层叠的繁花。<br>你会看见，目光的芬芳流溢，你会懂得，一季季的相逢和告别，不是种偶然。我是夙命的，我是愿意编织谎言，又深信的。<br>于是，我说那些前世，于是，我眷恋于今生。<br>我在凉丝丝的九月，穿过校园。<br>我拥有夜晚，我拥有雨天，拥有爱人的温度和气味，却无法安全。（<code>凝</code>）</p><p>※·※</p><p>母亲说，记得给花换水。<br>我怎么可能忘记呢。那苍凉而美丽的花朵呀。<br>很旧的上海，有女子在留声机里唱起，花样的年华，月样的精神。<br>你们要尽情地美，莫要顾惜。<br><code>半亩花田。</code><br>素处以默，妙机其微。（<code>花样</code>）</p><p>※·※</p><p>我没有太多的朋友，却拥有，最善良贴心的伙伴。<br>秋天里，不可得的是清醒，长久的是沉溺于西风的萧瑟。而我，是深怀了感激与爱的。<br><span style="color:red; ">我对岁月俯首，对星辰致意。</span><br>我想到宇宙的无限，想到不可挽回，不可琢磨的长度与空间。<br>那黑漆的世界，仿佛要吞噬所有，却又好象给予了一切。（<code>谁或谁的胡言</code>）</p><p>※·※</p><p>我想着，这年里，一场艳夏的荒芜，想着，水光在桥洞下流变，那空无一物般的静。也想这肉身的虚弱，一次次的病痛，无能无力。<br>就有愧疚的心，对于母亲，她不曾奢求我什么，只是要我的平安与康健，我却都不能够完满。我不能够完满，她那卑微的幸福，我对母亲说，不要责怪我吧，她就要哭出来。我竟是这样不会言语的孩子。躺在她身旁，我才知道，我和母亲原是一体，我正如她的肢体发丝，是没有区分的。</p><p>她总是温柔而宽容地对待我，这曾经小小的，生长在她体内的生命。她是爱我，用了全部的心血和劳力。为了这病怏怏的我，为了这不能够完满她幸福的我。是因为些什么，我脆弱得好象白纸的苍白了，却有恍然坚强勇敢起来。我平卧在这夜的深暗里，把所有的遭遇和不幸都一一原谅。<br>不可以改变的事情，我们就伸开双臂，深情拥抱。<br>仿佛这一夜，我拥抱自己的身体，不曾责怪她可能致命的小毛病。<br>曹问，你为些什么活着。<span style="color:green; ">我说，眷恋与不舍。</span><br><span style="color:green; ">万物美好，我在中央。</span>(<code>芜杂里的生长</code>)</p><p>※·※</p><p>我们永远看不清身处何方，我们永远只是被时间无情地流放。<br>细数流年，去懂得草木，懂得雨雪，懂得，一颗心的盛开和凋谢。<br>我喝一杯清水。黑夜浸润了房间。<br>我们是水做的。我们在生死人神的临界。（<code>临界·留念</code>）</p><p>※·※</p><p>关于生死，我们总是疑问，像隔了山岳几重又几重，带着旅人的疲惫，也带着期待，我们一路奔赴。越了山溪，经过如笑春山，几分欣愉，几分恐惧。因着对生的无限眷恋。<br>不要说，你无所谓于生死。我却仍然感觉生之可贵。我们终将离去，我们终将闭了双眼万事不知，这有限的岁月，纵使是屈辱和痛苦，也该好好保存的罢。因那是母亲的赠予，无限的赠予。<br>因这一身的不可再生，我们珍爱了落花，悲伤了秋树，听着残荷临雨，细数西风的归期，感叹着流年暗中偷换，凄恻一场（<code>生</code>）</p><p>※·※</p><p>树，用它们一成不变的姿态站立，在高处俯瞰，匆匆的，繁华似锦，又苍凉如寒梦的人间。<br>叶子是美丽的，有血脉流淌。<br>我等待着日子的告别，等待十二月，一场漫天席卷的风雪。让我喝一杯热开水，甜美地笑，满足在年末的疏落和枯燥。因为知道，冬天的花朵正开着，开着，肆无忌惮地幸福。<br><span style="color:red; ">我多想，在一个结了冰花的晨早，醒在你洁白的梦里。</span><br>我们都是，留恋人间的天使。（<code>十一月的胡言</code>）</p><p>※·※</p><p>空床卧听南窗雨，谁复挑灯夜补衣。<br>你说，我活得幸运，我说，我幸福得不知去向。<br>风吹向南方，吹灭我的妄想，像那些深夜里脆弱的烛火一样。<br>人人都貌似欢乐，人人都很悲伤。（<code>婚宴·其它</code>）</p><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;&lt;br&gt;题记：大概五六年前，我在博客园写作，不时的分享一些技术学习方面的心得。后来很多原因，我的写作一度中断。&lt;br&gt;时间长了之后再想提笔，竟没有继续在博客园写作的理由了。辗转多处，最后鼓捣了这么个小站，要给博客起个有意义的名字才好。这时候，我想
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [003]-我们仨</title>
    <link href="https://weibo.com/u/3800117445/2017/10/13/%E6%88%91%E4%BB%AC%E4%BB%A8/"/>
    <id>https://weibo.com/u/3800117445/2017/10/13/我们仨/</id>
    <published>2017-10-13T15:58:37.000Z</published>
    <updated>2018-04-16T11:23:45.685Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">* 作者 杨绛</div><div class="line">* 购书时间：2016年10月25日</div><div class="line">* 开始时间：2016年10月26日</div><div class="line">* 结束时间：2016年11月11日</div><div class="line">* [我们仨](https://book.douban.com/subject/19958089/)</div><div class="line">* Reading 杨也</div></pre></td></tr></table></figure><a id="more"></a><h4 id="第一部分-我们俩老了"><a href="#第一部分-我们俩老了" class="headerlink" title="第一部分 我们俩老了"></a>第一部分 我们俩老了</h4><p>有一晚，我做了一个梦。<br>梦中凄凄惶惶，好像只要能找到他，就能一同回家。</p><h4 id="第二部分-我们仨失散了"><a href="#第二部分-我们仨失散了" class="headerlink" title="第二部分 我们仨失散了"></a>第二部分 我们仨失散了</h4><p>这是一个万里长梦。梦境历历如真，醒来还如在梦中。<br>文中说道：开会 + 84岁 + 古驿道 + 钱锺书去春大病 + 圆(媛) + 结核 + 船(311) + 三里河 + 西石槽<br>他向例早睡早起，我晚睡晚起，阿圆晚睡早起。<br>我们俩人的早饭总是锺书做的。<br>我常常觉得年纪不饶人，我已力不从心。<br>警告是红牌黑字，字很大。</p><p>顺着蜿蜒的水道向西看去，只觉得前途很远很远，只是迷迷茫茫，看不分明。<br>水边一顺溜的青青草，引出绵绵远道。<br>季康，阿圆。<br>堤上的杨柳开始黄落，渐渐地落成一棵棵秃柳。我每天在驿道上一脚一脚走，带着自己的影子，踏着落叶。<br>“有一个星期天，三人在床上相聚”。<br>我在古驿道上，一脚一脚的，走了一年多。</p><p>我变成了一个很沉重的梦。<br>我终于找到了她的医院，在苍松翠柏间。<br>进院门，灯光下看到一座牌坊，原来我走进了一座墓院。<br>他很倦怠，话也懒讲，只听我讲，张开眼，又闭上。<br>我虽然天天见到他，只觉得他离我很遥远。<br>梦是有想象力的，想念的太狠了，就做噩梦。<br>锺书仍对我说，叫阿圆回去，回到她自己家里去。<br>锺书很诧异的看着我，他说，”你也看见她了?”<br>锺书着重说…<br>锺书凄然看着我说….<br>老人的眼泪是干枯的，只会心上流泪。<br>锺书点头，却闭着眼睛。<br>我初住客栈，能轻快地变成一个梦。到这时，我的梦已经像沾了泥的杨花，飞不起来。<br>三里河的家，已经不复是家，只是我的客栈了。</p><h4 id="第三部分-我一个人思念我们仨"><a href="#第三部分-我一个人思念我们仨" class="headerlink" title="第三部分 我一个人思念我们仨"></a>第三部分 我一个人思念我们仨</h4><p>我们仨都没有虚度此生，因为是我们仨。<br><code>我们这个家，很朴素；我们三个人，很单纯</code>。<br>现在我们三个失散了。往者不可留，逝者不可追；剩下的这个我，再也找不到他们了。</p><p><strong>(一) “夫妇牛津学习”</strong></p><p>1935年7月，锺书不足25岁，我24岁不到，我们结了婚同到英国牛津求学。<br>锺书已由官方为他安排停当，入埃克塞特(Exeter)学院，攻读文学学士学位。<br>‘东吴大学-清华研究生’<br>我的兴趣不在戏剧而在小说。<br>那时候我年纪小，不懂得造化弄人，只觉得不服气。<br>既然我无缘公费出国，我就和锺书一同出国，借他的光，可省些生活费。<br>我不得已而求其次，只能做一个旁听生，听几门课，到大学的图书馆自习。<br>他是我国的庚款公费生，在牛津却是自费生。<br>我上的课，锺书都不上。他有他的必修课。他最吃重的是导师和他一对一的课。<br>我一个人穿着旗袍去上课，经常和两三位修女一起坐在课堂侧面的旁听座上，心上充满了自卑感。<br>严格的训练，是我欠缺的，而他没有更多的阅读时间。<br>反正我们两个都不怎么称心，而他的失望更大。<br>牛津学制每年共三个学期，每学期是八周，然后放假六周。<br>吃饭比上课更重要。<br>获得学士学位之后，再吃两年饭就是硕士，再吃四年饭，就成博士。<br>牛津的假期相当多。锺书把假期的全部时间投入读书。<br>他不爱活动 ⬆️<br>牛津人情味重。<br>能和锺书对等玩的人不多，不相投的就会嫌锺书刻薄了。我们和不相投的人保持距离，又好像是骄傲了。</p><p><strong>(二) “在牛津的生活”</strong></p><p>由老金处搬走入新居所。<br>我们不断的地发明，不断地实验，我们由原始人的烹调渐渐开化，走入文明阶段。<br>妥帖的字有黏性，忘不了。<br>一九三六年早春，英王乔治五世去世。<br>这一学年，该是我生平最轻松快乐的一年，也是我最用功读书的一年，除了想家想得苦，此外可说无忧无虑。<br>锺书不像我那么苦苦地想家。</p><p><strong>(三) “牛津大学毕业”</strong></p><p>我们第一次到伦敦时，锺书的堂弟锺韩带我们参观大英博物馆和几个有名的画廊以及蜡人馆等处。<br>这个暑假他一人骑了一辆自行车旅游德国和北欧，并到工厂实习。锺书只有佩服的份儿。<br>他绝没有这等本领，也没有这样的兴趣。<br>一九三六年”世界青年大会”代表。<br>获得牛津大学文学学士学位之后，他告别牛津友好，摒挡行李，一家三口随即前往巴黎。</p><p><strong>(四) “女儿诞生，前往巴黎大学游学”</strong></p><p>女儿已经有名有号，祖父取名为健汝，号丽英(因为属牛，牛丽于英)。<br>圆圆成了她的小名。<br>杨绛夫妇经常来往的是林藜光，李玮夫妇，李玮是清华中文系的同学。<br>他觉得为了一个学位赔掉许多时间，很不值当。他白费功夫读些不必要的功课，想读的许多书都只好放弃。<br>因此，他常引用一位曾获牛津文学学士的英国学者对文学学士的评价：文学学士，就是对文学无识无知。<br>锺书在巴黎的这一年，自己下功夫扎扎实实的读书。<br>他每天读中文、英文、隔日读法文、德文，后来又加上意大利文。<br>这是爱书如命的锺书恣意读书的一年。<br>交际圈：林藜光 + 李玮 + 向达<br>我自己才做了半年的妈妈，就失去了自己的妈妈。<br>那时的我没有意识到，悲苦能够任情啼哭，是多么的幸福。<br>我虽然尝到做母亲的艰辛，但我没有报得娘恩。<br>一九三八年八月，坐三等舱回国。</p><p><strong>(五) “学成回国到香港”</strong></p><p>船到香港，锺书上岸就直赴昆明西南联大(已经提前有约回清华大学教书)。<br>杨绛先生母校振华女中的校长因为苏州已经沦陷，所以请杨绛在上海筹建分校，并担任分校校长。<br>在清华工作不满一年，其父要求锺书到蓝田师范学院外文系主任，同时侍奉父亲。<br>“我是个乖女儿，爸爸的沉默启我深思”。<br>他自己无限抱愧，清华破格任用他，他却有始无终，任职不满一年就离开了。<br>杨绛先生认为，钱锺书辞职别就”到蓝田师范去做系主任”，得罪了时任清华大学外文系主任的叶公超先生。其认为钱是骄傲的人。<br>天下爷娘护小儿，对长子则往往责望多于宠爱。<br>‘锺书自小就缺少一位慈母，这对于他的性格和习惯都有着深远的影响。<br>钱锺书的父亲(钱基博)是头等的大好人，但是对人情世故却不练达；他关心国事，却天真得不识时务。</p><p><strong>(六) “女儿圆圆认字日常”</strong></p><p>圆圆天资聪明，只需要看一眼就认识字，不用温习，全部都记得，即过目不忘。<br>回国后，杨绛带着女儿一直和自己的父母姐妹们居住在上海。<br>1940年秋天，杨绛先生弟弟在维也纳医科大学学成回国。</p><p><strong>(七) “锺书为何没有回清华-家庭日常变迁”</strong></p><p>1941年暑假，锺书辗转回到上海。<br>锺书获悉清华聘他回清华任教，时清华外文系主任为陈福田。十月，陈福田亲来上海聘请钱锺书回清华任教。<br>但是钱锺书夫妇认为清华迟迟不发聘书，是为不欢迎。因此直接回绝了。<br>锺书这辈子受到的排挤不算少，他从不和对方争执，总乖乖的退让。<br>我们挤在辣斐德路钱家，一住就是八年。<br>珍珠港事变之后，孤岛已沉没，振华分校也解散了。<br>随后，杨绛先生变开始做代课老师，业余的时间写剧本。<br>锺书是父亲最器重的儿子，爱之深则责之严，但严父的架势掩不没慈父的真情。他们父慈子孝，但是父子俩的志趣并不相投。</p><p><strong>(八) 上海沦陷 日子艰苦</strong></p><p>上海沦陷，日子艰苦。<br>我在小学代课，写剧本，都是为了柴(煤球)和米。<br>锺书依靠几个拜门学生的学费过活。<br>杨绛先生父亲于1945年3月底在苏州去世，抗日战争还没有结束。<br>贫与病总是相连的。锺书在这段时期，每年生一场病。<br>1947年冬天，女儿钱媛得了骨结核，后痊愈。<br>1949年钱锺书夫妇接受了清华的聘约。</p><p><strong>(九) 何去何从</strong></p><p>1948年夏天，锺书的爷爷百岁寿冥，分散全国各地的一家人，都回无锡老家聚会。<br>1945年，锺书不再担任震旦女子文理学院的临时讲师，任中央图书馆的英文编辑，后又兼任暨南大学的教授，继而《围城》出版。<br>钱锺书父亲说话，从来不理会对方对方是否悦耳，这是他说话，写信，作文的一贯作风。<br>我们沦陷上海期间，饱经忧患，也见到世态炎凉。<br>一个人20不狂没志气，30犹狂是无识妄人。<br>钱锺书曾有机会到联合国教科文组织工作，但是被拒绝了。’不吃胡萝卜，就不会受大棒驱使’<br>锺书的第一个拜门弟子，常常请为他买书。”借痴斋藏书”<br>我们的阅读面很广。所以人心惶惶的时候，我们并不惶惶然。<br>我们明白，对国家有用的是科学家，而不是没用的知识分子。</p><p>如果要逃跑，并不是无路可走。<br>可是一个人在紧要关头，决定他何去何从的，也许总是他最基本的感情。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;* 作者 杨绛&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 购书时间：2016年10月25日&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 开始时间：2016年10月26日&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 结束时间：2016年11月11日&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* [我们仨](https://book.douban.com/subject/19958089/)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* Reading 杨也&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [002]-等一朵花开</title>
    <link href="https://weibo.com/u/3800117445/2017/09/14/%E7%AD%89%E4%B8%80%E6%9C%B5%E8%8A%B1%E5%BC%80/"/>
    <id>https://weibo.com/u/3800117445/2017/09/14/等一朵花开/</id>
    <published>2017-09-14T00:55:52.000Z</published>
    <updated>2018-04-16T11:23:45.670Z</updated>
    
    <content type="html"><![CDATA[<p><strong><code>等一朵花开，需要很多耐心和微笑</code></strong></p><p>日复一日的生活，并不太坏，也不太好，这就是苟且。</p><p>要成为一个有趣的人，最重要的事情，是要找个兴趣来碾压自己的智慧。<br><a id="more"></a><br>天微微亮时，朝霞红透了无边无际的海面，海浪拍打着脚下的礁石，数不清的海鸥绕着小岛飞舞，日出光芒万丈浮云开合。是不是很诗意的场景？其实我们不过是为了钓上一条两斤的石斑鱼而已。</p><p>有些事情，不需要辞职旅行，不需要等你辛苦存到一千万，只要心里长了草，马上就可以开始去做。</p><p>用很多的耐心和微笑，去等一朵花开放，有着非常重要的人生意义。</p><p>在最后会发现，那条石斑鱼根本不重要了。最美的时光，是在等那条鱼的时候。有趣才有诗意，眼界就是远方。</p><p><em>PS</em> 无意中找到了这样一本书，无论是图书的装帧、行文的风格还是内嵌的插图都让我在阅读的时候感到无比的轻松，很少能遇到有这样一本书能够让我在阅读的时候仅仅“享受”阅读这个过程，你能读到作者的诗情画意，也能注意到正午阳光正暖，种子在发芽。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;code&gt;等一朵花开，需要很多耐心和微笑&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日复一日的生活，并不太坏，也不太好，这就是苟且。&lt;/p&gt;
&lt;p&gt;要成为一个有趣的人，最重要的事情，是要找个兴趣来碾压自己的智慧。&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [001]-工作前5年，决定你一生的财富</title>
    <link href="https://weibo.com/u/3800117445/2017/09/13/%E5%B7%A5%E4%BD%9C%E5%89%8D5%E5%B9%B4%EF%BC%8C%E5%86%B3%E5%AE%9A%E4%BD%A0%E4%B8%80%E7%94%9F%E7%9A%84%E8%B4%A2%E5%AF%8C/"/>
    <id>https://weibo.com/u/3800117445/2017/09/13/工作前5年，决定你一生的财富/</id>
    <published>2017-09-13T15:00:18.000Z</published>
    <updated>2018-04-16T11:23:45.655Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">* 作者 三公子</div><div class="line">* 购书时间：2016年10月13日</div><div class="line">* 开始时间：2016年10月20日</div><div class="line">* 预计时间：15 * 30M</div><div class="line">* [工作前5年，决定你一生的财富](https://book.douban.com/subject/26590267/)</div><div class="line">* 花费时间：6[20] + 3[21] + 2[23] + 1[24] + 4[25] == 16[6]</div><div class="line">     说明：共花费16个30M，持续6天完成</div><div class="line">* Reading 杨也</div></pre></td></tr></table></figure><a id="more"></a><h4 id="第一章-理财意识觉醒笔记-0-20"><a href="#第一章-理财意识觉醒笔记-0-20" class="headerlink" title="第一章 理财意识觉醒笔记(0~20)"></a>第一章 理财意识觉醒笔记(0~20)</h4><p>〇 <code>金钱是可以控制的，足够的财务知识，理智和自控力，让进去为我所用</code>。<br>① <code>钱无比重要，有钱在手，如同一技傍身</code>。<br>② <code>有些道理，讲一讲就明白，可有些道理，需要经历过切肤之痛才能体会到</code>。<br>③ <code>经济独立才能换来生活独立，经济自由才能换来生活自由。</code><br>④ <code>生活可能因为钱而变得无力改变，人生可能因为钱而变得黯淡无光。</code><br>⑤ <code>养一只可以下金蛋的鹅。</code></p><p> 千万不要杀鸡取卵，很多人花光了自己所有的钱，却从来没有养大过一鹅。如果自己没有一只下金蛋的鹅，或者能够生钱的机器，那么无论你多有钱，那么都只是在不断的烧钱。”论述-有稳定收入来源的重要性”鹅是本金，而金蛋是利息。”鹅-金蛋  房东-房租” 。</p><p>⑥ <code>金钱与生活梦想是共生的关系,高质量的生活需要金钱买单，追求梦想的行动需要金钱付账。</code></p><p> 比如 可以花更多的金钱来租到距离公司更近的房子|比如旅游也是需要金钱的。</p><p>⑦<code>明确目标开始行动</code></p><p>A 弄清楚存钱的目的<br>B 确定切实的存钱目标 “依据自己的实际水平制定 + 目标不宜过高也不宜过低”<br>C 制定合理清晰的规划</p><p>⑧<code>如果只爱而没有钱，那么这一切就经不起时间的考验。</code></p><p>存钱攒钱也是需要付出代价的。<br>存钱不是理财，但是有一定的金钱基础是理财最最基本的条件。</p><p>⑨ <code>不要惧怕计划的庞大身躯，也不要低估聚沙为塔的力量。</code></p><h4 id="第二章-存钱大作战笔记（-60）"><a href="#第二章-存钱大作战笔记（-60）" class="headerlink" title="第二章 存钱大作战笔记（~60）"></a>第二章 存钱大作战笔记（~60）</h4><p>〇 <code>储蓄是理财的第一步。</code></p><p>[1]如果一毛钱都没有，那你理什么财？<br>[2]第一阶段，如何让自己有财可以理。</p><p>① <code>先存钱再消费，千万不能本末倒置。</code><br>② <code>一定要将钱存在一个自己拿不到的安全的地方</code><br>③ <code>无谓的失败没有任何意义，只会增加你上当受骗的概率。</code><br>④ <code>前几年的辛苦坚持，换来的可能是另一种生活。</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">01 如果在三线城市，每月仅仅800元或者是在一线城市，每月仅仅2000元，那么怎么办？</div><div class="line">            好好工作，多读书，尽早换一份能让你攒下钱的工作。</div><div class="line">02 存钱规划方式</div><div class="line">            方式一：20%存钱 + 30%租房 +40%日常开支+10%应急资金</div><div class="line">            方式二：每月存固定数额的资金在银行账户（12存单法）</div><div class="line">            方式三：百元周（每周只花100元），不推荐，预防报复性反弹</div><div class="line">            方式四：信封花钱法，不推荐</div><div class="line"> 03 关于“钱是挣出来的，不是攒出来的”</div><div class="line">            挣钱有两个重要的条件：① 原始资金 ② 守财有道</div><div class="line">            有意思：开口闭口这句话的人往往都是家无存粮的月光族，自我安慰罢了。</div></pre></td></tr></table></figure></p><p>⑤ <code>剔除不必要的开支，可以尝试记账</code></p><p>纸本记账：麻烦 + 按时按点的记账太困难<br>APP记账：依然无法解决遗忘的问题，只能自己克服</p><p>⑥ <code>真实账单中需要面对的&quot;现实问题&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">01 不好好吃饭，零食水果乱花钱。</div><div class="line">02 囤书容易，读书难。</div><div class="line">03 毫无节制的娱乐是对金钱和时间的不尊重。</div><div class="line">A 从某种程度上来说，恰恰因为我在很多方面可以免去开支的困扰，才更应该珍惜这种机会和条件，去认真对待自己的财务状况，去努力守护好每一分钱。</div><div class="line">B 庆幸自己的幸运</div><div class="line">C 正式因为我有更好的条件，所以我才更加珍惜如此的机会，更加慎重和努力的去工作。</div><div class="line">D 人必须懂得珍惜和感恩。</div></pre></td></tr></table></figure></p><p>⑦ <code>欲望大过一切的人，有再多的钱也不会节约下一分钱。</code><br>⑧ <code>存钱和理财这件事，和家境没有太大的关系，只和当下自己的决心有关系。</code><br>⑨ <code>存钱并不能让我们成为富翁，但如果没有存钱的习惯则更不可能成为富翁。</code><br>⑩ <code>生活中的幸福并不是来自于金钱，但财务的困难和生活中不可知的意外事件，会影响独立、尊严和自由。</code></p><h4 id="第四章-存钱大作战-盲目投资的教训-笔记-80"><a href="#第四章-存钱大作战-盲目投资的教训-笔记-80" class="headerlink" title="第四章 存钱大作战(盲目投资的教训)笔记(~80)"></a>第四章 存钱大作战(盲目投资的教训)笔记(~80)</h4><p>① <code>记账是必要的。</code></p><p>01 详细的账目是一本日常生活的流水账。<br>02 消费情况暗示生活状态。</p><p>② <code>放心给压岁钱，也就意味着他们知道我不会随便乱花。</code><br>③ <code>无论什么时候，都不要倾家荡产的去做一件事情。&quot;资金安全-风险&quot;</code><br>④ <code>错误的判断只会让我们在泥潭中越陷越深。</code><br>⑤ <code>有的时候，我们或许应该大胆承认自己的贪婪和无知，抽身离开。</code></p><h4 id="第五章-投资正式入门（基金应该这么买）笔记-116"><a href="#第五章-投资正式入门（基金应该这么买）笔记-116" class="headerlink" title="第五章 投资正式入门（基金应该这么买）笔记(~116)"></a>第五章 投资正式入门（基金应该这么买）笔记(~116)</h4><p>①<code>在金钱的事情上，做事情以谨慎为上。</code><br>② <code>基金：把大家手中的钱汇总到一个有经验的人手中做同一管理的一种方式。</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">01 咒语:你所依赖的不是别人的推荐，而是自己的判断。</div><div class="line">02 可以通过测试题，来测试自己的风险偏好和风险承受能力。</div><div class="line">03 分类：</div><div class="line">            货币型基金：风险低，流动性高，收益低。</div><div class="line">            债券型基金：相对稳健，收益中等</div><div class="line">            股票型基金：从长期来看，收益最大，但波动也较大。</div><div class="line">04 先选择基金的类型，基金公司，然后通过一些基金网站（晨星网）筛选基金</div></pre></td></tr></table></figure></p><p>③ <code>按照年龄来分配投资的额度，比如25岁，那么推荐在储蓄上保持25%，余下的75%拿来进行投资</code>。<br>④ <code>基金操作的问题。</code>担心操作失误的妄想，情绪波动非正常化<br>⑤ <code>基金有风险，投资需谨慎。短期看基金风险很大，长期看基金几乎没有风险</code>。<br>⑥ <code>投资开始得越早，就可以承担更大的风险，也可以获得更大的收益（复利）。</code><br>⑦ <code>平衡策略，卖掉上涨快的优良资产，买入下跌或跑得慢的不良资产，以有纪律的投资来高抛低吸。</code><br>⑧ <code>人生有追求是一件多么幸福的事情。</code></p><h4 id="第六章-投资进阶-股市是财富的放大器-笔记-140"><a href="#第六章-投资进阶-股市是财富的放大器-笔记-140" class="headerlink" title="第六章  投资进阶(股市是财富的放大器)笔记(~140)"></a>第六章  投资进阶(股市是财富的放大器)笔记(~140)</h4><p>① <code>背景说明，在有一定积累之后，开始寻找新的投资方向(股市)。</code></p><p>01 父母花钱买了一套满意的房子，而作者借机套现了部分公积金30000元。<br>02 租房价格，物资快速上涨。<br>03 作者花大多数的时间来研究基金和股票，乐得悠闲。<br>04 作者前文言每月薪资5000左右，其实加上每月2300左右的公积金，作者月收入到7500左右且在三线城市工作和生活。<br>05 从作者的行文来看，感觉生活和工作方面的压力几乎没有，似乎也能体会到这份事业单位工作的优哉游哉。<br>06 请注意作者交待的背景条件：吃住在家里，月薪7500，还有几乎不可能的150%投资回报率。<br>07 综上 该书似乎并不具备太大现实的参考意义，但其对金钱的态度对理财的理解可以当成宝贵的经验。</p><p>② <code>事情从不同的角度来看，可以得到不同的答案。</code><br>③ <code>在股票市场的策略和选择</code></p><p>01 初始资金 19万 对资金进行切割，分成30%和70%份<br>02 策略 先使用30%的资金对选准的股票进行建仓，如果持续上涨则观望，如果下跌则分批使用70%的资金补仓。<br>03 逻辑<br>   ① 被众人抛弃或许价格就便宜<br>   ② 品牌没有那么容易被击垮<br>   ③ 消费群体依然不担心没有生机<br>   ④ 别人不要的我要</p><p>④ <code>股民体验为作者带来的改变（反思）</code></p><p>△ 理财理念逐渐建全，记账更加自然。<br>△ 消费观念逐渐改变，更看重消费的价值。<br>△ 任何事情留有余地，持有现金的人才能扭转乾坤。<br>△ 对生活有了新看法，企业就在我们伸手的地方。<br>△ 股市是生活的一部分，也只是一部分。</p><p>⑤ <code>理财-金钱-爱的关系 理财的目的不在于消费，而是为自己或者是家人提供一份物质前提。</code></p><p>光有钱，没有爱，那就只有跟孤独作伴；光有爱，没有钱，那爱熬不过贫寒。<br>有钱有爱，维持在一个相对合理的状态，既不会因为缺乏金钱 而阻碍双方的交流，也不会因为金钱过多而替代了爱的沟通。<br><strong>备注</strong>上面两句，是书中的原话。我猜想，三公子这个时候大概谈恋爱了。</p><p>⑥ <code>不同的阶段，需要有不同的理财规划(积累-投资-稳健投资)</code></p><p><strong>第一个阶段：财富准备阶段(学习)</strong><br>              该阶段应该以学习，提升业务水平和自身素养为主，金钱方面体现为攒钱。<br>              阶段：刚毕业工作<br>              现阶段不适宜盲目投资：<br>                01 资本太小滚不起来。<br>                02 阅历太浅，难有深刻认识。<br>                03 荒废主业，得不偿失。<br>            鸡汤：去学习，去读书，去锻炼技能，培养正确的理财观念，并守护好自己挣来的每一分钱。</p><p><strong>第二阶段：财富变质阶段(弹性提升)</strong><br>             现阶段应该从深处确定重仓取得一次8~10倍资产增值的机会。<br>             阶段：工作10年，有50万左右存款<br>             鸡汤：<br>                01 人这一辈子，不能就这么算了，不是吗？<br>                02 挺过去就是一片不同的天，挺不过去，这辈子就这样了。</p><p><strong>第三阶段：工作自由阶段(稳健)</strong><br>             现阶段应该以稳健投资为主，进行钱生钱的规模化操作。<br>             阶段：资产基数==300万左右<br>             说明：前两个阶段是典型的积累时期，应该努力的开源节流，开源可以更好的拓展财富积累领域，节流则让让我们理性消费，削减掉不必要的开支。</p><p><strong>第四阶段：财富自由阶段(安全-守成)</strong><br>总结：第一阶段努力学习，提升能力，积累第一桶金；第二阶段改变财务观念，进行合理的资产投资；第三阶段稳健为主，稳扎稳打；第四阶段安全第一，保护资产。</p><p>⑦ <code>时间和金钱同样宝贵，不仅在投资领域，在日常生活中也要好好珍惜。</code><br>⑧ <code>自己的财产|命运需要自己去掌控，不要盲从不要跟风更不要不懂装懂。</code></p><p><strong>“推荐阅读”</strong><br>    ① 记事本圆梦计划：为自己量身打造理想的人生金字塔 作者：熊谷正寿<br>    ② 小狗钱钱|财务自由之路                      作者：博多·舍费尔<br>    ③ 穷人缺什么                               作者：古古<br>    ④ 激荡三十年                               作者：吴晓波<br>    ⑤ 琼查理宝典                               建议：从整个人生的高度来讲述活着的意义<br>    ☺ ‘辐射阅读：利用一个核心点去寻找与之相关的其他好书。<br>    ☺ ‘成功人士的诸多优点：低调|勤勉|节俭|谨慎。<br>    ☺ ‘努力勤奋加上合理的投资可以让人拥有很好的生活。<br>    ☺ ‘成长，有时候会概念一个人对金钱的态度。</p><h4 id="第七章-投资反思-值得认真总结的新起点-笔记-170"><a href="#第七章-投资反思-值得认真总结的新起点-笔记-170" class="headerlink" title="第七章 投资反思(值得认真总结的新起点)笔记(~170)"></a>第七章 投资反思(值得认真总结的新起点)笔记(~170)</h4><p>① <code>理财投资让我们对金钱消费有了重新的认识。</code><br>② <code>挣钱的三种境界：用体力挣钱|用脑子挣钱|用钱挣钱。</code><br>③ <code>偏狭的理解一件事情，往往会让我们走向极端。</code></p><p>01 存款是备用资金的代名词。 |5W<br>02 存款是股票和基金市场的灭火器。<br>03 在熊市里，永远不要满仓。<br>04 基金和股市不是ATM机，如果不做好功课就贸然进场，很可能会血本无归。</p><p> ④ <code>富有标准难以制定，原因在于每个人的视野格局不同，以致对有钱人的认知不同。</code><br>⑤ <code>何以理解财务自由？&quot;财务&quot; + 自由?</code></p><p>01 ==&gt;在财务上得以解脱，能够真正追求热爱的事业，过自己想过的人生。<br>02 ==&gt;我们需要财务自由吗？<br>03 ==&gt;为何不直接跳过财务自由阶段，真实的追求事业？</p><p>⑥ <code>作者把自己理财方面的成绩归功于：极好的运气 + 父母提供的支援 + 自我的努力和克制。</code><br>⑦ <code>压抑太久的会爆发，疯狂太久的会崩塌。</code><br>⑧ <code>面对未来</code></p><p>01 对待市场，有敬畏之心。<br>02 对待盈利，有自知之明。<br>03 对待未来，要继续学习</p><h4 id="第八章-搭建属于自己的理财体系笔记-188"><a href="#第八章-搭建属于自己的理财体系笔记-188" class="headerlink" title="第八章  搭建属于自己的理财体系笔记(~188)"></a>第八章  搭建属于自己的理财体系笔记(~188)</h4><p>① <strong>作者在该篇章使用表格的方式完成了实现1000万资产目标的轨迹。</strong><br>       【1】了解自己的财务状况(存款|稳定的月收入|支出情况)<br>       【2】实现目标的轨迹 == (存款 + 稳定的输出 + 保持高回报率 + 时间)</p><p>② <strong>回报率的高低对资产的增值具有”指数级”的放大作用。</strong><br>③ <strong>72法则：本金增长2倍所需要的时间 = 72 ➗ 年复利收益率</strong></p><p>【ex】假设有10万元的本金，年复利收益率为8%，那么累计得到20万元资产需要花费 72 ➗ 8 = 9年</p><p>④ <strong>复利在创建财富奇迹的时候，还需要时间这个朋友。</strong><br> 只有耐心等待时光馈赠的人，才会真正得到财富的礼物，不要太过于浮躁。</p><p> ⑤ <strong>作者的理财之路总结</strong><br> <strong>历程</strong>：<code>攒钱 - 适当投资基金 - 投资股票</code><br> <strong>经验</strong>：<br>            01 克制消费，尊重并积攒每一分钱。<br>            02 基金和黄金定投，相当于是定期的存款。       20%<br>            03 大部分资金投放股市，追求高昂的投资收益率。  70%<br>            04 手握部分现金，面对可能出现的各种调整。      10%(5-5)</p><h4 id="第九章-豆邮精选笔记-212"><a href="#第九章-豆邮精选笔记-212" class="headerlink" title="第九章 豆邮精选笔记(~212)"></a>第九章 豆邮精选笔记(~212)</h4><p>① 理财的最终目的在于更好的梳理人生，几乎所有的财务问题都可以折射出当下的生活状态和职场态度。<br>② 环境糟糕时，精力都耗费在无谓斗争中；身处积极环境，命运会裹挟着你前进。<br>③ <code>人生的起航需要自备干粮</code>。<br>        <em>备注：</em> 193页小C的薪资应该为2400元，书中误为2300。<br>④ 一切好走的路都是下坡路。<br>⑤ 不要将职业定性为”自己卖命，公司发薪水”，磨难是礼物，时间和经理是宝贵的资本。<br>⑥ 年轻时候，最应该投资的就是我们自己，学问(‘深造’)和身体。<br>⑦ 没有规划的旅行，就好比家里的自来水龙头没有关，结果不是水漫金山就是水表疯狂旋转。<br>⑧ “没有预算，没有节制，没有结余的生活是可怕的。<br>⑨ 存不下钱的人往往有一个特点，就是永远搞不清楚自己每月花了多少钱。<br>⑩ 有梦想，有持久的梦想，有永不放弃的梦想，那么就会有源源不断的欲望和动力。<br>        <code>不要让自己的规划成为&quot;说说而已，笑笑即忘&quot;的聚会故事。</code></p><h4 id="第十章-理财，让梦想照进现实笔记-225"><a href="#第十章-理财，让梦想照进现实笔记-225" class="headerlink" title="第十章 理财，让梦想照进现实笔记(~225)"></a>第十章 理财，让梦想照进现实笔记(~225)</h4><p>① 金钱仅仅只是一个工具，你是怎样的人会决定金钱如何为你所用。<br>② 以其当赌徒，不如开赌场。<br>③ 时间很宝贵，不要为其他人而浪费，乔布斯的名言。<br>④ 金钱本不是绳索，但是金钱的匮乏却会让人变得胆小和害怕，变成束缚自己的绳索。<br>⑤ 金钱与创业|尊严|职场|梦想。<br>⑥ 长远的梦想需要慢慢实现，短期的目标需要马上开始。</p><h4 id="附录-全书结构图"><a href="#附录-全书结构图" class="headerlink" title="附录 全书结构图"></a>附录 全书结构图</h4><p><img src="https://github.com/flowerField/Source/blob/master/Blog/caifu.png?raw=true" alt="Alt text"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;* 作者 三公子&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 购书时间：2016年10月13日&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 开始时间：2016年10月20日&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 预计时间：15 * 30M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* [工作前5年，决定你一生的财富](https://book.douban.com/subject/26590267/)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 花费时间：6[20] + 3[21] + 2[23] + 1[24] + 4[25] == 16[6]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     说明：共花费16个30M，持续6天完成&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* Reading 杨也&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jQuery系列   [08]-jQuery框架Ajax模块</title>
    <link href="https://weibo.com/u/3800117445/2017/08/30/%E7%AC%AC%E5%85%AB%E7%AB%A0%20jQuery%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84Ajax%E6%A8%A1%E5%9D%97/"/>
    <id>https://weibo.com/u/3800117445/2017/08/30/第八章 jQuery框架中的Ajax模块/</id>
    <published>2017-08-30T08:57:03.000Z</published>
    <updated>2018-04-16T11:23:45.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="8-1-jQuery框架中的Ajax简介"><a href="#8-1-jQuery框架中的Ajax简介" class="headerlink" title="8.1 jQuery框架中的Ajax简介"></a>8.1 jQuery框架中的Ajax简介</h4><p><code>Ajax技术的核心是XMLHTTPRequest对象</code>，该对象是Ajax实现的关键，发送异步请求、接收服务器端的响应以及执行回调等操作都是通过XMLHTTPRequest对象来完成的。</p><p>jQuery框架对Ajax操作进行了封装，在jQuery框架的Ajax模块中提供了很多方法用于网络编程。我们主要从Ajax网络请求、Ajax事件以及序列化等方面讲解。</p><h4 id="8-2-jQuery框架中的Ajax网络请求"><a href="#8-2-jQuery框架中的Ajax网络请求" class="headerlink" title="8.2 jQuery框架中的Ajax网络请求"></a>8.2 jQuery框架中的Ajax网络请求</h4><a id="more"></a><p>jQuery框架中为我们提供的发送网络请求方法主要有：</p><ul><li>load方法</li><li>ajax方法</li><li>get方法</li><li>post方法</li><li>getScript方法</li><li>getJSON方法</li></ul><p><strong><code>① load方法</code></strong></p><p><code>语法</code> <code>jQ.load(url,[data],[callback])</code><br><code>参数</code></p><ul><li>url 资源的请求路径</li><li>data 发送请求时提交的参数，支持查询字符串和JSON对象格式</li><li>callback 加载完成的回调函数，3形参为：响应体 + 状态 + 请求对象</li></ul><p><code>说明</code>该方法请求远程的资源，并插入到选中的jQ实例对象中。</p><p><code>注意</code></p><ul><li>默认发送GET请求，如果传递参数(JSON对象)则发送POST请求。</li><li>支持对返回的数据进行筛选</li></ul><p><strong>代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 直接加载文件中的数据</span></div><div class="line"><span class="comment">//默认发送的是GET请求</span></div><div class="line"><span class="comment">//$("#demo").load("php/test.html");</span></div><div class="line"></div><div class="line"><span class="comment">//02 加载文件中的数据，获取其中的某一部分（进行筛选）</span></div><div class="line"><span class="comment">//$("#demo").load("php/test.html span");</span></div><div class="line"></div><div class="line"><span class="comment">//参数在请求体中进行传递</span></div><div class="line">$(<span class="string">"#demo"</span>).load(<span class="string">"php/test.html span"</span>,&#123;<span class="string">"namme"</span>:<span class="string">"zs"</span>&#125;);</div></pre></td></tr></table></figure></p><p><strong><code>② ajax方法</code></strong></p><p><code>语法</code> <code>$.ajax(url,[settings]) | $.ajax(settings)</code></p><p><code>常用参数说明</code></p><ul><li>url 资源的请求路径</li><li>data 发送请求时提交的参数，支持查询字符串和JSON对象格式</li><li>async 是否异步发送网络请求</li><li>cache 是否进行缓存处理</li><li>context 指定回调函数中的this指针</li><li>dataType 预期服务器返回的数据类型</li><li>timeout 请求的超时时间</li><li>beforeSend 请求发送前执行的回调函数</li><li>complete 请求完成后执行的回调函数</li><li>error 请求失败执行的回调函数</li><li>success 请求成功执行的回调函数</li></ul><p><code>说明</code>该方法是jQuery框架中最底层的Ajax实现，用于发送网络请求。<br><code>注意</code></p><ul><li>最简单的情况下，$.ajax()可以不带任何参数直接使用。</li><li>所有的选项都可以通过$.ajaxSetup()函数来进行全局设置。</li></ul><p><strong>代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">            <span class="string">"url"</span>:<span class="string">"php/03-ajax.php"</span>,  <span class="comment">//设置请求路径</span></div><div class="line">            <span class="string">"type"</span>:<span class="string">"get"</span>, <span class="comment">//设置请求方法，不区分大小写</span></div><div class="line">            <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res,status,xhr</span>) </span>&#123;  </div><div class="line">            <span class="comment">//请求成功的回调</span></div><div class="line">                $(<span class="string">"#demo"</span>).html(res); <span class="comment">//获取响应状态码</span></div><div class="line">                <span class="built_in">console</span>.log(status);  <span class="comment">//获取请求的状态</span></div><div class="line">                <span class="built_in">console</span>.log(xhr);     <span class="comment">//获取请求对象本身</span></div><div class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">//获取上下文</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"error"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">                <span class="comment">//请求失败的回调函数</span></div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"失败"</span>);</div><div class="line">                <span class="built_in">console</span>.log(res);</div><div class="line">            &#125;,  </div><div class="line">            <span class="comment">//"data":"name=ls"    //参数：查询字符串形式</span></div><div class="line">            <span class="string">"data"</span>:&#123;<span class="string">"name"</span>:<span class="string">"ls"</span>&#125;, <span class="comment">//参数：JSON对象形式</span></div><div class="line">            <span class="string">"timeout"</span>:<span class="number">10</span>，        <span class="comment">//设置请求超时的时间 </span></div><div class="line">            statusText：timeout</div><div class="line">            <span class="string">"context"</span>:obj,    <span class="comment">//设置回调函数中this的指向</span></div><div class="line">            <span class="string">"complete"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">"请求完成"</span>);</div><div class="line">                <span class="built_in">console</span>.log(res);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure></p><p><strong><code>③ get和post方法</code></strong></p><p><code>语法</code><br>    <code>[1]$.get(url,[data],[callback]，[type])</code><br>    <code>[2]$.post(url,[data],[callback]，[type])</code></p><p><code>参数</code></p><ul><li>url 资源的请求路径</li><li>data 发送请求时提交的参数</li><li>callback 请求成功的回调函数</li><li>type 服务器端返回内容的格式：包括xml、html、json、script等</li></ul><p><code>GET和POST对比</code></p><ul><li>GET请求参数跟在URL后，POST请求参数作为请求体发送。</li><li>GET请求对参数大小有限制，而POST请求理论上不受限制。</li><li>GET请求的数据会被浏览器缓存，存在严重的安全性问题。</li><li>服务器端读取数据的方式不同。在PHP中，区分为\$_GET和\$_POST。</li></ul><p><strong>代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//发送请求获取服务器返回的文本,把div的内容替换掉</span></div><div class="line"> <span class="comment">//第一个参数:url请求路径(必传)</span></div><div class="line"> <span class="comment">//第二个参数:参数 支持两种形式[查询字符串][JSON对象]</span></div><div class="line"> <span class="comment">//第三个参数:success(response,status,xhr)</span></div><div class="line"> <span class="comment">//         请求成功的回调</span></div><div class="line"> <span class="comment">//         response:服务器返回的响应体</span></div><div class="line"> <span class="comment">//         status:状态说明[success-error]</span></div><div class="line"> <span class="comment">//         xhr:请求对象</span></div><div class="line"> <span class="comment">//第四个参数:预期返回的数据类型:json|script|jsonP等</span></div><div class="line"> $.get(<span class="string">"php/03-get.php"</span>,&#123;<span class="string">"param1"</span>:<span class="string">"value1"</span>&#125;,</div><div class="line">     <span class="function"><span class="keyword">function</span> (<span class="params">response,status,xhr</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(response);</div><div class="line">     <span class="built_in">console</span>.log(status);</div><div class="line">     <span class="built_in">console</span>.log(xhr);</div><div class="line"> &#125;)</div><div class="line"><span class="comment">//注意点:GET请求请求路径一样会缓存,POST请求不会缓存</span></div><div class="line"> $.post(<span class="string">"php/04-post.php"</span>,&#123;<span class="string">"param1"</span>:<span class="string">"value1"</span>&#125;,</div><div class="line">     <span class="function"><span class="keyword">function</span> (<span class="params">response,status,xhr</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(response);</div><div class="line">     <span class="built_in">console</span>.log(status);</div><div class="line">     <span class="built_in">console</span>.log(xhr);</div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p><p><strong><code>④ getScript和getJson方法</code></strong></p><p>jQuery框架提供了getScript和getJson方法来直接加载js文件和JSON数据</p><p><code>语法</code></p><p><code>[1] $.getScript(url,[callBack])</code><br><code>[2] $.getJson(url,[callBack])</code></p><p><code>说明</code></p><ul><li>getScript方法用于加载js文件，并自动执行。</li><li>getJson方法用于加载JSON数据。</li></ul><p><strong>代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.getScript(<span class="string">"test.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> <span class="comment">//加载完成后执行的回调函数</span></div><div class="line">  alert(<span class="string">"加载并执行JS文件"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h4 id="8-3-jQuery框架中的Ajax事件方法"><a href="#8-3-jQuery框架中的Ajax事件方法" class="headerlink" title="8.3 jQuery框架中的Ajax事件方法"></a>8.3 jQuery框架中的Ajax事件方法</h4><p>jQuery框架中除了提供上述方法来发送网络请求外，还提供了一些事件方法来对调用Ajax方法过程中的HTTP请求进行精细控制。通过jQuery提供的一些自定义全局函数，能够为各种与Ajax相关的事件注册回调函数。jQuery的Ajax全局事件方法如下：</p><p><code>[1] ajaxStart(callBack)</code>  =&gt;检测到网络请求开始发送会触发，1次<br><code>[2] ajaxStop(callBack)</code>     =&gt;检测到网络请求结束会触发，1次<br><code>[3] ajaxSend(callBack)</code>  =&gt;检测到网络请求开始发送会触发，N次<br><code>[4] ajaxComplete(callBack)</code>=&gt;检测到网络请求结束会触发，N次<br><code>[5] ajaxError(callBack)</code> =&gt; 网络请求失败会触发<br><code>[6] ajaxSuccess(callBack)</code> =&gt; 网络请求成功会触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ajaxStart(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"第一个已经开始+++++"</span>);</div><div class="line">     $(<span class="string">"#demoID"</span>).show(<span class="number">1000</span>);</div><div class="line">&#125;)</div><div class="line">$(<span class="built_in">document</span>).ajaxStop(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"最后一个已经结束+++++"</span>);</div><div class="line">     $(<span class="string">"#demoID"</span>).hide(<span class="number">1000</span>);</div><div class="line">&#125;)</div><div class="line">$(<span class="built_in">document</span>).ajaxSend(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(<span class="string">"开始发送网络请求___"</span>);</div><div class="line">&#125;)</div><div class="line">$(<span class="built_in">document</span>).ajaxComplete(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"发送网络请求完成___"</span>);</div><div class="line">&#125;)</div><div class="line">$.ajax(&#123; <span class="comment">//发送网络请求--A</span></div><div class="line">    <span class="string">"url"</span>:<span class="string">"php/06-other.php"</span>,</div><div class="line">    <span class="string">"type"</span>:<span class="string">"GET"</span>,</div><div class="line">    <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res,status,xhr</span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">"网络请求成功--1"</span>);</div><div class="line">      &#125;</div><div class="line">&#125;)</div><div class="line">$.ajax(&#123;  <span class="comment">//发送网络请求--B</span></div><div class="line">    <span class="string">"url"</span>:<span class="string">"php/06-other.php"</span>,</div><div class="line">    <span class="string">"type"</span>:<span class="string">"GET"</span>,</div><div class="line">    <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res,status,xhr</span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">"网络请求成功--2"</span>);</div><div class="line">      &#125;</div><div class="line">&#125;)</div><div class="line">$(<span class="built_in">document</span>).ajaxError(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"请求失败"</span>);</div><div class="line">&#125;)</div><div class="line">$(<span class="built_in">document</span>).ajaxSuccess(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h4 id="8-4-jQuery框架中的序列化方法"><a href="#8-4-jQuery框架中的序列化方法" class="headerlink" title="8.4 jQuery框架中的序列化方法"></a>8.4 jQuery框架中的序列化方法</h4><p>在开发的时候，经常需要把表单中的数据作为网络请求的参数，如果一个一个的获取再拼接成查询字符串那么相当的麻烦，jQuery框架中为我们提供了两个对应的方法，可以方便解决该需求。</p><p><code>serialize方法</code>能够将DOM元素内容序列化为查询字符串。<br><code>serializeArray方法</code>可以将DOM元素序列化后返回JSON格式的数据。</p><p><strong>代码示例</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"demo1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"demo2"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    $(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        $.ajax(&#123;</span></div><div class="line"><span class="javascript">            <span class="string">"url"</span>:<span class="string">"php/07-get.php"</span>,</span></div><div class="line"><span class="javascript">            <span class="comment">//"data":"username="+$("#demo1").val()+"&amp;password=" +$("#demo2").val(),</span></span></div><div class="line"><span class="javascript">            <span class="string">"data"</span>:$(<span class="string">"form"</span>).serialize(),</span></div><div class="line"><span class="javascript">            <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span></div><div class="line"><span class="javascript">                <span class="built_in">console</span>.log(res);</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        &#125;)</span></div><div class="line"><span class="javascript">        <span class="comment">//把表单中的key-value按照固定的格式拼接为查询字符串:username=lisi&amp;password=abcd</span></span></div><div class="line"><span class="javascript">        <span class="built_in">console</span>.log($(<span class="string">"form"</span>).serialize());</span></div><div class="line"><span class="javascript">        <span class="built_in">console</span>.log($(<span class="string">"form"</span>).serializeArray());</span></div><div class="line"><span class="javascript">        <span class="comment">//[&#123;"username":"zhangsan"&#125;,&#123;"password":"123"&#125;];</span></span></div><div class="line"><span class="undefined">    &#125;)</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;8-1-jQuery框架中的Ajax简介&quot;&gt;&lt;a href=&quot;#8-1-jQuery框架中的Ajax简介&quot; class=&quot;headerlink&quot; title=&quot;8.1 jQuery框架中的Ajax简介&quot;&gt;&lt;/a&gt;8.1 jQuery框架中的Ajax简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Ajax技术的核心是XMLHTTPRequest对象&lt;/code&gt;，该对象是Ajax实现的关键，发送异步请求、接收服务器端的响应以及执行回调等操作都是通过XMLHTTPRequest对象来完成的。&lt;/p&gt;
&lt;p&gt;jQuery框架对Ajax操作进行了封装，在jQuery框架的Ajax模块中提供了很多方法用于网络编程。我们主要从Ajax网络请求、Ajax事件以及序列化等方面讲解。&lt;/p&gt;
&lt;h4 id=&quot;8-2-jQuery框架中的Ajax网络请求&quot;&gt;&lt;a href=&quot;#8-2-jQuery框架中的Ajax网络请求&quot; class=&quot;headerlink&quot; title=&quot;8.2 jQuery框架中的Ajax网络请求&quot;&gt;&lt;/a&gt;8.2 jQuery框架中的Ajax网络请求&lt;/h4&gt;
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="jQuery框架" scheme="https://weibo.com/u/3800117445/tags/jQuery%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>jQuery系列 [07]-jQuery框架DOM操作</title>
    <link href="https://weibo.com/u/3800117445/2017/08/20/%E7%AC%AC%E4%B8%83%E7%AB%A0%20jQuery%E6%A1%86%E6%9E%B6%E7%9A%84DOM%E6%93%8D%E4%BD%9C/"/>
    <id>https://weibo.com/u/3800117445/2017/08/20/第七章 jQuery框架的DOM操作/</id>
    <published>2017-08-20T04:05:39.000Z</published>
    <updated>2018-04-16T11:23:45.696Z</updated>
    
    <content type="html"><![CDATA[<p>jQuery框架继承和优化了JavaScript访问DOM对象的特性，我们使用jQuery框架提供的api可以更加方便的操作DOM对象。<br><a id="more"></a></p><h4 id="7-1-创建DOM节点"><a href="#7-1-创建DOM节点" class="headerlink" title="7.1 创建DOM节点"></a>7.1 创建DOM节点</h4><p>使用JavaScript原生方式创建DOM节点并添加到页面中的代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//01 创建DOM节点</span></div><div class="line"> <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line"> <span class="comment">//02 设置DOM节点的内容</span></div><div class="line"> oDiv.innerText = <span class="string">"测试的DIV标签"</span>;</div><div class="line"> <span class="comment">//03 把节点添加到页面中</span></div><div class="line"> <span class="built_in">document</span>.body.appendChild(oDiv);</div></pre></td></tr></table></figure></p><p>使用jQuery框架创建DOM节点并添加的代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 创建DOM节点</span></div><div class="line"> <span class="keyword">var</span> oDom = $(<span class="string">"&lt;div&gt;&lt;/div&gt;"</span>);</div><div class="line"> <span class="comment">//02 设置DOM节点的内容</span></div><div class="line"> oDom.text(<span class="string">"测试的div标签"</span>);</div><div class="line"> <span class="comment">//02 把DOM节点添加到页面中</span></div><div class="line"> $(<span class="string">"body"</span>).append(oDom);</div></pre></td></tr></table></figure></p><p>更简单的创建及添加方式：<br><code>$(&quot;body&quot;).append($(&quot;&lt;div&gt;我是测试的div标签&lt;/div&gt;&quot;));</code></p><p><strong>说明</strong></p><p>【1】jQuery框架简化了DOM操作，直接使用jQuery构造函数$()来创建标签，在创建标签的时候只需要把HTML字符串传递给函数，jQuery框架会根据参数的内容来创建标签并包装成一个jQ实例对象返回。</p><p>【2】要明白jQuery框架的DOM操作本身是对JavaScript原生方式进行的封装，所以相对原生的DOM操作而言<code>效率更低</code>。</p><h4 id="7-2-插入DOM节点"><a href="#7-2-插入DOM节点" class="headerlink" title="7.2 插入DOM节点"></a>7.2 插入DOM节点</h4><p>jQuery框架中提供了多个插入DOM节点的方法，我们可以通过调用这些方法方便的实现节点的插入操作。</p><p>在JavaScript原生的DOM操作中，我们通常使用<code>appendChild和insertBefore方法</code>来实现插入操作，下面的具体的代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;div&gt;我是div标签<span class="number">1</span>&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&lt;div&gt;我是div标签2&lt;/</span>div&gt;</div><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">    <span class="comment">//appendChild方法使用</span></div><div class="line">    <span class="comment">//01 创建p标签</span></div><div class="line">    <span class="keyword">var</span> oP = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</div><div class="line">    oP.innerHTML = <span class="string">"我是p标签"</span>;</div><div class="line"></div><div class="line">    <span class="comment">//02 获取页面中第一个div标签</span></div><div class="line">    <span class="keyword">var</span> oDiv1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">//03 使用appendChild方法添加</span></div><div class="line">    <span class="comment">//把p标签插入到oDiv1标签内容的后面</span></div><div class="line">    oDiv1.appendChild(oP);</div><div class="line"></div><div class="line">    <span class="comment">//insertBefore方法使用</span></div><div class="line">    <span class="keyword">var</span> oDiv2 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>)[<span class="number">1</span>];</div><div class="line">    <span class="comment">//把p标签插入到oDiv2标签内容的前面</span></div><div class="line">    oDiv2.insertBefore(oP,oDiv2.firstChild);</div><div class="line"></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>body&gt;</div></pre></td></tr></table></figure></p><p>jQuery框架中为我们提供了四个方法来提供对应的功能，它们分别是：<br><code>[1]append方法</code>:向每个匹配的元素内部追加内容。<br><code>[2]appendTo方法</code>：把所有匹配的元素追加到另一个指定的元素集合中，和append方法相反。<br><code>[3]prepend方法</code>:向每个匹配的元素内部前置内容。<br><code>[4]prependTo方法</code>：把所有匹配的元素前置到另一个指定的元素集合中，和append方法相反。</p><p><strong>插入方法的代码示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</div><div class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></div><div class="line"><span class="regexp">    &lt;script src="jQuery框架/</span>jquery<span class="number">-2.0</span><span class="number">.0</span>.js<span class="string">"&gt;&lt;/script&gt;</span></div><div class="line"><span class="string">&lt;/head&gt;</span></div><div class="line"><span class="string">&lt;body&gt;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&lt;div class="</span>cur<span class="string">"&gt;我是div1&lt;/div&gt;</span></div><div class="line"><span class="string">&lt;div&gt;我是div2&lt;/div&gt;</span></div><div class="line"><span class="string">&lt;div&gt;我是div3&lt;/div&gt;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&lt;ul&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;我是第1个li&lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;我是第2个li&lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;我是第3个li&lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;我是第4个li&lt;/li&gt;</span></div><div class="line"><span class="string">    &lt;li&gt;我是第5个li&lt;/li&gt;</span></div><div class="line"><span class="string">&lt;/ul&gt;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&lt;button&gt;按钮&lt;/button&gt;</span></div><div class="line"><span class="string">&lt;script&gt;</span></div><div class="line"><span class="string">    $(function () &#123;</span></div><div class="line"><span class="string">        $("</span>button<span class="string">").click(function () &#123;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">            //appendTo:把页面中所有的li标签都插入到所有的div标签内容的后面</span></div><div class="line"><span class="string">            //$("</span>li<span class="string">").appendTo($("</span>div<span class="string">"));</span></div><div class="line"><span class="string">            //append:把页面中所有的div标签都插入到所有的li标签内容的后面</span></div><div class="line"><span class="string">            //$("</span>li<span class="string">").append($("</span>div<span class="string">"));</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">            //prependTo:把页面中所有的li标签都插入到所有的div标签内容的前面</span></div><div class="line"><span class="string">            //$("</span>li<span class="string">").prependTo($("</span>div<span class="string">"));</span></div><div class="line"><span class="string">            //prepend:把页面中所有的div标签都插入到所有的li标签内容的前面</span></div><div class="line"><span class="string">            //$("</span>li<span class="string">").prepend($("</span>div<span class="string">"));</span></div><div class="line"><span class="string">        &#125;)</span></div><div class="line"><span class="string">    &#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">&lt;/script&gt;</span></div><div class="line"><span class="string">&lt;/body&gt;</span></div><div class="line"><span class="string">&lt;/html&gt;</span></div></pre></td></tr></table></figure></p><p>jQuery框架中还提供了多个外部插入内容的方法，它们分别是：<br><code>[1]after方法</code>：在每个匹配的元素之后插入内容。<br><code>[2]before方法</code>：在每个匹配的元素之前插入内容。<br><code>[3]insertAfter方法</code>：把所有匹配的元素插入到另一个指定的元素集合的后面。<br><code>[4]insertBefore方法</code>：把所有匹配的元素插入到另一个指定的元素集合的前面。</p><h4 id="7-3-删除DOM节点"><a href="#7-3-删除DOM节点" class="headerlink" title="7.3 删除DOM节点"></a>7.3 删除DOM节点</h4><p>JavaScript原生的DOM操作中可以使用removeChild方法来删除指定的节点以及其包含的所有子节点，并返回这些删除的内容。</p><p>jQuery框架中定义了3个删除内容的方法：它们分别是remove（）、empty（）和detach（）。</p><p><code>remove方法</code>能够将匹配的元素从DOM中删除。<br><code>empty方法</code>用来清空元素包含的内容，该方法没有参数。<br><code>detach方法</code>能够将匹配的元素从DOM中分离出来。</p><p><strong>注意</strong></p><p>[1] 删除和清空是两个概念，清空操作执行后该标签还存在。</p><p>[2] detach方法和remove方法差不多，但detach方法能够保存所有jQuery数据与被移走的元素相关联，所有绑定在元素上的事件、附加的数据等都会保存下来。如果您在移走一个元素不久后，又需要将该元素重新插入DOM，那么推荐使用detach方法。</p><h4 id="7-4-复制和替换DOM节点"><a href="#7-4-复制和替换DOM节点" class="headerlink" title="7.4 复制和替换DOM节点"></a>7.4 复制和替换DOM节点</h4><p><strong>① 节点的复制</strong></p><p>在JavaScript原生方式操作DOM节点时，可以使用cloneNode方法来复制节点，具体的语法如下：</p><p>语法：<code>nodeObject.cloneNode(include_all)</code><br>参数：</p><p>include_all参数本身为布尔类型的值。</p><ul><li>如果为true，那么将会复制原有的节点以及所有的子节点。</li><li>如果为false，那么紧紧复制节点本身。</li></ul><p>jQuery框架中，使用clones方法来复制节点，具体的语法如下：</p><p>语法：<code>jQ.clone（[widthDataAndEvents]，[deepWithDataAndEvents]）</code><br>参数：<br>    clone方法的两个参数都是可选的布尔值，如果不传递则默认全部为false。</p><ul><li>widthDataAndEvents参数表示是否复制该节点的事件处理数据。</li><li>deepWithDataAndEvents参数表示是否复制子元素的事件处理数据。</li></ul><p><strong>② 节点的替换</strong></p><p>在原生的DOM操作中，可以使用replaceChild方法来替换节点。<br>语法：<code>nodeObject.replaceChild(new_node,old_node)</code><br>参数说明：new_node为指定的新节点，old_node为被替换的节点。如果替换成功，那么会返回被替换的节点，如果替换失败，那么会返回null。</p><p>jQuery框架中定义了replaceWith和replaceAll方法来替换节点。</p><p><strong><code>[1] replaceWith方法</code></strong></p><p>语法：<code>jQ.replaceWith（newContent）</code><br>说明：replaceWith方法能够将所有匹配的元素都替换成指定的HTML或者是DOM元素。<br>示例：<code>$(&quot;p&quot;).replaceWith(&quot;&lt;div&gt;我是DIV标签&lt;div&gt;&quot;)</code></p><p><strong><code>[2] replaceAll方法</code></strong></p><p>语法：<code>jQ.replaceAll(selector)</code><br>说明：replaceAll方法和replaceWith是一对相反的操作。</p><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jQuery框架继承和优化了JavaScript访问DOM对象的特性，我们使用jQuery框架提供的api可以更加方便的操作DOM对象。&lt;br&gt;
    
    </summary>
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端开发技术" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    
      <category term="jQuery框架" scheme="https://weibo.com/u/3800117445/tags/jQuery%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
