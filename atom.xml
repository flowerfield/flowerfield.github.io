<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花田半亩</title>
  
  <subtitle>文顶顶的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weibo.com/u/3800117445/"/>
  <updated>2018-09-24T15:47:46.375Z</updated>
  <id>https://weibo.com/u/3800117445/</id>
  
  <author>
    <name>文顶顶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序序列[09]-小程序中的基础组件(二)</title>
    <link href="https://weibo.com/u/3800117445/2018/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%5B09%5D-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6(%E4%BA%8C)/"/>
    <id>https://weibo.com/u/3800117445/2018/09/20/微信小程序系列[09]-小程序中的基础组件(二)/</id>
    <published>2018-09-19T16:00:09.000Z</published>
    <updated>2018-09-24T15:47:46.375Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍小程序中的基础组件，主要包括button、input等组件的基本使用和代码示例。</p></blockquote><h4 id="1-0-button组件"><a href="#1-0-button组件" class="headerlink" title="1.0 button组件"></a>1.0 button组件</h4><p>小程序中的<a href="https://developers.weixin.qq.com/miniprogram/dev/component/button.html" target="_blank" rel="external">button组件</a>就是按钮。</p><p><strong>这里列出button组件的主要属性</strong><br><span class="propWX-green bg-red">open-type</span>    微信开放能力。<br><span class="propWX-green bg-red">size</span>    按钮的大小，默认值为default，还能取值mini。<br><span class="propWX-green ">plain</span>     设置按钮是否镂空，布尔类型的值，默认为false。<br><span class="propWX-green bg-red">disabled</span>    是否禁用按钮，布尔类型的值，默认为false。<br><span class="propWX-green">loading</span>    名称的前面是否设置加载icon,默认为false。<br><span class="propWX-green bg-red">form-type</span>    用来触发form表单中的submit和reset事件。<br><span class="propWX-green">hover-class</span>    按钮被按下的样式类，none表示没有任何效果。<br><span class="propWX-green">hover-start-time</span>    按钮被按下多久出现点击态，默认为20毫秒。<br><span class="propWX-green">hover-stay-time</span>    手指松开按钮点击态的保留时间，默认为70毫秒。<br><span class="propWX-green bg-red">type</span>  按钮的样式类型，默认值为default，还能取值primary和warn。<br><span class="propWX-green">session-from</span>    会话来源，open-type=<code>&quot;contact&quot;</code>时生效。<br><span class="propWX-green">bindcontact</span>    客服消息回调，open-type=<code>&quot;contact&quot;</code>时生效。<br><span class="propWX-green">binderror</span>    使用开放能力时失败的回调，open-type=<code>&quot;launchApp&quot;</code>时生效。<br><span class="propWX-green">bindopensetting</span>    打开授权设置页面的回调，open-type=<code>&quot;openSetting&quot;</code>时生效。<br><span class="propWX-green">bindgetphonenumber</span>    获取用户手机号码回调，open-type=<code>&quot;getPhoneNumber&quot;</code>时生效。<br><span class="propWX-green">bindgetuserinfo</span>    点击时用户信息在detail中返回，open-type=<code>&quot;getUserInfo&quot;</code>时生效。<br><span class="propWX-green">app-parameter</span>    打开app时向app传递的参数，open-type=<code>&quot;launchApp&quot;</code>时生效。<br><span class="propWX-green">lang</span>    指定返回的用户信息的语言，open-type=<code>&quot;getUserInfo&quot;</code>时生效。<br><span class="propWX-green">send-message-title</span>    会话内消息卡片标题，open-type=<code>&quot;contact&quot;</code>时生效。<br><span class="propWX-green">send-message-img</span>    会话内消息卡片图片，open-type=<code>&quot;contact&quot;</code>时生效。<br><span class="propWX-green">show-message-card</span>    显示会话内消息卡片默认为false，open-type=<code>&quot;contact&quot;</code>时生效。<br><span class="propWX-green">send-message-path</span>    会话内消息卡片点击跳转小程序路径，open-type=<code>&quot;contact&quot;</code>时生效。</p><p><strong>open-type微信开放能力属性取值说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cotact        打开客服会话。</div><div class="line">openSetting打开授权设置页。</div><div class="line">share        触发用户转发，使用前建议先阅读使用指引。</div><div class="line">feedback打开“意见反馈”页面，用户可提交反馈内容并上传日志。</div><div class="line">getUserInfo获取用户信息，可以从bindgetuserinfo回调中获取到用户信息。</div><div class="line">launchApp打开APP，可以通过app-parameter属性设定向APP传的参数具体说明。</div><div class="line">getPhoneNumber获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，具体说明。</div></pre></td></tr></table></figure></p><p>我们重点关注button组件非开放能力相关的属性，关于开放能力的相关知识点可以查询官方文档，这里给出button组件使用的代码示例。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//wxml文件中的内容</div><div class="line"><span class="comment">&lt;!-- 1.0 演示按钮的基本使用 --&gt;</span></div><div class="line"><span class="comment">&lt;!-- 001 type属性对比  取值为：defalut(默认白色) warn(红色) primary(绿色) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">'defalut'</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">'warn'</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">'primary'</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 002 size属性：设置按钮的大小 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">'mini'</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 003 plain属性：设置按钮是否镂空显示 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">plain</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 004 disabled属性：设置禁用按钮 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disabled</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 005 loading属性：文字前面是否显示icon，布尔类型的值，默认不显示 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">loading</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 006 form-type属性：设置表单中的submit和reset --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">bindsubmit</span>=<span class="string">'submitClick'</span> <span class="attr">bindreset</span>=<span class="string">'resetClick'</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">placeholder</span>=<span class="string">'请输入用户名'</span> <span class="attr">name</span>=<span class="string">'usrname'</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span><span class="attr">placeholder</span>=<span class="string">'请输入密码'</span> <span class="attr">name</span>=<span class="string">'password'</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">form-type</span>=<span class="string">'submit'</span>&gt;</span>提交表单的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">form-type</span>=<span class="string">'reset'</span>&gt;</span>重置表单的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 007 hover-class属性：设置按钮按下去的样式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">hover-class</span>=<span class="string">'btn-hover'</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 008 部分开放能力属性测试 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">'contact'</span> <span class="attr">bindcontact</span>=<span class="string">'testClick'</span>&gt;</span>开放能力打开客服会话<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">'getPhoneNumber'</span></span></div><div class="line"><span class="tag"><span class="attr">bindgetphonenumber</span>=<span class="string">"getPhoneNumberClick"</span>&gt;</span></div><div class="line">开放能力获取用户的手机号码</div><div class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line">//js文件中的内容</div><div class="line">Page(&#123;</div><div class="line">  submitClick:function(e)&#123;</div><div class="line">    console.log("点击了表单的提交按钮",e);</div><div class="line">  &#125;,</div><div class="line">  resetClick: function (e) &#123;</div><div class="line">    console.log("点击了表单的重置按钮",e);</div><div class="line">  &#125;,</div><div class="line">  testClick:function(e)&#123;</div><div class="line">      console.log("打开客服会话",e);</div><div class="line">    &#125;,</div><div class="line">    getPhoneNumberClick:function()&#123;</div><div class="line">      console.log("获取用户的电话号码",e);</div><div class="line">    &#125;</div><div class="line"> &#125;);</div><div class="line"></div><div class="line">//wxss文件中的内容</div><div class="line">.btn-hover</div><div class="line">&#123;</div><div class="line">  background: #110e1e;</div><div class="line">  color: #fff;</div><div class="line">  font-size: 20rpx;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="2-0-input组件"><a href="#2-0-input组件" class="headerlink" title="2.0 input组件"></a>2.0 input组件</h4><p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html" target="_blank" rel="external">input组件</a>就是输入框，主要用来处理用户的输入和数据修改等操作。</p><p><strong>这里列出input组件的主要属性</strong></p><p><span class="propWX-green bg-red">type</span> 输入框的类型。<br><span class="propWX-green ">disabled</span>      输入框是否禁用。<br><span class="propWX-green bg-red">value</span>    输入框的初始内容。<br><span class="propWX-green ">password</span>     输入框是密码类型的。<br><span class="propWX-green ">placeholder-style    </span>     指定placeholder的样式。<br><span class="propWX-green ">placeholder-class</span>     指定placeholder的样式类。<br><span class="propWX-green bg-red">placeholder</span>     输入框为空的时候显示的占位字符。<br><span class="propWX-green ">maxlength</span>     输入框的最大输入长度，设置为-1表示没有限制默认为140。<br><span class="propWX-green bg-red">confirm-type</span>     弹出键盘的右下角的文字，默认为done，type为text时生效。<br><span class="propWX-green ">confirm-hold</span>     点击键盘右下角按钮时是否保持键盘不收起。<br><span class="propWX-green ">adjust-position</span>     键盘弹起时，是否自动上推页面,默认值为true。<br><span class="propWX-green ">focus</span>     获取焦点。<br><span class="propWX-green ">cursor</span>     指定focus时的光标位置。<br><span class="propWX-green ">selection-start</span>     光标起始位置，自动聚集时有效，需与selection-end搭配使用。<br><span class="propWX-green ">selection-end</span>     光标结束位置，自动聚集时有效，需与selection-start搭配使用。<br><span class="propWX-green bg-red">bindfocus</span>     输入框聚焦时触发。<br><span class="propWX-green ">bindblur</span>     输入框失去焦点时触发。<br><span class="propWX-green bg-red">bindconfirm</span>     点击完成按钮时触发。<br><span class="propWX-green ">bindinput</span>     键盘输入时触发，处理函数能直接return替换输入框的内容。</p><p><strong>特定属性的取值情况说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">type属性的取值可以是下面的四种情况，分别对应弹出不同类型的键盘。</div><div class="line">text文本输入键盘</div><div class="line">number数字输入键盘</div><div class="line">idcard身份证输入键盘</div><div class="line">digit带小数点的数字键盘</div><div class="line"></div><div class="line">confirm-type属性的有效值有下面五种，其最终表现与手机输入法本身的实现有关。</div><div class="line">send右下角按钮为“发送”</div><div class="line">search右下角按钮为“搜索”</div><div class="line">next右下角按钮为“下一个”</div><div class="line">go右下角按钮为“前往”</div><div class="line">done右下角按钮为“完成”</div></pre></td></tr></table></figure></p><p><strong>这里给出input标签使用的示例代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//wxml文件内容</div><div class="line">&lt;!-- 1.0 测试type属性，有效值为text  number idcard digit --&gt;</div><div class="line">&lt;input type=&apos;text&apos; placeholder=&apos;我是文本输入框&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input type=&apos;number&apos; placeholder=&apos;我是弹出数字键盘&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input type=&apos;idcard&apos; placeholder=&apos;我弹出身份证键盘&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input type=&apos;digit&apos; placeholder=&apos;我弹出小数键盘&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 2.0 测试confirm-type属性：有效值为send search next go done --&gt;</div><div class="line">&lt;input confirm-type=&apos;send&apos; placeholder=&apos;键盘右下角的文字为send-发送&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input confirm-type=&apos;search&apos; placeholder=&apos;键盘右下角的文字为search-搜索&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input confirm-type=&apos;next&apos; placeholder=&apos;键盘右下角的文字为next-下一项&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input confirm-type=&apos;go&apos; placeholder=&apos;键盘右下角的文字为go-前往&apos;&gt;&lt;/input&gt;</div><div class="line">&lt;input confirm-type=&apos;done&apos; placeholder=&apos;键盘右下角的文字为done-完成&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 3.0 测试value属性：控制输入框的初始值 --&gt;</div><div class="line">&lt;input value=&apos;我是该输入框的初始值&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 4.0 测试disabled属性：控制输入框是否禁用 --&gt;</div><div class="line">&lt;input disabled placeholder=&apos;禁用输入框&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 5.0 测试placeholder-style：给占位的文本设置样式 --&gt;</div><div class="line">&lt;input placeholder-style=&apos;color:red;&apos; placeholder=&apos;我是占位的文本&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 6.0 测试maxlength：限制输入框的最大长度 --&gt;</div><div class="line">&lt;input maxlength=&quot;10&quot; placeholder=&apos;最多只能输入10个字符&apos;&gt;&lt;/input&gt;</div><div class="line"></div><div class="line">&lt;!-- 7.0 测试事件 --&gt;</div><div class="line">&lt;input</div><div class="line">bindfocus=&apos;onbindfocus&apos;</div><div class="line">bindblur=&apos;onbindblur&apos;</div><div class="line">bindinput=&apos;onbindinput&apos;</div><div class="line">bindconfirm=&apos;onbindconfirm&apos;</div><div class="line">placeholder=&apos;输入框获取焦点的时候出发&apos;&gt;</div><div class="line">&lt;/input&gt;</div><div class="line"></div><div class="line">//js文件的内容</div><div class="line">Page(&#123;</div><div class="line">  onbindfocus:function(e)&#123;</div><div class="line">    console.log(&quot;onbindfocus-获得焦点&quot;,e);</div><div class="line">  &#125;,</div><div class="line">  onbindblur: function (e) &#123;</div><div class="line">    console.log(&quot;onbindblur-失去焦点&quot;, e);</div><div class="line">  &#125;,</div><div class="line">  onbindconfirm: function (e) &#123;</div><div class="line">    console.log(&quot;onbindconfirm-点击完成(键盘右下角)&quot;, e);</div><div class="line">  &#125;,</div><div class="line">  onbindinput: function (e) &#123;</div><div class="line">    console.log(&quot;onbindinput-监听到键盘输入&quot;, e);</div><div class="line">  &#125;&#125;);</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍小程序中的基础组件，主要包括button、input等组件的基本使用和代码示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-0-button组件&quot;&gt;&lt;a href=&quot;#1-0-button组件&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="微信小程序序列" scheme="https://weibo.com/u/3800117445/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序序列[03]-小程序开发(主体文件)</title>
    <link href="https://weibo.com/u/3800117445/2018/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%5B03%5D-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E4%B8%BB%E4%BD%93%E6%96%87%E4%BB%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/09/20/微信小程序系列[03]-小程序框架主体文件/</id>
    <published>2018-09-19T16:00:02.000Z</published>
    <updated>2018-09-21T08:46:39.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍开发微信小程序项目中的主体文件，这些文件的作用，以及具体的配置字段。</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx04.png?raw=true"></p><h3 id="1-0-配置文件-app-json"><a href="#1-0-配置文件-app-json" class="headerlink" title="1.0 配置文件(app.json)"></a>1.0 配置文件(app.json)</h3><h4 id="app-json文件说明"><a href="#app-json文件说明" class="headerlink" title="app.json文件说明"></a>app.json文件说明</h4><p>该文件是小程序的配置文件，编写的时候需要严格遵循json的格式规范(关于JSON的知识点请参考<a href="http://wendingding.com/2018/04/16/javaScript%E7%B3%BB%E5%88%97%20[05]-javaScript%E5%92%8CJSON/" target="_blank" rel="external">javaScript系列 [05]-javaScript和JSON</a>)，在程序加载的时候负责对小程序的全局进行配置，配置项如下：</p><p>☑︎ <span style="color:#f50">page</span>:设置页面路径。<br>◻︎ <span style="color:#f50">tabBar</span>:设置tab的表现。<br>◻︎ <span style="color:#f50">window</span>:设置默认页面的窗口表现。<br>◻︎ <span style="color:#f50">networkTimeout</span>:设置网络超时时间。<br>◻︎ <span style="color:#f50">debug</span>:设置是否开启debug模式，可选项为true或false，默认关闭。</p><p>列出app.json文件内容的整体结构<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"pages"</span>:[],</div><div class="line">  <span class="attr">"window"</span>:&#123;&#125;,</div><div class="line">  <span class="attr">"tabBar"</span>:&#123;&#125;,</div><div class="line">  <span class="attr">"networkTimeout"</span>:&#123;&#125;,</div><div class="line">  <span class="attr">"debug"</span>:<span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="pages配置项"><a href="#pages配置项" class="headerlink" title="pages配置项"></a>pages配置项</h4><p>pages配置选项负责注册小程序的页面，是必须要填写的，当我们使用开发工具来创建页面的时候默认会自动生成对应的配置信息。</p><p>pages配置项的value值是一个包含多有页面路径的数组，用来指定小程序由哪些页面构成，其中每一项均有“<code>路径+文件名</code>”组成，下面给出示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="attr">"pages"</span>: [</div><div class="line">  <span class="string">"pages/home/home"</span>,</div><div class="line">  <span class="string">"pages/cart/cart"</span>,</div><div class="line">  <span class="string">"pages/category/category"</span>,</div><div class="line">  <span class="string">"pages/mine/mine"</span>,</div><div class="line">  <span class="string">"pages/index/index"</span>,</div><div class="line">  <span class="string">"pages/logs/logs"</span>,</div><div class="line">  <span class="string">"pages/login/login"</span>,</div><div class="line">  <span class="string">"component/wdd-component/block/index"</span>,</div><div class="line">  <span class="string">"pages/mine/coupon/coupon"</span>,</div><div class="line">  <span class="string">"component/wdd-component/addresscard/index"</span></div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><div class="tip"><br>说明：pages配置项中的第一个元素(上面为home)默认为小程序的首页，路径中不需要填写文件后缀名，渲染页面的时候框架会自动寻找路径并把同名的.json、.wxml、.wxss和.js文件进行整合。<br></div><h4 id="window配置项"><a href="#window配置项" class="headerlink" title="window配置项"></a>window配置项</h4><p>window配置项负责设置小程序<span style="color:"#195"">状态栏、导航条、标题、窗口背景色等系统级样式。</span></p><p><span class="propWX">navigationBarBackgroundColor</span>    导航栏背景颜色     [<code>HexColor类型</code>]<br><span class="propWX">navigationBarTextStyle</span>          导航栏标题颜色     [<code>String类型</code>],black或white(默认)<br><span class="propWX">navigationBarTitleText</span>          导航栏标题文字内容  [<code>String类型</code>]<br><span class="propWX">navigationStyle</span>                    导航栏样式         [<code>String类型</code>]，default(默认)或custom<br><span class="propWX">backgroundColor</span>                  窗口的背景色       [<code>HexColor类型</code>]<br><span class="propWX">backgroundTextStyle</span>              下拉加载的样式     [<code>String类型</code>]，dark(默认)和light<br><span class="propWX">backgroundColorTop    </span>           顶部窗口的背景色    [<code>HexColor类型</code>]     ，仅 iOS 支持<br><span class="propWX">backgroundColorBottom</span>            底部窗口的背景色    [<code>HexColor类型</code>]     ，仅 iOS 支持<br><span class="propWX">enablePullDownRefresh</span>            全局开启下拉刷新    [<code>Boolean类型值</code>]，true和false(默认)<br><span class="propWX">onReachBottomDistance</span>            上拉触底事件触发时距底部距离 [<code>Number类型</code>]，默认值为50px</p><p>这里给出一个小程序项目中的window配置项示例<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"window"</span>: &#123;</div><div class="line">    <span class="attr">"backgroundTextStyle"</span>: <span class="string">"light"</span>,</div><div class="line">    <span class="attr">"navigationBarBackgroundColor"</span>: <span class="string">"#000"</span>,</div><div class="line">    <span class="attr">"navigationBarTitleText"</span>: <span class="string">"文顶顶的小程序"</span>,</div><div class="line">    <span class="attr">"navigationBarTextStyle"</span>: <span class="string">"white"</span>,</div><div class="line">    <span class="attr">"backgroundColor"</span>: <span class="string">"#eeeeee"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="tabBar配置项"><a href="#tabBar配置项" class="headerlink" title="tabBar配置项"></a>tabBar配置项</h4><p><strong><code>tabBar配置项</code></strong> 用于设置小程序中的tabBar选项卡，在商业小程序中使用频率很高。tabBar配置项的可配置属性如下：</p><p>☑︎ <span class="propWX-green">color</span>                   tab 上的文字默认颜色[<code>HexColor类型</code>]<br>☑︎ <span class="propWX-green">selectedColor</span>         tab 上的文字选中时的颜色[<code>HexColor类型</code>]<br>☑︎ <span class="propWX-green">backgroundColor</span>         tab 的背景色[<code>HexColor类型</code>]<br>◻︎ <span class="propWX-green">borderStyle</span>             tabbar上边框的颜色， 仅支持 black / white(默认)<br>◻︎ <span class="propWX-green">position</span>                 tabBar的位置，仅支持 bottom / top[<code>String类型</code>]<br>☑︎ <span class="propWX-green">list</span>                     tab 的列表最少2个、最多5个元素[<code>Array类型</code>]</p><p><strong><code>list配置项</code></strong> 中的每一项都应该是一个对象，代表着一个tab的相关配置。list配置项的课配置属性如下：<br>☑︎ <span class="propWX-green">text    </span>            tab 上按钮文字<br>☑︎ <span class="propWX-green">pagePath</span>            页面路径，必须在 pages 中先定义<br>◻︎ <span class="propWX-green">iconPath</span>            图片的相对路径，icon 大小限制为40kb，不支持网络图片。<br>◻︎ <span class="propWX-green">selectedIconPath</span>    选中时的图片相对路径，icon 大小限制为40kb，不支持网络图片。</p><p>这里给出一个小程序项目中的tabBar配置项的示例和最终显示结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"tabBar"</span>: &#123;</div><div class="line">    <span class="attr">"selectedColor"</span>: <span class="string">"#000000"</span>,</div><div class="line">    <span class="attr">"list"</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"pagePath"</span>: <span class="string">"pages/home/home"</span>,</div><div class="line">        <span class="attr">"text"</span>: <span class="string">"首页"</span>,</div><div class="line">        <span class="attr">"iconPath"</span>: <span class="string">"img/tabbar/home.png"</span>,</div><div class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"img/tabbar/homeSelected.png"</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"pagePath"</span>: <span class="string">"pages/login/login"</span>,</div><div class="line">        <span class="attr">"text"</span>: <span class="string">"分类"</span>,</div><div class="line">        <span class="attr">"iconPath"</span>: <span class="string">"img/tabbar/category.png"</span>,</div><div class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"img/tabbar/categorySelected.png"</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"pagePath"</span>: <span class="string">"pages/cart/cart"</span>,</div><div class="line">        <span class="attr">"text"</span>: <span class="string">"购物车"</span>,</div><div class="line">        <span class="attr">"iconPath"</span>: <span class="string">"img/tabbar/cart.png"</span>,</div><div class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"img/tabbar/cartSelected.png"</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">"pagePath"</span>: <span class="string">"pages/mine/mine"</span>,</div><div class="line">        <span class="attr">"text"</span>: <span class="string">"我的"</span>,</div><div class="line">        <span class="attr">"iconPath"</span>: <span class="string">"img/tabbar/mine.png"</span>,</div><div class="line">        <span class="attr">"selectedIconPath"</span>: <span class="string">"img/tabbar/mineSelected.png"</span></div><div class="line">      &#125; ]</div><div class="line">  &#125;&#125;</div></pre></td></tr></table></figure><p>上面配置项的显示效果如下图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/wx05.png?raw=true" width="450px"></p><div></div><h4 id="请求超时和debug模式"><a href="#请求超时和debug模式" class="headerlink" title="请求超时和debug模式"></a>请求超时和debug模式</h4><p><strong><code>networkTimeout</code></strong>用于控制小程序中所有网络请求的超时时间(只能通过该配置项统一的配置)。</p><p><strong><code>debug配置项</code></strong>用于控制是否开启debug模式，默认情况下是关闭的，当debug模式设置为true之后在开发者工具的控制面板，所有的调试信息将以info的形式输。</p><div class="tip">说明：需要注意全局配置文件和页面配置文件的关系，当路由到对应页面的时候，页面配置文件的配置项将会覆盖全局配置</div><h3 id="2-0-逻辑控制文件-app-js"><a href="#2-0-逻辑控制文件-app-js" class="headerlink" title="2.0 逻辑控制文件(app.js)"></a>2.0 逻辑控制文件(app.js)</h3><p>app.js是小程序的整体逻辑控制文件，在该文件中通过<span style="color:#f82">App()函数</span>来注册小程序的生命周期函数、全局方法和全局属性，而且已经注册的小程序实例可以在其他的逻辑层代码中通过getApp()函数获取。</p><strong>App()函数用于注册一个微信小程序。</strong><br><strong>App()函数必须在app.js中注册，且不能注册多个。</strong><br><strong>App()函数的Object参数对象主要包括<code>生命周期函数</code>和其它数据，生命周期函数用于程序监听。</strong><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx06.png?raw=true"></p><p><strong>生命周期函数说明</strong></p><p>当启动一个微信小程序的时候，会首先依次触发<code>onLaunch</code>和<code>onShow方法</code>，然后通过app.json配置文件中的pages配置项来注册相应的页面，最后根据默认路径加载首页。当用户点击关闭标签或点击了设备的Home按钮离开微信的时候小程序并不会直接销毁，而是进入后台，这两种情况都会触发<code>onHide方法</code>，当再次打开微信小程序的时候会触发<code>onShow方法</code>。当小程序进入后台一定时间或者系统资源占用过高的时候会被真正的销毁。</p><p>注册小程序的示例代码(该代码可以在app.js文件通过敲入<code>App + Tab键</code>的方式生成)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">App(&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onLaunch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 当小程序启动，或从后台进入前台显示，会触发 onShow</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShow: <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;&#125;,</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 当小程序从前台进入后台，会触发 onHide</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onHide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onError: <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;&#125;,</div><div class="line">  otherDate:<span class="string">'存放其他数据'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="3-0-全局样式文件-app-wxss"><a href="#3-0-全局样式文件-app-wxss" class="headerlink" title="3.0 全局样式文件(app.wxss)"></a>3.0 全局样式文件(app.wxss)</h3><p>WXSS是小程序基于CSS拓展的一套样式语言，它实现了CSS大部分规则。<br><strong>app.wxss是全局样式表，对项目中每个页面都有效</strong>，可以将一些系统级别的样式统一写入到该文件中。</p><div class="tip">注意：页面在渲染的时候，页面中的.wxss文件样式会覆盖app.wxss中相同的选择器样式。</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍开发微信小程序项目中的主体文件，这些文件的作用，以及具体的配置字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog
      
    
    </summary>
    
    
      <category term="微信小程序序列" scheme="https://weibo.com/u/3800117445/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序序列[02]-小程序开发(框架体系)</title>
    <link href="https://weibo.com/u/3800117445/2018/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%5B02%5D-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
    <id>https://weibo.com/u/3800117445/2018/09/20/微信小程序系列[02]-小程序框架文件体系/</id>
    <published>2018-09-19T16:00:01.000Z</published>
    <updated>2018-09-24T03:55:33.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍开发微信小程序项目中的体系结构和组成部分。</p></blockquote><h4 id="1-0-微信小程序框架体系"><a href="#1-0-微信小程序框架体系" class="headerlink" title="1.0 微信小程序框架体系"></a>1.0 微信小程序框架体系</h4><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx03.png?raw=true" height="300px"></p><p>微信小程序框架体系由两部分组成，分别是视图层和逻辑层。</p><p>视图层由<code>WXML</code>和<code>WXSS</code>组成，类似于前端开发中的HTML(标签)和CSS(样式)。</p><p>逻辑层是一套运行在本地JavaScript引擎中的JavaScript代码，负责调用数据处理方法来驱动视图更新。</p><p>微信小程序的整体开发流程非常接近前端<span style="color:#195">HTML + CSS + JavaScript</span>的模式,需要注意的是在小程序开发中没有DOM的概念的，本地也没有document和window等对象，更不能使用jQuery等类似的框架。</p><p>微信小程序中视图层和逻辑层的交互主要通过数据绑定和事件响应来实现，采用了单向绑定的机制。</p><p><strong>微信小程序的单向绑定机制</strong></p><p><span style="color:#f40">单向绑定机制需要先将逻辑层和视图层的数据与事件进行绑定，当页面需要修改的时候，逻辑层只需要调用特定的setData方法修改已经绑定的数据即可，这时候框架会自动触发WXML来重新渲染整个视图，当框架接收到用户的交互操作时会根据视图层绑定的事件执行逻辑层中对应的事件函数以进行响应</span>。</p><h4 id="2-0-微信小程序的结构"><a href="#2-0-微信小程序的结构" class="headerlink" title="2.0 微信小程序的结构"></a>2.0 微信小程序的结构</h4><p>微信小程序的开发工具下载并安装之后，我们可以来开始创建一个新的项目，如果没有appID那么可以选择使用测试账号。</p><p>项目初始化完成后，我们能够看到下面的界面。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx02.png?raw=true" height="300px"></p><p>整个开发界面大概可以分成工具选项区、模拟器显示区、调试区、代码目录和工作区，其中工作区、模拟器显示区和调试区均可以选择在关闭在打开中进行切换，这里我们主要关注项目初始化后的代码目录。</p><p>打印项目文件的目录结构(使用命令行操作，具体请参考<a href="http://wendingding.com/2018/04/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20Mac%E7%B3%BB%E7%BB%9F%E4%B8%ADTree%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">网络编程系列 Mac系统中Tree的使用</a>)如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── app.js</div><div class="line">├── app.json</div><div class="line">├── app.wxss</div><div class="line">├── pages</div><div class="line">│   ├── index</div><div class="line">│   │   ├── index.js</div><div class="line">│   │   ├── index.wxml</div><div class="line">│   │   └── index.wxss</div><div class="line">│   └── logs</div><div class="line">│       ├── logs.js</div><div class="line">│       ├── logs.json</div><div class="line">│       ├── logs.wxml</div><div class="line">│       └── logs.wxss</div><div class="line">├── project.config.json</div><div class="line">└── utils</div><div class="line">    └── util.js</div></pre></td></tr></table></figure><p>在一个完成的小程序项目中，所有的文件可以划分为<strong><code>小程序框架主体文件</code></strong>和<strong><code>页面文件</code></strong>两类。</p><p><strong>① 小程序框架主体文件</strong>是系统级文件，每个项目中只有一份，他们分别是：</p><pre>  app.js文件      控制小程序整体逻辑，主要用于注册小程序全局实例。  app.json文件    控制小程序整体配置，配置小程序整体设置。  app.wxss文件    控制小程序整体样式，对所有页面的布局文件都有效。  project.config.json文件     整个项目的配置信息</pre><p><strong>② 页面文件</strong> 通常由四个文件组成，分别是<span style="color:#195">.wxml（结构）.wxss（样式）.js（逻辑）和.json（配置）</span>。框架规定，同一个页面的这四个文件必须具有相同的路径和文件名，在编译的时候它们将自动关联。在初始化后的项目中，pages文件夹下面拥有两个默认的页面，分别是index页面和logs页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍开发微信小程序项目中的体系结构和组成部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-0-微信小程序框架体系&quot;&gt;&lt;a href=&quot;#1-0-微信小程序框架体系&quot; class=&quot;headerlink&quot; title=&quot;1.0 微信
      
    
    </summary>
    
    
      <category term="微信小程序序列" scheme="https://weibo.com/u/3800117445/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序序列[01]-小程序开发(注册)</title>
    <link href="https://weibo.com/u/3800117445/2018/09/20/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%B3%BB%E5%88%97%5B01%5D-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E6%AD%A5/"/>
    <id>https://weibo.com/u/3800117445/2018/09/20/微信小程序系列[01]-小程序初步/</id>
    <published>2018-09-19T16:00:00.000Z</published>
    <updated>2018-09-20T07:10:18.126Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍在开发微信小程序需要的初步知识。</p></blockquote><h3 id="1-0-简单说明"><a href="#1-0-简单说明" class="headerlink" title="1.0 简单说明"></a>1.0 简单说明</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx.png?raw=true" height="200px"></p><p>微信小程序于2016年9月21日内测。</p><p>微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p>微信小程序是一种不需要下载安装就可以使用的应用，它实现了应用触手可及的梦想，用户只需要使用微信扫一扫或者简单搜索即可安装和使用，而且能够”用完就走”。</p><p>微信小程序本身采用了类似于React Native和Weex一样的解析技术，开发者能够编写一套代码在多端(移动端和浏览器)运行，同时相比公众号的H5应用而言小程序又具备更好的原生体验。</p><p>微信小程序与订阅号、服务号和企业号是并行的体系，具有独立的注册、发布流程，在正式开发小程序之前需要先在<a href="mp.weixin.qq.com">微信公众平台上面注册</a>。</p><h3 id="2-0-小程序的注册和开发的基本流程"><a href="#2-0-小程序的注册和开发的基本流程" class="headerlink" title="2.0 小程序的注册和开发的基本流程"></a>2.0 小程序的注册和开发的基本流程</h3><p><strong>注册范围</strong></p><p><span style="color:#19f">个人</span>：由自然人注册和运营的公众帐号。<br><span style="color:#19f">媒体</span>：报纸、杂志、电视、电台、通讯社、其他等。<br><span style="color:#19f">其他</span>：不属于政府、媒体、企业或个人的类型。<br><span style="color:#19f">企业</span>：企业、分支机构、个体工商户、企业相关品牌。<br><span style="color:#19f">政府</span>：国内、各级、各类政府机构、事业单位(ex 公安、党团、司法、交通机构)等。</p><p><strong>基本流程</strong></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wx01.png?raw=true"></p><p><strong><code>[001] 注册</code></strong></p><p>  <strong>1.填写账号信息</strong> 具体信息包括邮箱[没有被公众号 &amp; 开放平台 &amp; 个人微信绑定] 密码 验证码 勾选协议。</p><p>  <strong>2.邮箱激活说明</strong> 注册之后需要进入注册时使用的邮箱查看邮件，并激活公众平台帐号。</p><p>  <strong>3.用户信息登记</strong> 该步骤需要确认你的微信公众帐号主体类型，并请按照对应的类别进行信息登记。</p><p>  政府、媒体、其他组织类型帐号，必须通过微信认证验证主体身份。</p><p>  企业类型帐号需要通过公司的对公账户向腾讯公司打款来验证或者通过微信认证验证主体身份并支付300元认证费。</p><p>  个人类型账号需要的信息主要有：<br>   <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[a] 身份证姓名(信息审核成功后身份证姓名不可修改)</div><div class="line">[b] 身份证号码(一个身份证号码只能注册5个小程序)</div><div class="line">[c] 管理员手机(需要短信验证)</div><div class="line">[d] 管理员身份验证（使用管理员本人的微信来扫描二维码，成为管理员后需合法、合理地谨慎操作..）</div></pre></td></tr></table></figure></p><p><strong><code>[002] 完善信息</code></strong></p><p>  进入到小程序首页后，查看小程序发布流程，填写小程序相关的信息。</p><p>  需要填写的主要信息包括：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">小程序的名称(30字以内)   ex: 用于演示的Demo</div><div class="line">小程序的头像(小于2MB 建议png格式)</div><div class="line">小程序的介绍(120内)</div><div class="line">正确选择小程序的服务类目，有餐饮、生活服务、体育、快递与邮政业等。</div></pre></td></tr></table></figure></p><p><strong><code>[003] 开发微信小程序</code></strong></p><p>  注册成功后，进入到开发首页，选择普通小程序开发者工具下载对应的开发工具安装。</p><p>  如果是多人合作开发请添加并配置相关的开发者成员。</p><p>  绑定开发者说明：<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（1）个人主体小程序最多可绑定5个开发者，10个体验者。</div><div class="line">（2）未认证的组织类型小程序最多可绑定10个开发者，20个体验者。</div><div class="line">（3）已认证的小程序最多可绑定20个开发者，40个体验者。</div></pre></td></tr></table></figure></p><p>  获取AppID:<code>进入“设置-开发设置”，获取AppID信息</code></p><p><strong><code>[004] 版本发布</code></strong></p><p>  需要先提交代码，然后提交审核，审核通过后发布。      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍在开发微信小程序需要的初步知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-0-简单说明&quot;&gt;&lt;a href=&quot;#1-0-简单说明&quot; class=&quot;headerlink&quot; title=&quot;1.0 简单说明&quot;&gt;&lt;/a&gt;1.0 简单说
      
    
    </summary>
    
    
      <category term="微信小程序序列" scheme="https://weibo.com/u/3800117445/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [013]-寻找无双</title>
    <link href="https://weibo.com/u/3800117445/2018/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B013%5D-%E5%AF%BB%E6%89%BE%E6%97%A0%E5%8F%8C/"/>
    <id>https://weibo.com/u/3800117445/2018/09/01/读书笔记 [013]-寻找无双/</id>
    <published>2018-08-31T16:11:18.000Z</published>
    <updated>2018-09-21T08:46:34.856Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：寻找无双这本书很多年前就看过了，在我老家的书柜里还存放着两套全新的王小波全集，前段时间刚巧在体育中心新华书店看到了十月文艺出版社出版的精装版本，遂又买了其中的“寻找无双”领回家中重读，还是当年的味道，却也有很多东西不同了。这篇文章将分成两个部分，一为我自己的碎碎念，一为原著的碎片摘写。</div><div style="color:#195; font-size:20px">※·※ 碎碎念 ※·※</div><p>我喜欢阅读，更喜欢买书。</p><p>这样的习惯持续了很多年，因为早期能接触到的书很少，所以我喜欢对一本书反复阅读，因着这层原因我竟发现很多书读一遍和读N遍其体会很不一样。很多年过去了，朋友们也都一个个三十而立，周遭保持阅读的人似乎越来越少，其实我也一样。而且现在不比从前，以前也没有太多的钱用来买书，往往拿到一本喜欢的新书后可能半天甚至一天就读完，现在我常常的是买的多，读的少，甚至很多书买来后从来不读。</p><p>这有很多的原因。</p><p>脱离了学生的身份，生活压力开始变大，个人的空间和时间被压缩这些都是客观事实。更深层的原因是我也很难再找到一本自己喜欢的书，可能是个人胃口实在刁钻吧。</p><p>今天回头来看，我早已记不清楚是什么开始接触王小波老师的。</p><p>也许是高中的时候，更或许更早一些（我接触的第一本课外书是钱钟书先生的围城没上初中）。</p><p>王小波的作品给我带来很多说不清的东西，不论是黄金时代还是绿毛水怪或者其它。在阅读时我获得了很多了乐趣和思考，也有幸接触到了其它大师的一些作品，这里说声感谢。</p><div style="color:#195; font-size:20px">※·※ 寻找无双 ※·※</div><div style="color:#F45; font-size:18px">※·※ 第一章 ※·※</div><p>建元年间，王仙客到长安城里找无双，据他自己说，无双是这副模样：矮矮的个子，圆圆的脸，穿着半截袖子的小褂子和半截裤管的半短裤，手脚都被太阳晒得黝黑，眉毛稀稀拉拉的。头上梳了两把小刷子，脚下蹬了一双塌拉板，走到哪里都是哗啦啦的响。就这个样子而言，可以说是莫辨男女。</p><p>王仙客在宣阳坊里打听无双时，人人都说没见过。</p><p>王仙客到宣阳坊找无双，宣阳坊是个大院子，周围围着三丈高的土坯墙。</p><p>王仙客说，以前他在宣阳坊里住过。</p><p>王仙客长了一个大个子，穿一身柞蚕丝的白袍子，粉白的面孔，<span class="propT">飘飘然有神仙之姿</span>。宣阳坊里的各位君子一见到他，就有似曾相识之感，但却想不起他的名字。这王仙客也确实可疑，他说来找无双，但是却找不到无双的家门口。他说坊中间的空院子就是无双原来的家，但是那个院子人人都知道，是个废了的尼姑庵。</p><p>大家又告诉他说，可能你记错了地方。也许令表妹不住在宣阳坊，而是在别的坊。您要知道，长安城里七十二坊，有好几个外表一模一样。听了这些话，王仙客自己也说，很可能记错了，骑上马到别的坊里去找了。王仙客初次在宣阳坊找无双，情形就是这样。宣阳坊里的各位君子后来提起这件事，是这么说的：三句话就把那小子打发走了；感觉很是痛快。</p><p>王仙客到宣阳坊里找无双，来过许多次。</p><p>后来王仙客就在宣阳坊里住下来，寻访无双的下落。他又向所有的人打听无双，并且说，那位无双不但是他的表妹，而且他们还有婚姻之约。这次他从山东来，带来了金一提，银一驮，作为聘礼，要把无双接回山东去。</p><p>其实大伙都不想理睬王仙客，知道他不是自己人；但是见他打赢了官司，也都有点害怕。</p><p><span style="color:#f23">虽然不是个废尼庵，却是个废道观。</span></p><p>王仙客住在宣阳坊的客栈里，这个客栈就在那所空院子对面。不管别人怎么说，他都不相信那是个空道观。因为那所院子既不像尼庵，也不像道观，就像个官宦人家住的院子。除此之外，他还千真万确的记得，无双家就住在这里，不在别的地方。</p><p>王仙客住在空院子对面的的客栈里，要了一间楼上的房子，从窗户里看那院子。这里离那院子隔了一条大街，而且空院子的房上长了很高的荒草，所以看不大的确。他就跑到波斯人的铺子里买了一架单眼望远镜来。当时的望远镜技术不过关，看到的景象是倒的。所以他就在房梁上拴上绳子，捆住了脚，头朝下的看。但是房顶上的草还是要挡住视线，所以他又去买了一些兔子，把它们扔到空院子的房上。兔子在房上下不来，就把草都吃掉了。经过了这些努力，他终于可以像看眼前的景物一样看到那个空院子了。但是那些兔子有公有母，在房顶上繁殖起来，并且始终不能下地，最后成了很大的灾害。它们在房顶上跑来跑去，吃光了瓦房上的茅草和瓦松，就吃草房上的房草，还在房上打洞筑巢。</p><p>这一切又在宣阳坊里引起了很大的骚乱，但是<span style="color:#195">王安老爹对此却毫无办法，因为这个王仙客很有钱</span>。</p><p>王安老爹说，创世之初，世间就有两种人存在。一种人是我们，另一种是奸党。到了大唐建元年间，世上还有两种人存在，一种人依旧是我们，另一种依旧是奸党。这是老爹的金玉良言。到了今天，世上仍然有两种人，一种还是我们，另一种还是奸党。</p><p>他从山东跋山涉水来到这里，吃了无数的苦，花了无数的钱，到最后连要找的人是谁都出了问题。</p><p>王仙客觉得最奇怪的是他和这位鱼玄机没有任何关系，别人却不厌其烦地把她的事讲给他听。这个故事有头有尾，却没有中段。</p><p>宣阳坊里的罗老板大约有五十岁，长得很富态。年轻时读过几本书，人也很文静。他给王仙客讲这些故事时，一手托着三络长髯，另一手用两根手指捏着茶杯的手柄，这个样子当得起四个字：不辱斯文。虽然他是个商人，但王仙客对他颇有亲近之感。也是因为这个原因，王仙客觉得他的话格外可信。除此之外，罗老板还说，我告诉你的话都是我亲眼所见，耳闻的我不说。</p><p>那辆车是一队白羊拉的小四轮车，车上铺了一块鲜红的猩猩毡。鱼玄机斜躺在毡上，衣着如前所述，披散着万缕青丝，一手托腮，嘴角叼了一朵山茶花，一付若有所思的模样。脸上虽然没有血色，却更显得人如粉雕玉琢，楚楚可怜。鱼玄机上法场时就是这个模样。在三绞毕命之前，鱼玄机走上台子，用手向后撩起头发，让刽子手往她脖子上系绞索。那时候她还笑着对刽子手说：呆会儿可别太使劲了。我的脖子是很细的哟！</p><p><span style="color:#195">鱼玄机的手十指纤长，指甲涂丹；长发委地，光可鉴人，十分好看。</span></p><p>仙姑，人间法度。</p><p>大家都以为他走了再不会回来，谁知他出尔反尔，去了半年又跑回来。不但如此，他还大发雷霆，说宣阳坊里住了一窝骗子。原来他不知从哪里打听出来，鱼玄机已经死了整整二十年了，而他和无双分手，不过是没几年的事。所以他就有了个怪念头，说是鱼玄机死了以后，无双一家才搬到那院子里去。</p><p>王仙客到了宣阳坊里，马上就知道无双很难找到。因为有了这样的思想准备，一时找不到无双不会让他气馁。与他相比，宣阳坊里的各位君子对他会旷日持久地找下去却缺少思想准备。</p><div style="color:#F45; font-size:18px">※·※ 第二章 ※·※</div><p>王仙客到长安城去找无双那一年，正好是二十五岁。</p><p>人在二十五岁时，什么事情都想干，但是往往一事无成。</p><p>后来王仙客找到了处死鱼玄机的刽子手，请他去喝酒。那时候他还急于找到无双，忙于印刷寻人张贴，和黑社会联络，向京城的巡检司行贿，忙了个四脚朝天。</p><p>事情办完后，双手抽筋，请了好几天假，少杀了好几个人。这是不小的损失，因为刽子手拿的是计件工资。</p><p>这是因为只要有一点钱，死刑犯都要雇一伙刽子手来杀自己。假如没钱，只好由公家的刽子手来杀了。<span style="color:#f34">那些人杀人挣不到钱，就不好好杀</span>。有时候半天杀不死，有时候杀得乱七八糟，砍头时砍到脚面上。其实每个刽子手都是两样买卖都干的，只是干公家刽子手时，管犯人叫贼子、死囚等等，还要动手打人。当私人刽子手时，管犯人叫东家，也不动手打。</p><p><span style="color:#520">但是鱼玄机却兴高彩烈，说道：再过一会儿就要死了，可真不容易呀</span>。</p><p>只要她身上还有值一文钱的东西，就永不得安生，因为中国人有盗墓的习惯，还因为偷死人的东西最安全。</p><p>梦醒了以后，他有好一阵子若有所思，觉得这个梦非同凡响。最后他想了起来，鱼玄机管她的使女叫彩萍，她的使女的确是叫彩萍。而无双的使女也叫彩萍。鱼玄机和无双的近似之处原来是这样的呀。</p><p>王仙客去找无双时，只有二十五岁。人在那个年龄虽然聪明，却不能达练人情，难免要碰钉子。</p><p>他到宣阳坊找无双，听别人讲了一阵鱼玄机，自己都不知自己要找谁了。假如他达练人情，就不会轻易相信别人的话。</p><p>王仙客在宣阳坊，所持仗的就是自己的智慧。可惜的是，他的智慧解决不了眼前的问题。</p><div style="color:#F45; font-size:18px">※·※ 第三章 ※·※</div><p>宣阳坊里各位君子对王仙客有如下结论：他是个来历不明的色鬼，流氓，丧门星。</p><p>王仙客到宣阳坊里来时，正是初春。转眼间，他就呆了六个月了，已经到了秋季。过去没人见过他，他要找的人也没人认识；他的生殖器像公驴一样；他对牛粪的态度也很反常。有关第一点，人们说，谁知他是从哪里跑来的。有关第二点，人们说，我要是有女儿，情愿打死了喂狗，也不嫁给他。有关第三点，人们说，这家伙一看就是个油瓶子倒了也不知道扶的公子哥儿。</p><p>他们根本就不懂什么叫公子哥儿，公子哥儿还管点多少灯油吗？就算是自己买灯油，他也记不住熄灯。</p><p>现在我是一个至诚君子，当年却是个尖刻、恶毒的中学生，阴毒有如妇人，不肯放弃任何一个叫人难过的机会。</p><p>可怕的是，这样的事不仅仅是梦，好像以前真的干过。</p><p>总而言之，鱼玄机本身就是个凄婉的梦，充满了色情和暴力。王仙客受到了吸引，就逐渐迷失在其中。</p><p>王仙客到长安来时，带来了一驮银子，到了那年的秋天，那一驮银子已经花完了，连驮银子的骡子也卖了。他整天在房子里围着被子冥思苦想，不知不觉钱都花光了，马也卖了。等到没了钱，孙老板就叫来了王安老爹，把他撵了出去，这时候他明白了自己要找的东西是什么：既不是无双，也不是鱼玄机，而是买一碗阳春面充饥的钱。</p><p>我们北京人有句老话说，有什么都别有病，没什么都别没钱。这的确是至理明言。</p><p>先是被人说成鱼玄机的老相好，搞得精神崩溃；后来又发现一文不名，简直要饿死了。幸亏这两种悲惨处境是不兼容的：精神崩溃的人总是有一点钱，一点钱没有的人不会精神崩溃。</p><div style="color:#F45; font-size:18px">※·※ 第四章 ※·※</div><p>小时候我常做这样的梦，先是梦到了洪水猛兽，吓得要命。猛然想起自己是睡着了的，就从梦里惊醒。后来又遇到了洪水猛兽，又吓得要了命。仔细一想，自己还是没有真醒，或者是又睡了，就又醒一回。</p><p>王仙客被撵出宣阳坊时，身上一文不名，而且恍恍惚惚。时值秋末冬初，天相当冷。所以很让人耽心他会冻饿而死。但是他很平安地过了冬，而且到了第二年，体重还有八十多公斤。这件事情告诉我们，千万不要低估了人适应各种环境的能力。</p><p>女主人说，难得这么体面的一条汉子，要是肯来当王八就好了。她们都想嫁给他。</p><p>王仙客长得很体面，飘飘然有神仙之姿。虽然穷得要饭，身上的衣服却是干干净净。除此之外，他的嘴又特别甜，见了窑子里的姑娘，不管她长得什么样，总是要说：你真漂亮！我都要晕倒了。当时不知有多少妓女要为他自杀，但是王仙客并没有当王八。</p><p>王仙客挣了一些钱后，他就从妓女家里搬了出来，自己租房子住。偶尔还到妓女家里打打杂，但是不再是为了谋生，而是为了拉交情。</p><p>王仙客在宣阳坊被人看成了色鬼，公子哥儿，来历不明的家伙，声明狼籍。但是在酉阳坊里就没人说他坏话。因为这里住的都是些坏蛋，就显得他道德清高。他在这里不但发了财，而且找到她了。</p><p>王仙客坐在四面拉门中间，就像午夜里站到了十字路口，有四个月亮从四条路上照来。</p><p>梦具有一种荒诞的真实性，而真实有一种真实的荒诞性。除了这种感觉上的差异，他说不出这两者之间有什么区别。</p><p>他大叫一声道：原来你是彩萍！我可找到你了。</p><p>王仙客虽然找到了彩萍，但是无双还是下落不明。原来就在王仙客回山东去了没多久，长安就闹了一场兵乱。无双一家人到城外躲难，走到城门口，正遇上叛军攻城，加上地痞流氓趁乱起哄，那里就乱成了一锅粥。那时候彩萍和无双家失散了，等到乱定后再去找，那一大家人就变得无影无踪。不但找不到人，连街坊都不承认有这家人。这件事真是古怪得很。</p><p>就我所知，人多了也能成为很大的灾害，丝毫不在兔子的灾害之下；当然我这样说不是想发起什么灭人的斗争——这种斗争只有大人物才能发动起来((⊙o⊙)…  这影射文革的呢噢)。</p><p>他挣这样的钱，也是有原因的。他还要再回宣阳坊，找到无双。要干这样的事，没有很多钱是不行的。要干这样的事，没有彩萍也不成。现在虽然有了钱，又有了彩萍，还需要一个计划。而想好一个计划，就需要很多时间。</p><div style="color:#F45; font-size:18px">※·※ 第五章 ※·※</div><p>鱼玄机伏法那一天，长安城里的人听说要把她勒死，就把一切都扔下跑来看。罗老板当然也在其中。后来他说鱼玄机死时视死如归等等，其实全是他在犯腻歪。鱼玄机从车上下来时两腿如筛糠，几乎站不住了。她哆哆嗦嗦地对刽子手说：怎么来了这么多人看我死！都和我有仇吗？我什么时候得罪了这么多人？</p><p>有关那一天刑场上人多，可以这样形容，真正达到了万人空巷，挥汗成雨。</p><p>根据这些事实，罗老板告诉王仙客的事情不对，那天长安街头没有绞死一个视死如归的大美人，倒是勒死了一个哆哆嗦嗦的灰眼睛姑娘。</p><p>从前孟夫子说：人之所以异于禽兽者，几稀。几稀不是没有。在我看来，稀就稀在有认罪伏法的态度这一点上。因此我认为一般来说，骂人是不对的。但是也不能一概而论，这和到了什么时候大有关系。假如到了那会儿，就真是不骂白不骂了。</p><div style="color:#F45; font-size:18px">※·※ 第六章 ※·※</div><p>建元年间，王仙客和彩萍到宣阳坊里找无双，和单独来时大不一样。</p><p>王仙客第二次到宣阳坊找无双，他知道宣阳坊是恨人有笑人无的地方。</p><p>王仙客现在阔了，但是却没人恨他。因为他太阔，恨起来恐怕要把自己气死了，只能找个软一点的来恨恨。假如我著作等身，就要得诺贝尔文学奖，也就没人来恨我。</p><p>据说监狱里的狱官和刽子手订有协定，前者给后者介绍了生意，大家五五分成。</p><p>王仙客进了这个院子，发现里面空空如也。窗户纸全破了，门窗上的油漆全剥落了，房子里的东西全都没有了。只剩下正房里孤伶伶一把太师椅。这件家具虽然孤单，但是寓意深远。这是因为别的家具都可以搬走，安放在其它地方，只有它不能安放在其它地方。当时的人相信，一家之主的坐位，放到别的地方就会闹鬼。</p><p>要知道，现在人心不古，世道浇漓，什么人都有。</p><p>这件事说到头就是一句话，王仙客太有钱了，叫人害怕。</p><p>王仙客搬到宣阳坊半个月，房上的兔子已经非常少了。偶尔还能看见一只，总是蹲在房顶上最高的地方一动不动，就像白天的猫头鹰一样。那些兔子的危险来自天上，但是它们老往地下看。</p><p>鱼玄机在临终时骂起人来，这样很不雅。但是假设有人用绳子勒你脖子，你会有何感触呢？是什么就说什么，是一件需要极大勇气的事；但是假定你生来就很乖，后来又当了模范犯人，你会说什么呢？我们经常感到有一些话早该有人讲出来，但始终不见有人讲。我想，这大概是因为少了一个合适的人去受三绞毕命之刑罢。</p> <div style="color:#F45; font-size:18px">※·※ 第七章 ※·※</div><p>王仙客和彩萍在宣阳里找无双，我认为宣阳坊是个古怪地方，这里的事情谁都说不太准，就好像爱丽丝漫游奇境，谁知走到下一步会出什么事。但是王仙客不这样想。王仙客觉得一切都有成竹在胸。他住进宣阳坊那座大宅子里，觉得日子过得飞快。寻找无双的过程，就像蚂蚁通过迷宫。开头时，仿佛有很多的岔路，每一条路都是艰巨的选择。首先，他要确定自己是不是醒着，其次要确定无双是不是存在，最后则是决定到哪里找无双。现在这些问题都解决了，只剩下了最后一个问题：无双到哪儿去了。</p><p>假如你是一只猪，生活在暗无天日的猪圈里，就会把在吃猪食看作极大的幸福，因此忘掉早晚要挨一刀。所以猪的记性是被逼成这样子的，不能说是天生的不好。</p><p>要是您能证明她是骗子，我一定送她去打板子。打坏了不就是掏点医疗费吗？就是把屁股打没了，要装金屁股，咱也掏得起。<br>那一年叛军逃走后，长安正是七月流火，天气很热。</p><p>。皇帝听说了和见到了这种情况，觉得把长安七十二坊都洗荡一遍不划算。他就下了一道圣旨：其余七十一坊，只要交出占人口总数百分之五的附逆分子，就准许他们投降。但是官员不按此百分比计算。凡是城陷时身在城内的官员，有一个算一个，都是附逆分子。</p><p>王仙客住在宣阳坊，布下了疑阵，等待别人自己上门告诉他无双的事。等了半个月，只来了一个老爹。老爹只说彩萍是假无双，却没说出谁是真无双。王仙客对老爹原来就没抱很大期望，因此也没很失望。</p><p>王仙客去宣阳坊找无双，自己装成了大富翁，并把彩萍打扮得奇形怪状。这就好比我知道这次分房子没有我，就剃个大秃头，穿上旗袍出席分房会。这样也可能找到无双，也可能找不到；也可能分到了房子，也可能分不到。不管怎么说，假如事情没了指望，就可以胡搅它一下，没准搅出个指望来。王仙客的举动堪称天才，我的举动就不值这么高的评价，因为我抄袭了医学的故智。在我们医院里，假如有人死掉，心脏不跳了，就用电流刺激他的心脏。这样他可能活过来，于是刺激就收到了起死回生之效；当然他也可能继续死去，这也没什么，顶多把死因从病死改做电死。王仙客在法拉第之前就知道用强刺激法去治别人的记性，实在是全体王姓一族的光荣。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.516it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.5it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：寻找无双这本书很多年前就看过了，在我老家的书柜里还存放着两套全新的王小波全集，前段时间刚巧在体育中心新华书店看到了十月文艺出版社出版的精装版本，遂又买了其中的“寻找无双”领回家中重读，还是当年的味道，却也有很多东西不同了。这篇文章将分成两个部
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jQuery系列 [10]-jQuery框架源码解读[结构]</title>
    <link href="https://weibo.com/u/3800117445/2018/08/24/jQuery%E7%B3%BB%E5%88%97%20%5B10%5D-jQuery%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5B%E7%BB%93%E6%9E%84%5D/"/>
    <id>https://weibo.com/u/3800117445/2018/08/24/jQuery系列 [10]-jQuery框架源码解读[结构]/</id>
    <published>2018-08-24T10:01:02.000Z</published>
    <updated>2018-08-24T15:36:23.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章将主要介绍jQuery框架的前600行代码并说明jQuery框架的整体结构。</p></blockquote><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>这里先简单贴出jQuery框架3.3.1版本中的前600行代码，其它和整体结构无关的部分省略了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> * jQuery JavaScript Library v3<span class="number">.3</span><span class="number">.1</span></div><div class="line"> * https:<span class="comment">//jquery.com/                  官网地址</span></div><div class="line"> *</div><div class="line"> * Includes Sizzle.js</div><div class="line"> * https:<span class="comment">//sizzlejs.com/                核心选择器</span></div><div class="line"> *</div><div class="line"> * Copyright JS Foundation and other contributors</div><div class="line"> * Released under the MIT license    开源协议</div><div class="line"> * https:<span class="comment">//jquery.org/license           开源协议地址</span></div><div class="line"> *</div><div class="line"> * <span class="built_in">Date</span>: <span class="number">2018</span><span class="number">-01</span><span class="number">-20</span>T17:<span class="number">24</span>Z    更新(发布)时间</div><div class="line"> *<span class="regexp">/</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/jQuery的外城结构是一个闭包(即时调用函数)</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/整体结构可以抽象为(fn)(....)</span></div><div class="line"><span class="regexp">( function( global, factory ) &#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">"use strict"; /</span><span class="regexp">/开启严格模式</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/判断的当前的环境是否是CommonJs</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/说明：CommJs 环境中会有一个 module 对象，这个对象上会有一个 exports 对象</span></div><div class="line"><span class="regexp">if ( typeof module === "object" &amp;&amp; typeof module.exports === "object" )</span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ For CommonJS and CommonJS-like environments where a proper `window`</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ is present, execute the factory and get jQuery.</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ For environments that do not have a `window` with a `document`</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ (such as Node.js), expose a factory as module.exports.</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ This accentuates the need for the creation of a real `window`.</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ e.g. var jQuery = require("jquery")(window);</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ See ticket #14549 for more info.</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/如果在 CommonJs 环境下，那么将 jQuery 对象挂载到 module.exports 对象</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/factory函数的第二个参数传递为true,表示将不会在window上注册jQuery对象</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/因为可能运行在非浏览器下，所有对global.document进行检查</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/如果global.document有值，那么调用factory( global, true )得到结果赋值给module.exports</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/如果global.document没有值(在非浏览器环境下)，我们没有window对象，那么就需要自己创建了一个模拟浏览器的环境</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/传入自己的 window 对象，这种情况下 jQuery 对象将绑定到你传入的这个特殊的 window 对象上</span></div><div class="line"><span class="regexp">module.exports = global.document ?</span></div><div class="line"><span class="regexp">factory( global, true ) :</span></div><div class="line"><span class="regexp">function( w ) &#123;</span></div><div class="line"><span class="regexp">if ( !w.document ) &#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/如果没有document,那么就抛出错误信息</span></div><div class="line"><span class="regexp">throw new Error( "jQuery requires a window with a document" );</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">return factory( w );</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">else</span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/如果不是在 CommonJs 环境下，直接执行工厂函数</span></div><div class="line"><span class="regexp">        /</span><span class="regexp">/调用函数的时候传递一个参数(window|this),第二个参数没有传值，默认为undefined</span></div><div class="line"><span class="regexp">factory( global );</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Pass this if window is not defined yet</span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/实参说明：第一个参数(global)的值为window 或者 是当前上下文this,第二个参数为函数</span></div><div class="line"><span class="regexp">&#125; )( typeof window !== "undefined" ? window : this, function( window, noGlobal )</span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ enough that all such attempts are guarded in a try block.</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/开启严格模式</span></div><div class="line"><span class="regexp">"use strict";</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/声明变量</span></div><div class="line"><span class="regexp">var arr = [];</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/获取document文件</span></div><div class="line"><span class="regexp">var document = window.document;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存Object对象上获取原型对象的方法</span></div><div class="line"><span class="regexp">var getProto = Object.getPrototypeOf;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存数组中截取元素的方法</span></div><div class="line"><span class="regexp">var slice = arr.slice;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存数组中合并数组的方法</span></div><div class="line"><span class="regexp">var concat = arr.concat;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存数组中添加元素的方法</span></div><div class="line"><span class="regexp">var push = arr.push;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存数组中返回元素索引的方法</span></div><div class="line"><span class="regexp">var indexOf = arr.indexOf;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/初始化空的对象</span></div><div class="line"><span class="regexp">var class2type = &#123;&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存&#123;&#125;.toString方法,其实是Object.prototype.toString方法</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/该方法用于获取指定对象的类型和真实构造函数 ex: [object String]</span></div><div class="line"><span class="regexp">var toString = class2type.toString;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存检查是否是实例成员的方法</span></div><div class="line"><span class="regexp">var hasOwn = class2type.hasOwnProperty;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存 Object.prototype.hasOwnProperty.toString方法</span></div><div class="line"><span class="regexp">var fnToString = hasOwn.toString;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存 Object.prototype.hasOwnProperty.toString.call(Object) 方法</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/==&gt; "function Object() &#123; [native code] &#125;"</span></div><div class="line"><span class="regexp">var ObjectFunctionString = fnToString.call( Object );</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 初始化空的对象</span></div><div class="line"><span class="regexp">var support = &#123;&#125;;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 工具函数：检查传入的对象是否是函数类型的</span></div><div class="line"><span class="regexp">var isFunction = function isFunction( obj ) &#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">      /</span><span class="regexp">/ Support: Chrome &lt;=57, Firefox &lt;=52</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/浏览器的支持情况</span></div><div class="line"><span class="regexp">      /</span><span class="regexp">/ In some browsers, typeof returns "function" for HTML &lt;object&gt; elements</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/ 在很多的浏览器中对HTML对象节点执行typeof会返回 function</span></div><div class="line"><span class="regexp">      /</span><span class="regexp">/ (i.e., `typeof document.createElement( "object" ) === "function"`).</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/ 在ie中typeof document.createElement( "object" )的结果为function</span></div><div class="line"><span class="regexp">      /</span><span class="regexp">/ We don't want to classify *any* DOM node as a function.</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/ 在检查函数的时候排除任何的DOM节点</span></div><div class="line"><span class="regexp">  /</span><span class="regexp">/ 注：DOM节点均拥有nodeType属性，属性值为number类型，根据具体的数值不同来进行区分 1为元素节点 2为属性节点</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">      return typeof obj === "function" &amp;&amp; typeof obj.nodeType !== "number";</span></div><div class="line"><span class="regexp">  &#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/工具函数：检查传入的参数是否是window</span></div><div class="line"><span class="regexp">var isWindow = function isWindow( obj ) &#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/检查window的方式  window = window.window 即window对象本身拥有window属性来标名自己是window</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/null不能拥有任何的属性，排除null</span></div><div class="line"><span class="regexp">return obj != null &amp;&amp; obj === obj.window;</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/保存script属性的字面量对象:类型|资源|noModule</span></div><div class="line"><span class="regexp">var preservedScriptAttributes = &#123;</span></div><div class="line"><span class="regexp">type: true,</span></div><div class="line"><span class="regexp">src: true,</span></div><div class="line"><span class="regexp">noModule: true</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 该方法作为 $.globalEval();方法的内部实现,作用类似于js原生的eval方法</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ $.globalEval( "var a = 1;" );方法其实就是调用 DOMEval("var a = 1;");</span></div><div class="line"><span class="regexp">function DOMEval( code, doc, node ) &#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">     /</span><span class="regexp">/如果doc没有值,那么初始化为document</span></div><div class="line"><span class="regexp">doc = doc || document;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/创建空的script标签</span></div><div class="line"><span class="regexp">var i,</span></div><div class="line"><span class="regexp">script = doc.createElement( "script" );</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/设置script标签的文本内容</span></div><div class="line"><span class="regexp">script.text = code;</span></div><div class="line"><span class="regexp">if ( node ) &#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/循环preservedScriptAttributes对象</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/把node节点中的type &amp;&amp; src &amp;&amp; noModule拷贝给script标签</span></div><div class="line"><span class="regexp">for ( i in preservedScriptAttributes ) &#123;</span></div><div class="line"><span class="regexp">if ( node[ i ] ) &#123;</span></div><div class="line"><span class="regexp">script[ i ] = node[ i ];</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/doc.head 表示访问页面中的header头部标签</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/把先创建的script标签插入到页面然后删除掉</span></div><div class="line"><span class="regexp">doc.head.appendChild( script ).parentNode.removeChild( script );</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/获取参数对应的数据类型</span></div><div class="line"><span class="regexp">function toType( obj ) &#123;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 如果参数是null,那么就返回"null"</span></div><div class="line"><span class="regexp">if ( obj == null ) &#123;</span></div><div class="line"><span class="regexp">return obj + "";</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Support: Android &lt;=2.3 only (functionish RegExp)</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 如果typeof的结果为object 或者是function 那么就通过class2type[ toString.call( obj ) ]方法计算</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ class2type[ toString.call( obj ) ] 其实就是Object.prototype.toString.call(obj) 形式</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 如果toString方法计算的结果为false,那么就返回object,否则返回typeof obj的值</span></div><div class="line"><span class="regexp">return typeof obj === "object" || typeof obj === "function" ?</span></div><div class="line"><span class="regexp">class2type[ toString.call( obj ) ] || "object" :</span></div><div class="line"><span class="regexp">typeof obj;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">/</span>* global <span class="built_in">Symbol</span> *<span class="regexp">/</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Defining this global in .eslintrc.json would create a danger of using the global</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ unguarded in another place, it seems safer to define global only for this module</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">var</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 当前版本</span></div><div class="line"><span class="regexp">version = "3.3.1",</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Define a local copy of jQuery 定义jQuery的本地副本</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ jQuery工厂函数的定义(声明)</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 参数1 ： 选择器</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 参数2 :  上下文对象</span></div><div class="line"><span class="regexp">jQuery = function( selector, context ) &#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ The jQuery object is actually just the init constructor 'enhanced'</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Need init if jQuery is called (just allow error to be thrown if not included)</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ jQuery.fn,init 作为构造函数，这里返回的其实是jQuery.fn.init构造函数的实例化对象</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 调用jQuery函数的时候其实是以构造函数的方式调用 xxx...init函数</span></div><div class="line"><span class="regexp">return new jQuery.fn.init( selector, context );</span></div><div class="line"><span class="regexp">&#125;,</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Support: Android &lt;=4.0 only</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Make sure we trim BOM and NBSP</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 确保对BOM和NBSP的处理,清除字符串开始和结尾的一个或多个空格的正则表达式</span></div><div class="line"><span class="regexp">rtrim = /</span>^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;</div><div class="line"></div><div class="line"><span class="comment">//设置jQuery的原型对象，并把原型对象赋值给jQuery.fn</span></div><div class="line">jQuery.fn = jQuery.prototype = &#123;</div><div class="line"></div><div class="line"><span class="comment">//这里列出了一部分jQuery原型成员（属性和方法）</span></div><div class="line"><span class="comment">//所有的jQuery实例对象都能够访问这些属性和方法</span></div><div class="line"></div><div class="line"><span class="comment">// The current version of jQuery being used</span></div><div class="line"><span class="comment">//当前正在使用的jQuery版本信息</span></div><div class="line">jquery: version,</div><div class="line"><span class="comment">//构造器属性 ---&gt; jQuery</span></div><div class="line"><span class="keyword">constructor</span>: jQuery,</div><div class="line"></div><div class="line">// The default length of a jQuery object is 0</div><div class="line">//jQuery实例对象中数据的个数，默认长度为0</div><div class="line">length: 0,</div><div class="line"></div><div class="line">// 把jQuery实例对象转换为数组类型的方法</div><div class="line">toArray: function() &#123;</div><div class="line"><span class="comment">//其实调用的是Array.prototype.slice.call(this) 方法 相当于this.slice()</span></div><div class="line"><span class="comment">//在数组的slice方法中，如果不接受参数则表示截取所有的元素保存到一个新的数组中返回</span></div><div class="line"><span class="keyword">return</span> slice.call( <span class="keyword">this</span> );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Get the Nth element in the matched element set OR</span></div><div class="line"><span class="comment">// Get the whole matched element set as a clean array</span></div><div class="line"><span class="comment">// 获取jQ对象中指定索引对应的数据(通常为DOM节点)</span></div><div class="line">get: <span class="function"><span class="keyword">function</span>(<span class="params"> num </span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// Return all the elements in a clean array</span></div><div class="line"><span class="comment">//如果没有传递参数，那么等价于调用了toArray方法</span></div><div class="line"><span class="comment">//把当前jQ对象中所有的value值保存到数组中返回</span></div><div class="line"><span class="keyword">if</span> ( num == <span class="literal">null</span> ) &#123;</div><div class="line"><span class="keyword">return</span> slice.call( <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Return just the one element from the set</span></div><div class="line"><span class="comment">// 区分索引值的情况</span></div><div class="line"><span class="comment">// 如果索引值为负数那么 返回this[index + this.length]</span></div><div class="line"><span class="comment">// 如果索引值&gt; = 0     返回thus[index]</span></div><div class="line"><span class="keyword">return</span> num &lt; <span class="number">0</span> ? <span class="keyword">this</span>[ num + <span class="keyword">this</span>.length ] : <span class="keyword">this</span>[ num ];</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Take an array of elements and push it onto the stack</span></div><div class="line"><span class="comment">// (returning the new matched element set)</span></div><div class="line"><span class="comment">// 维护堆栈集合 把传入的数据包裹成一个新的jQ对象，然后更新prevObject的值为上一个(this)对象</span></div><div class="line">pushStack: <span class="function"><span class="keyword">function</span>(<span class="params"> elems </span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">// Build a new jQuery matched element set</span></div><div class="line"><span class="comment">// merge方法用于合并两个数组</span></div><div class="line"><span class="comment">// this.constructor() 其实就是this.jQuery(); 得到的是一个空的jQ实例对象</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">var</span> ret = jQuery.merge( <span class="keyword">this</span>.constructor(), elems );</div><div class="line"></div><div class="line"><span class="comment">// Add the old object onto the stack (as a reference)</span></div><div class="line"></div><div class="line"><span class="comment">//prevObject属性用于维护和记录前一个操作的jQ实例对象</span></div><div class="line"><span class="comment">//把当前对象设置为ret的prevObject属性，并返回</span></div><div class="line">ret.prevObject = <span class="keyword">this</span>;</div><div class="line"></div><div class="line"><span class="comment">// Return the newly-formed element set</span></div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Execute a callback for every element in the matched set.</span></div><div class="line"><span class="comment">//迭代jQuery实例对象的方法，该方法内部调用jQuery.each方法实现</span></div><div class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params"> callback </span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> jQuery.each( <span class="keyword">this</span>, callback );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// 数组映射方法，对jQuery.map方法做了额外的包装</span></div><div class="line">map: <span class="function"><span class="keyword">function</span>(<span class="params"> callback </span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pushStack( jQuery.map( <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> elem, i </span>) </span>&#123;</div><div class="line"><span class="comment">//使用当前的元素来调用callback方法,绑定this</span></div><div class="line"><span class="keyword">return</span> callback.call( elem, i, elem );</div><div class="line">&#125; ) );</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 截取对象中指定的键值对(元素)</span></div><div class="line"><span class="comment">//因为slice方法调用后返回的是一个新的对象集合，所以需要调用pushStack方法维护prevObject堆栈</span></div><div class="line">slice: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//核心实现：this =&gt; Array.prototype.slice(arguments) || this =&gt; [].slice(arguments)</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pushStack( slice.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ) );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">//获取jQuery实例对象中的第一个元素(第一个键值对中的value值，其实就是第一个DOM标签)包裹为jQuery对象返回</span></div><div class="line"><span class="comment">//内部通过调用jQuery.eq方法实现，</span></div><div class="line">first: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.eq( <span class="number">0</span> );</div><div class="line">&#125;,</div><div class="line"><span class="comment">//获取jQuery实例对象中的最后一个元素</span></div><div class="line"><span class="comment">//同first方法一致，eq方法传递-1表示倒着数，即倒数第一个(最后一个)元素</span></div><div class="line">last: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.eq( <span class="number">-1</span> );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">//获取jQuery实例对象中指定索引对应的元素，拿到元素后包装为jQuery实例对象返回</span></div><div class="line"><span class="comment">//该方法的参数支持正整数或者是负数</span></div><div class="line">eq: <span class="function"><span class="keyword">function</span>(<span class="params"> i </span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> len = <span class="keyword">this</span>.length,</div><div class="line">j = +i + ( i &lt; <span class="number">0</span> ? len : <span class="number">0</span> );</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.pushStack( j &gt;= <span class="number">0</span> &amp;&amp; j &lt; len ? [ <span class="keyword">this</span>[ j ] ] : [] );</div><div class="line"></div><div class="line"><span class="comment">//自己写的另外一种实现方案(在判断的时候需要考虑到越界的问题)</span></div><div class="line"><span class="comment">// var len = this.length;</span></div><div class="line"><span class="comment">// var arrM = [];</span></div><div class="line"><span class="comment">// if (i &gt;= 0 &amp;&amp; i &lt; len)</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// arrM.push(this[i])</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">// else if(i &lt; 0 &amp;&amp; (-i &lt; len) )</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// arrM.push(this[i + len])</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">// return this.pushStack(arrM)</span></div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">//返回前一个操作的jQuery实例对象</span></div><div class="line">end: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//检查prevObject的属性值，如果优质那么就返回prevObject否则返回空的jQuery实例对象</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.prevObject || <span class="keyword">this</span>.constructor();</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// For internal use only.</span></div><div class="line"><span class="comment">// 仅供内部使用的方法</span></div><div class="line"><span class="comment">// Behaves like an Array's method, not like a jQuery method.</span></div><div class="line"><span class="comment">// 这些方法的表现和数组一致，不完全像jQuery风格的方法</span></div><div class="line"></div><div class="line"><span class="comment">//往jQuery实例对象中添加数据</span></div><div class="line">push: push,</div><div class="line"><span class="comment">//排序的方法</span></div><div class="line">sort: arr.sort,</div><div class="line"><span class="comment">//添加|删除的方法，其实就是数组中的splice方法</span></div><div class="line">splice: arr.splice</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//  jQuery中的插件处理机制</span></div><div class="line"><span class="comment">//给jQuery添加extend扩展方法，即jQuery.extend()</span></div><div class="line"><span class="comment">//给jQuery的原型对象添加extend扩展方法,即jQuery.prototype.extend()</span></div><div class="line"><span class="comment">//这两个的方法的作用简单来说就是把传入参数(对象类型)中所有的方法都添加到jQuery或者是jQuery原型对象上面</span></div><div class="line"><span class="comment">//  这里给出一个简陋的实现版本,内部使用了this根据当前上下文的不同，指代的可能是jQuery或者是jQuery.prototype</span></div><div class="line"><span class="comment">//     jQuery.extend = jQuery.fn.extend = function (objT) &#123;</span></div><div class="line"><span class="comment">// for (var key in objT)</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// if (Object.hasOwnProperty(key))</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">// this[key] = objT[key];</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"><span class="comment">//     &#125;;</span></div><div class="line"></div><div class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//声明一堆的变量length 为实参的个数</span></div><div class="line"><span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</div><div class="line">target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</div><div class="line">i = <span class="number">1</span>,</div><div class="line">length = <span class="built_in">arguments</span>.length,</div><div class="line">deep = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">// Handle a deep copy situation</span></div><div class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">"boolean"</span> ) &#123;</div><div class="line">deep = target;</div><div class="line"></div><div class="line"><span class="comment">// Skip the boolean and the target</span></div><div class="line">target = <span class="built_in">arguments</span>[ i ] || &#123;&#125;;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></div><div class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">"object"</span> &amp;&amp; !isFunction( target ) ) &#123;</div><div class="line">target = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Extend jQuery itself if only one argument is passed</span></div><div class="line"><span class="keyword">if</span> ( i === length ) &#123;</div><div class="line">target = <span class="keyword">this</span>;</div><div class="line">i--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line"></div><div class="line"><span class="comment">// Only deal with non-null/undefined values</span></div><div class="line"><span class="keyword">if</span> ( ( options = <span class="built_in">arguments</span>[ i ] ) != <span class="literal">null</span> ) &#123;</div><div class="line"></div><div class="line"><span class="comment">// Extend the base object</span></div><div class="line"><span class="keyword">for</span> ( name <span class="keyword">in</span> options ) &#123;</div><div class="line">src = target[ name ];</div><div class="line">copy = options[ name ];</div><div class="line"></div><div class="line"><span class="comment">// Prevent never-ending loop</span></div><div class="line"><span class="keyword">if</span> ( target === copy ) &#123;</div><div class="line"><span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Recurse if we're merging plain objects or arrays</span></div><div class="line"><span class="keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||</div><div class="line">( copyIsArray = <span class="built_in">Array</span>.isArray( copy ) ) ) ) &#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( copyIsArray ) &#123;</div><div class="line">copyIsArray = <span class="literal">false</span>;</div><div class="line">clone = src &amp;&amp; <span class="built_in">Array</span>.isArray( src ) ? src : [];</div><div class="line"></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Never move original objects, clone them</span></div><div class="line">target[ name ] = jQuery.extend( deep, clone, copy );</div><div class="line"></div><div class="line"><span class="comment">// Don't bring in undefined values</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</div><div class="line">target[ name ] = copy;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Return the modified object</span></div><div class="line"><span class="keyword">return</span> target;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//为jQuery添加一堆工具方法,对象参数中所有的成员都将直接添加在jQuery函数身上成为jQuery的静态方法</span></div><div class="line">jQuery.extend( &#123;</div><div class="line"></div><div class="line"><span class="comment">// Unique for each copy of jQuery on the page</span></div><div class="line"><span class="comment">// 简单测试下得到的结果是：jQuery33104605303773584173</span></div><div class="line"><span class="comment">// 确保页面中的jQuery副本是唯一的，（jQuery + 版本号 + 随机数） =&gt; 格式处理</span></div><div class="line">expando: <span class="string">"jQuery"</span> + ( version + <span class="built_in">Math</span>.random() ).replace( <span class="regexp">/\D/g</span>, <span class="string">""</span> ),</div><div class="line"></div><div class="line"><span class="comment">// Assume jQuery is ready without the ready module</span></div><div class="line"><span class="comment">// 是否已经准备就绪</span></div><div class="line">isReady: <span class="literal">true</span>,</div><div class="line"><span class="comment">//错误处理方法：根据传入的消息创建一个错误对象并抛出异常</span></div><div class="line">error: <span class="function"><span class="keyword">function</span>(<span class="params"> msg </span>) </span>&#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( msg );</div><div class="line">&#125;,</div><div class="line"><span class="comment">//空函数</span></div><div class="line">noop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line"><span class="comment">//用于判断指定参数是否是一个纯粹的对象</span></div><div class="line"><span class="comment">//所谓"纯粹的对象"，就是该对象是通过"&#123;&#125;"或"new Object"创建的 .排除了数组、自定义构造函数创建的对象以及函数等类型</span></div><div class="line">isPlainObject: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> proto, Ctor;</div><div class="line"></div><div class="line"><span class="comment">// Detect obvious negatives</span></div><div class="line"><span class="comment">// Use toString instead of jQuery.type to catch host objects</span></div><div class="line"></div><div class="line"><span class="comment">//如果参数为null | undefined 或者在调用Object.prototype.toString.call(参数)的时候得到的结果不是[object Object]则直接返回false</span></div><div class="line"><span class="keyword">if</span> ( !obj || toString.call( obj ) !== <span class="string">"[object Object]"</span> ) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取当前对象的原型对象，其实是调用了Object.getPrototypeOf(参数) 方法</span></div><div class="line">proto = getProto( obj );</div><div class="line"></div><div class="line"><span class="comment">// Objects with no prototype (e.g., `Object.create( null )`) are plain</span></div><div class="line"><span class="comment">//监测 没有原型对象的最纯净的对象 例如使用Object.create( null )创建的对象</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( !proto ) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Objects with prototype are plain iff they were constructed by a global Object function</span></div><div class="line"><span class="comment">//如果原型对象上拥有constructor属性(前一句的结果为true) 那么就返回proto.constructor的值</span></div><div class="line"><span class="comment">//如果原型对象是Object.prototype 那么Object.prototype.constructor ==&gt; ƒ Object() &#123; [native code] &#125;</span></div><div class="line">Ctor = hasOwn.call( proto, <span class="string">"constructor"</span> ) &amp;&amp; proto.constructor;</div><div class="line"></div><div class="line"><span class="comment">//检查Ctor是否是函数 且函数字符串是否全等于function Object() &#123; [native code] &#125;</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> Ctor === <span class="string">"function"</span> &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">//用于判断指定参数是否是一个空对象</span></div><div class="line"><span class="comment">//所谓"空对象"，即不包括任何可枚举(自定义)的属性。简而言之，就是该对象没有属性可以通过for...in迭代。</span></div><div class="line">isEmptyObject: <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/* eslint-disable no-unused-vars */</span></div><div class="line"><span class="comment">// See https://github.com/eslint/eslint/issues/6125</span></div><div class="line"><span class="keyword">var</span> name;</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( name <span class="keyword">in</span> obj ) &#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Evaluates a script in a global context</span></div><div class="line"><span class="comment">//用于全局性地执行一段JavaScript代码,内部调用DOMEval方法实现</span></div><div class="line"><span class="comment">//其作用与常规的JavaScript eval()函数相似。区别自傲与jQuery.globalEval()执行代码的作用域为全局作用域。</span></div><div class="line">    <span class="comment">//使用示例：$.globalEval( "var a =1" ); 该行代码将在全局作用域中定义变量a</span></div><div class="line">globalEval: <span class="function"><span class="keyword">function</span>(<span class="params"> code </span>) </span>&#123;</div><div class="line">DOMEval( code );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">//常用的迭代方法，可以用来遍历数组|对象|jQ实例对象(伪数组)</span></div><div class="line"><span class="comment">//该方法同$("xxx").each() 方法保持一致</span></div><div class="line"><span class="comment">//第一个参数：要遍历的对象| 数组 | jQ实例对象</span></div><div class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params"> obj, callback </span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> length, i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">//如果参数是伪数组那么使用普通的for循环来进行遍历</span></div><div class="line"><span class="keyword">if</span> ( isArrayLike( obj ) ) &#123;</div><div class="line">length = obj.length;</div><div class="line"><span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line"><span class="comment">//调用回到函数，把当前的value值绑定给函数的this [each方法的回调函数中this--&gt; value值]</span></div><div class="line"><span class="comment">//把当前循环的key和value值(这里是i和obj[i])作为参数传递给callback回调函数</span></div><div class="line"><span class="comment">//检查回调函数的返回值，如果返回的是false，那么就退出循环</span></div><div class="line"><span class="keyword">if</span> ( callback.call( obj[ i ], i, obj[ i ] ) === <span class="literal">false</span> ) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//如果是普通的对象那么使用for..in循环来进行遍历</span></div><div class="line"><span class="keyword">for</span> ( i <span class="keyword">in</span> obj ) &#123;</div><div class="line"><span class="comment">//同上面的代码保持一致</span></div><div class="line"><span class="keyword">if</span> ( callback.call( obj[ i ], i, obj[ i ] ) === <span class="literal">false</span> ) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//把遍历的对象返回,链式编程的代码风格</span></div><div class="line"><span class="keyword">return</span> obj;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Support: Android &lt;=4.0 only</span></div><div class="line"><span class="comment">// 工具方法，用于清空字符串前面或者是后面的N个空格</span></div><div class="line"><span class="comment">// 在ES5中js提供了原生的trim方法来清除字符串前后的1个或多个空格</span></div><div class="line"><span class="comment">// 这里主要是通过正则表达式去进行匹配，把匹配到的内容替换为空字符串""</span></div><div class="line">trim: <span class="function"><span class="keyword">function</span>(<span class="params"> text </span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> text == <span class="literal">null</span> ?</div><div class="line"><span class="string">""</span> :</div><div class="line">( text + <span class="string">""</span> ).replace( rtrim, <span class="string">""</span> );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// results is for internal usage only</span></div><div class="line"><span class="comment">// 结果仅共内部使用</span></div><div class="line"><span class="comment">// 该函数用于将一个类数组对象(伪数组)转换为真正的数组对象</span></div><div class="line"><span class="comment">// 所谓"类数组对象"就是一个常规的Object对象，但它和数组对象非常相似：具备length属性，并以0、1、2、3……等数字作为属性名。</span></div><div class="line">makeArray: <span class="function"><span class="keyword">function</span>(<span class="params"> arr, results </span>) </span>&#123;</div><div class="line"><span class="comment">// 初始化ret为空数组</span></div><div class="line"><span class="keyword">var</span> ret = results || [];</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( arr != <span class="literal">null</span> ) &#123;</div><div class="line"><span class="comment">//检查传入的参数是否是伪数组</span></div><div class="line"><span class="keyword">if</span> ( isArrayLike( <span class="built_in">Object</span>( arr ) ) ) &#123;</div><div class="line"><span class="comment">//如果是伪数组，那么合并ret和arr 并返回</span></div><div class="line"><span class="comment">//如果arr是字符串那么jQuery.merge(ret,[arr]) ，否则jQuery.merge(ret,arr)</span></div><div class="line">jQuery.merge( ret,</div><div class="line"><span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?</div><div class="line">[ arr ] : arr</div><div class="line">);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">//如果参数不是伪数组，那么直接把arr中的每个数据都添加到新的数组中</span></div><div class="line"><span class="comment">//push.call( ret, arr ) 就是是 [].push.call(ret,arr) =&gt; [].push(arr)</span></div><div class="line">push.call( ret, arr );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//返回处理完的数组对象</span></div><div class="line"><span class="keyword">return</span> ret;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// 该方法用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。</span></div><div class="line"><span class="comment">// 第一个参数 用于查找的值</span></div><div class="line"><span class="comment">// 第二个参数 指定被查找的数组</span></div><div class="line"><span class="comment">// 第三个参数 指定从数组的指定索引位置开始查找，默认为 0</span></div><div class="line">    <span class="comment">// 如果数组中存在多个相同的值，则以查找到的第一个值的索引为准</span></div><div class="line"><span class="comment">// 使用示例：$.inArray("文顶顶",["demoA","demoB","wendingding.com","文顶顶","demoC","end"],4)</span></div><div class="line"><span class="comment">// 上面的代码表示从数组中索引为4的位置开始查找"文顶顶"这个元素项，返回的结果为-1，最后一个参数不传递则返回3</span></div><div class="line">inArray: <span class="function"><span class="keyword">function</span>(<span class="params"> elem, arr, i </span>) </span>&#123;</div><div class="line"><span class="comment">//如果参数是null或undefined那么直接返回-1</span></div><div class="line"><span class="comment">//否则通过调用indexOf方法实现 indexOf.call( arr, elem, i ) =&gt; arr.indexOf(elem,i)</span></div><div class="line"><span class="keyword">return</span> arr == <span class="literal">null</span> ? <span class="number">-1</span> : indexOf.call( arr, elem, i );</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span></div><div class="line"><span class="comment">// push.apply(_, arraylike) throws on ancient WebKit</span></div><div class="line"><span class="comment">//该方法用于合并两个数组</span></div><div class="line">merge: <span class="function"><span class="keyword">function</span>(<span class="params"> first, second </span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> len = +second.length,</div><div class="line">j = <span class="number">0</span>,</div><div class="line">i = first.length;</div><div class="line"></div><div class="line"><span class="keyword">for</span> ( ; j &lt; len; j++ ) &#123;</div><div class="line"><span class="comment">//通过普通的for循环来遍历第二个数组</span></div><div class="line"><span class="comment">//把第二个数组的元素依次追加在第一个数组的后面</span></div><div class="line">first[ i++ ] = second[ j ];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//更新数组的长度值</span></div><div class="line">first.length = i;</div><div class="line"></div><div class="line"><span class="keyword">return</span> first;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// 过滤函数用于过滤数组</span></div><div class="line"><span class="comment">// 参数1 待过滤的数组</span></div><div class="line"><span class="comment">// 参数2 过滤数组的具体函数</span></div><div class="line"><span class="comment">// 参数3 布尔类型的值</span></div><div class="line"><span class="comment">// 为true则函数返回数组中由过滤函数返回 true 的元素</span></div><div class="line"><span class="comment">//      为false则函数返回数组中由过滤函数返回false的元素</span></div><div class="line">grep: <span class="function"><span class="keyword">function</span>(<span class="params"> elems, callback, invert </span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//初始化一堆的变量</span></div><div class="line"><span class="keyword">var</span> callbackInverse,</div><div class="line">matches = [],   <span class="comment">//空数组</span></div><div class="line">i = <span class="number">0</span>,<span class="comment">//索引值为0</span></div><div class="line">length = elems.length,<span class="comment">//待过滤数组的长度</span></div><div class="line">callbackExpect = !invert;</div><div class="line"></div><div class="line"><span class="comment">// Go through the array, only saving the items</span></div><div class="line"><span class="comment">// that pass the validator function</span></div><div class="line"><span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line"><span class="comment">//每循环一次就把当前的元素和对应的索引传递给回调函数，并保存回调函数的返回值取反</span></div><div class="line">callbackInverse = !callback( elems[ i ], i );</div><div class="line"><span class="keyword">if</span> ( callbackInverse !== callbackExpect ) &#123;</div><div class="line"><span class="comment">//把过滤后的元素收集保存到新的数组中</span></div><div class="line">matches.push( elems[ i ] );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//返回过滤后得到的数据，是一个新的数组</span></div><div class="line"><span class="keyword">return</span> matches;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// arg is for internal usage only</span></div><div class="line"><span class="comment">// arg仅用于内部使用的情况</span></div><div class="line"><span class="comment">// 数组映射方法( 将一个数组中的元素转换到另一个数组中 )</span></div><div class="line"><span class="comment">// 参数1 ：待处理的数组</span></div><div class="line"><span class="comment">// 参数2 : 具体的处理函数</span></div><div class="line"><span class="comment">// 参数3 : arg</span></div><div class="line">map: <span class="function"><span class="keyword">function</span>(<span class="params"> elems, callback, arg </span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//初始化一堆的变量</span></div><div class="line"><span class="keyword">var</span> length, value,</div><div class="line">i = <span class="number">0</span>,<span class="comment">//索引值为0</span></div><div class="line">ret = [];<span class="comment">//ret为空的数组</span></div><div class="line"></div><div class="line"><span class="comment">// Go through the array, translating each of the items to their new values</span></div><div class="line"><span class="comment">// 遍历数组把数组中的每一项都转换为一个新的值</span></div><div class="line"></div><div class="line"><span class="comment">//检查是否是伪数组</span></div><div class="line"><span class="keyword">if</span> ( isArrayLike( elems ) ) &#123;</div><div class="line">length = elems.length;<span class="comment">//获取待处理的伪数组的长度</span></div><div class="line"><span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</div><div class="line"><span class="comment">//循环，每循环一次就调用处理函数并把当前的key和value值作为参数传递进去</span></div><div class="line"><span class="comment">//收集回调函数的返回值</span></div><div class="line">value = callback( elems[ i ], i, arg );</div><div class="line"></div><div class="line"><span class="comment">//如果回调函数的范返回值不为空，那么就把该返回值添加到数组中并最终返回</span></div><div class="line"><span class="keyword">if</span> ( value != <span class="literal">null</span> ) &#123;</div><div class="line">ret.push( value );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Go through every key on the object,</span></div><div class="line"><span class="comment">//如果是普通的对象，那么就使用for...in循环来进行遍历</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">for</span> ( i <span class="keyword">in</span> elems ) &#123;</div><div class="line">value = callback( elems[ i ], i, arg );</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( value != <span class="literal">null</span> ) &#123;</div><div class="line">ret.push( value );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Flatten any nested arrays</span></div><div class="line"><span class="comment">// 等价于 [].concat(ret) 问题：为什么不直接范湖ret数组呢？</span></div><div class="line"><span class="keyword">return</span> concat.apply( [], ret );  </div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// A global GUID counter for objects</span></div><div class="line"><span class="comment">// 全局的GUID计数器</span></div><div class="line">guid: <span class="number">1</span>,</div><div class="line"></div><div class="line"><span class="comment">// jQuery.support is not used in Core but other projects attach their</span></div><div class="line"><span class="comment">// properties to it so it needs to exist.</span></div><div class="line">    <span class="comment">// 就是个空对象 &#123;&#125; 不在核心中使用，但其他项目将它们的属性附加到它，因此它需要存在。</span></div><div class="line">support: support</div><div class="line">&#125; );</div><div class="line"></div><div class="line"><span class="comment">//......</span></div><div class="line"><span class="comment">// 设置jQuery.prototype.init方法</span></div><div class="line">init = jQuery.fn.init = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context, root </span>) </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Give the init function the jQuery prototype for later instantiation</span></div><div class="line">/  让jQuery.prototype.init方法的原型对象指向jQuery原型对象</div><div class="line"><span class="comment">// (正因如此$("xx")得到的jQ实例对象才能访问jQuery原型对象上面的方法)</span></div><div class="line">init.prototype = jQuery.fn;</div><div class="line"><span class="comment">//.....</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">&#125; );</div></pre></td></tr></table></figure><p>上面的代码简化后的整体结构如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//01 立即调用函数(闭包)</div><div class="line">(function (window) &#123;</div><div class="line"></div><div class="line">    //02 提供工厂函数</div><div class="line">    var jQuery = function (selector) &#123;</div><div class="line">        return new jQuery.fn.init(selector);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //03 设置原型对象</div><div class="line">    jQuery.prototype = &#123;</div><div class="line">        constructor:jQuery,</div><div class="line">        init:function (selector) &#123;</div><div class="line">            //初始化处理...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //动态的添加fn属性</div><div class="line">    jQuery.fn = jQuery.prototype;</div><div class="line">    </div><div class="line">    //04 原型对象赋值</div><div class="line">    jQuery.fn.init.prototype = jQuery.fn;</div><div class="line"></div><div class="line">    //........</div><div class="line">    </div><div class="line">    //05 把jQuery和$暴露出来</div><div class="line">    window.$ = window.jQuery = jQuery;</div><div class="line"></div><div class="line">&#125;)(window);</div></pre></td></tr></table></figure></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这篇文章将主要介绍jQuery框架的前600行代码并说明jQuery框架的整体结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;整体结构&quot;&gt;&lt;a href=&quot;#整体结构&quot; class=&quot;headerlink&quot; title=&quot;整体结构&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="jQuery框架系列" scheme="https://weibo.com/u/3800117445/tags/jQuery%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>jQuery系列 [09]-jQuery框架源码解读[开始]</title>
    <link href="https://weibo.com/u/3800117445/2018/08/24/jQuery%E7%B3%BB%E5%88%97%20%5B09%5D-jQuery%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%5B%E5%BC%80%E5%A7%8B%5D/"/>
    <id>https://weibo.com/u/3800117445/2018/08/24/jQuery系列 [09]-jQuery框架源码解读[开始]/</id>
    <published>2018-08-24T10:01:01.000Z</published>
    <updated>2018-08-24T09:32:57.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我将花点时间写几篇关于jQuery框架源码解读的系列文章，参考版本为当前最新的jQuery 3.3.1版本，本文主要介绍jQuery框架最新版本的基本信息以及如何开始等相关的内容。</p></blockquote><p><strong>准备说明</strong> </p><p>我自己在写文章和演示的时候使用的Mac OSX系统，在开始之前您需要先准备好如下的环境：</p><blockquote><p>✧ node和npm，可以<a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">点击下载node安装</a><br>✧ git环境 Mac电脑已经内置，windows系统可以<a href="https://gitforwindows.org/" target="_blank" rel="external">点击下载git for windows</a>来进行安装<br>✧ 掌握或者了解grunt构建工具的基本使用，您可以参考<a href="http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">Grunt的基本使用</a>等相关的文章</p></blockquote><p><strong>开始操作</strong></p><p>001 打开终端工具 新创建目录，cd进入到指定的项目路径</p><p>ex: <code>$ cd jQuery框架</code></p><p>002 把jQuery托管在github上面的框架源码下载到当前目录</p><p>ex: <code>$ git clone https://github.com/jquery/jquery.git</code></p><p>003 把jQuery源码下载完成后将得到下面的目录结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── AUTHORS.txt</div><div class="line">├── CODE_OF_CONDUCT.md</div><div class="line">├── CONTRIBUTING.md</div><div class="line">├── Gruntfile.js      //jQuery框架的构建配置文件(采用了Grunt构建工具)</div><div class="line">├── LICENSE.txt       //jQuery框架使用的开源协议文件(具体为MIT开源协议)</div><div class="line">├── README.md         //项目的说明文档(github托管地址主页能看到的介绍文档)</div><div class="line">├── build             //项目的构建目录</div><div class="line">├── dist              //项目的发布目录(当前为空)</div><div class="line">├── external          //项目的外部依赖</div><div class="line">├── package.json      //项目的配置文件(包含框架需要依赖的所有包信息)</div><div class="line">├── src               //项目的开发目录</div><div class="line">└── <span class="built_in">test</span>              //框架的测试目录</div></pre></td></tr></table></figure><p>004 使用npm包管理工具来安装框架的依赖，当命令行执行完毕后会在当前目录创建node_modules文件夹(里面包含框架需要的所有必要的依赖)</p><p>ex:<code>$ npm install</code></p><p>005 安装grunt-cli工具，并执行构建命令，对src目录的文件进测试、合并等操作</p><p>ex:<code>$ npm install -g grunt-cli</code><br>ex:<code>$ grunt -V</code><br>ex:<code>$ grunt</code></p><p>006 上面的命令执行完毕后会在dist发布目录创建jquery.js和jquery.min.js文件，除了像上面这样一步一步处理之外也可以直接在把jQuery下载到项目后直接执行$ npm run build命令（该命令内部会调用npm install &amp;&amp; grunt命令）。</p><div class="tip"><strong>说明</strong>：执行grunt命令的前提的是在本地安装了grunt-cli</div><p>007 后续我将逐行的对jQuery框架源码进行解析，并贴出注解版本和解析内容。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我将花点时间写几篇关于jQuery框架源码解读的系列文章，参考版本为当前最新的jQuery 3.3.1版本，本文主要介绍jQuery框架最新版本的基本信息以及如何开始等相关的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;准备说明
      
    
    </summary>
    
    
      <category term="jQuery框架系列" scheme="https://weibo.com/u/3800117445/tags/jQuery%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据安全系列 XOR</title>
    <link href="https://weibo.com/u/3800117445/2018/08/03/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%20XOR/"/>
    <id>https://weibo.com/u/3800117445/2018/08/03/数据安全系列 XOR/</id>
    <published>2018-08-02T16:00:00.000Z</published>
    <updated>2018-08-07T03:39:53.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单介绍计算机体系中的异或运算，运算其特点以及在数据安全领域的应用。</p></blockquote><h3 id="异或运算介绍"><a href="#异或运算介绍" class="headerlink" title="异或运算介绍"></a>异或运算介绍</h3><p><strong>XOR</strong> 全称为<code>exclusive OR</code>,简写为XOR，中文称为<strong>异或运算</strong>。</p><p>异或运算是一种数学运算符，主要应用于逻辑运算和计算机体系中的位运算。异或运算的数学符号常表示为“⊕”，运算法则为：<code>A ⊕ B = (¬A ∧B) ∨ (A ∧¬B)</code>。<br>简单研究下1个位（比特）的异或运算。</p><div style="font-Size:16px;color:#190;border:1px dashed #000;width:350px;padding:10px;text-align:center"> 0 ⊕ 0 = 0；（0与0异或运算的结果为0）<br>0 ⊕ 1 = 1；（0与1异或运算的结果为1）<br>1 ⊕ 0 = 1；（1与0异或运算的结果为1）<br>1 ⊕ 1 = 0；（1与1异或运算的结果为0）<br></div><p>异或运算可以类比于<span style="text-decoration:underline;color:#f66;">奇偶数的加法运算</span>或者是<span style="text-decoration:underline ; color:#F66;">翻牌处理</span>。在按位运算的过程中，参与运算的数值只有两种可能，那么为0要么为1，在这里0为偶数，1位奇数，可以得出下面的运算特征，我们发现结果和异或运算是一致的。</p><div style="font-Size:16px;color:#456;border:1px dashed #000;width:500px;padding:10px;text-align:center"> 偶数 + 偶数 = 偶数；（偶数与偶数相加运算的结果为偶数）<br>偶数 + 奇数 = 奇数；（偶数与奇数相加运算的结果为奇数）<br>奇数 + 偶数 = 奇数；（奇数与偶数相加运算的结果为奇数）<br>奇数 + 奇数 = 偶数；（奇数与奇数相加运算的结果为偶数）<br></div><p>接下来我们来看下所谓的<strong>翻牌处理</strong>。我们可以想象一下，假如桌面中有一张扑克牌，对应二进制总位的异或运算有0和1两种情况，那么对于扑克牌也有两种情况，那么就是不翻转和翻转，我们找到它们的对应关系。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/xor02.jpeg?raw=true" width="150px"></p><p>接下来我们来分析下对扑克牌进行翻转|不翻转处理以及对应特征，我们发现结果和异或运算是一致的。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/xor03.png?raw=true"></p><p><strong>异或运算的特征可以简单的归纳为：<code>相同为0，不同为1</code></strong>。</p><h3 id="常用位运算符补充"><a href="#常用位运算符补充" class="headerlink" title="常用位运算符补充"></a>常用位运算符补充</h3><p>位操作符用于最基本的层次，它们按照内存中表示数值的位来操作数值，位运算符主要有：<strong>按位与（&amp;）</strong>、<strong>按位或（|）</strong>、<strong>按位异或（^）</strong>、<strong>按位取反（~）</strong>、<strong>左移（&lt;&lt;）</strong>和<strong>右移（&gt;&gt;）</strong>，这里将简单介绍常用的位运算符以及其基本特征作为补充。</p><p><strong>按位或运算（OR）</strong>的运算符为<code>|</code>, 是双目运算符，其运算特征是：<code>两个运算数中有1则为1，否则为0</code>。</p><p><strong>按位与运算（AND）</strong>的运算符为<code>&amp;</code>，是双目运算符，其运算特征是：<code>只有当两个操作数均为1的时候结果为1，否则为0（也可以理解为：两个运算数中有0则为0，否则为1）</code>。</p><p><span style="color:#195"><strong>OR&nbsp;运算</strong></span>&nbsp; &nbsp;<span style="border:1px solid #000"><strong>&nbsp; &nbsp;1  |  1 = 1，1  |  0 = 1， 0  |  1 = 1，0  |  0 = 0 &nbsp; &nbsp;</strong></span></p><p><span style="color:#195"><strong>AND运算</strong></span>     <span style="border:1px solid #000"><strong>&nbsp; &nbsp;1 &amp; 1 = 1，1 &amp; 0 = 0， 0 &amp; 1 = 0，0 &amp; 0 = 0 &nbsp; &nbsp;</strong></span></p><p><strong>按位取反运算（NOT）</strong>也称为按位非运算，运算符为<code>~</code>，单目运算符。对操作数执行按位取反会返回操作数的反码，其运算本质为：<strong>操作数的负值-1</strong>。为了理解这一点，必须搞清楚下面的这些基本概念。</p><p>在处理数据的时候，通常把数据分为<code>有符号</code>和<code>无符号</code>的，如果我们使用32 位二进制码（不同语言有差异表示数据，那么对于有符号的整数，则32位中的前 31 位用于表示整数的值。第 32 位用于表示数值的符号：其中0 表示正数，1 表示负数。第32位被称为符号位。如果要表示19这个数字，那么其二进制码形式如下：<span style="color:#195">00000000   00000000   00000000   00010011 </span>需要注意的是，虽然负数在使用二进制码表示的时候使用的格式是二进制补码。下面给出负数的二进制补码表示方式的处理过程：</p><blockquote><p>[1] 求负数绝对值的二进制码。<br>[2] 求该二进制码的反码形式。<br>[3] 对得到的二进制反码加一。</p></blockquote><p>这里，我们以-19为例子来演示负数的表示方式。</p><p>19的二进制码     <span style="color:#195">00000000   00000000   00000000   00010011</span><br>二进制码反码      11111111   11111111   11111111   11101100<br>上面反码加①      <span style="color:#f22">11111111   11111111   11111111   11101101</span></p><p>我们回到按位非（NOT）的操作中来，它的结算特点是每个参与计算的二进制位都取反，相当于是求二进制的反码。我们已经知道负数的二进制表示方式，应该也就能够理解<code>对操作数进行按位非操作结果其实就是操作数的负值-1</code>。因为操作数的负值表示需要（反码 + 1），而我们需要的结果是反码，所以只需要倒退一步即可。</p><h3 id="XOR和密码体系"><a href="#XOR和密码体系" class="headerlink" title="XOR和密码体系"></a>XOR和密码体系</h3><p>现在我们已经清楚了异或运算的特点，而且掌握了1个二进制位的异或运算方式，那么下面我们来看一个稍微复杂点的例子，尝试着对一系列的二进制位进行异或处理。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/xor04.png?raw=true"></p><p>上面的示例中我们使用两个8位的二进制系列A和B进行异或运算，其中A的内容为0101 0001，B的内容为0010 0101。在对多个比特序列进行异或运算的时候，需要分别对每一位的数据进行异或运算以得到结果。这里A ⊕ B 得到的最终结果为C，其内容是0111 0100。</p><p>上面的计算过程非常简单，这里要特别说明的是因为异或运算的特点是：<code>相同为0，不同为1</code>, 所以考虑如果把A ⊕ B得到的结果 和 B 再次进行XOR运算，那么结果会变回A，即A ⊕ B = C ，C ⊕ B = A 。下面给出具体的图示：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/xor05.png?raw=true"></p><p><strong><span style="color:#195">XOR运算的可逆性可以用来恢复原值，这在加密算法中意义非凡</span></strong>。</p><p>源于XOR运算的以上特性，其实完全可以利用简单异或运算设计出一款高强度的密码算法，我们把A作为原文，B作为密钥，C作为密文，对应的密码算法为：</p><p><strong>加密算法</strong>  <span style="border:1px solid #000"><strong>&nbsp; &nbsp;原文  ⊕   密钥 =&gt;  密文 &nbsp; &nbsp; </strong></span><br><strong>解密算法</strong>  <span style="border:1px solid #000"><strong>&nbsp; &nbsp;密文  ⊕   密钥 =&gt;  原文 &nbsp; &nbsp; </strong></span><br><img src="https://github.com/flowerField/Source/blob/master/Blog/xor07.png?raw=true"></p><p>我们来简单看一下上面的图形展示，图形中我们把<code>实心的点假设为1，空性的点假设为0</code>，那么第一张图相当于明文（原文），第二张图作为蒙版（相当于密钥）盖在第一张图上的时候可以得到第三张图形（相当于密文），这个过程是可逆的，如果把第二张图片盖在第三张图片上面那么将能够还原出第一张图形来。接下来我们来看下字符串的处理情况，假设对<code>miao和nice</code>进行操作，它们在进行XOR运算后将得到一个位数相同的二进制码，把得到的二进制码和<code>nice</code>再进行XOR运算将能够恢复得到原文<code>miao</code>字符串。下面给出具体的图示：<br><img src="https://github.com/flowerField/Source/blob/master/Blog/xor06.png?raw=true"></p><p>其实像上面的这样的处理方式早在1917年就由维纳（<code>G·S Vernam</code>）提出了，被称为<strong>一次性密码</strong>，一次性密码的加密解密方式决定了它在理论上永远无法被破译，这一特性于1949年由香农通过数学方法加以证明。但实际上，这样简单的一次性密码并没有在现实中被广泛使用，原因有以下几点：<span style="color:#195">①  因为加密解密使用的是相同的密钥，所以无法保证密钥的配送和保存的安全。② 因为密钥的长度需要和明文匹配，所以意味着明文有500MB，那么密钥也必须500MB。③ 在一次性密码中需要生成大量真正的随机数，这很难实现。</span></p><p>不过，虽然直接应用XOR运算的可逆性实现的一次性密码算法无法在商业中真正应用，但我们还是能在很多经典的加密算法（比如，<code>DES</code>和<code>AES</code>）中看到XOR运算的身影。关于异或运算在其他算法中的应用，这里我们不做展开，相关的内容我将再写一篇新的文章来说明。。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单介绍计算机体系中的异或运算，运算其特点以及在数据安全领域的应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异或运算介绍&quot;&gt;&lt;a href=&quot;#异或运算介绍&quot; class=&quot;headerlink&quot; title=&quot;异或运算介绍&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据安全系列" scheme="https://weibo.com/u/3800117445/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据安全系列 术语</title>
    <link href="https://weibo.com/u/3800117445/2018/08/02/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%20%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E9%87%8A%E4%B9%89/"/>
    <id>https://weibo.com/u/3800117445/2018/08/02/数据安全系列 专业术语释义/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2018-08-04T07:49:40.693Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文不详细介绍具体的加密算法，仅仅罗列数据安全领域常见的专业术语，并作出简要释义和说明。大概可以分成两大类，一类是参与的相关方(就是人),另一类则是冷冰冰的词汇了。</p></blockquote><p><strong>密码学（cryptography）</strong> 密码学是通过把消息编码使其不可读从而获取安全性的艺术与科学。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt002.png?raw=true"></p><p><strong>发送者（Sender）</strong> 在传递消息的过程中，发出信息的一方被称为发送者，可以是人也可以是机器。</p><p><strong> 接收者（receiver）</strong>在传递消息的过程中，收到信息的一方被称为接收者，和发送者一样，接收者可以是具体的人或者是一台机器。</p><p><strong> 消息（message）</strong>传递的信息通常被称为<span style="color:#195">消息</span>，消息可以是字符串、文本、图片、音频、视频等数据。</p><p><strong>窃听者（eavesdropper）</strong> 发送者在把消息发送给接收者的时候，因为消息需要在在多个设备之间进行中转，所以在传达的过程中消息可能会被恶意的偷看，偷看消息内容的个体我们称为窃听者。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt001.png?raw=true"></p><p><strong>明文 | 原文（plaintext）</strong> 基于安全方面的考量，在开发中进行数据交互的时候通常我们会对一些敏感的用户隐私数据进行加密处理，需要进行加密的消息我们称为<span style="color:#195">明文或者是原文</span>。</p><p><strong>密文（ciphertext）</strong> 采用特定方式对明文|原文加密之后得到的结果称为密文。</p><p><strong>加密（encrypt）</strong> 加密是一种对明文的特定处理方式，对明文加密之后可以得到对应的密文，加密的方式和结果取决于特定的加密算法。</p><p><strong>算法（algorithm）</strong> 用于解决（复杂）问题的特定步骤，通常称为算法。算法为我们提供了一条解决问题的特定路径，解决同一个问题可以有多种不同的算法。</p><p><strong>加密算法（encrypt-Algorithm）</strong> 从明文生成密文的具体步骤，也就是加密的特定步骤我们称为加密算法。</p><p><strong>解密（decrypt）</strong> 解密是一种对密文的特定处理方式，对密文解密之后可以得到对应的明文。所以，解密指的是根据密文得到原文的过程。</p><p><strong>解密算法（decrypt-Algorithm）</strong> 从密文还原出明文|原文的具体步骤，也就是解密的特定步骤我们称为解密算法。</p><p><strong>密码算法</strong>  &nbsp; &nbsp; <span style="border:1px solid #000"><strong>&nbsp; &nbsp;加密算法 + 解密算法  = 密码算法 &nbsp; &nbsp;</strong></span></p><p><strong>密码破译（cryptanalysis）</strong> 接收者把密文还原为明文的过程我们称为解密，如果是接收者外的其他人试图将密文还原为明文，则称为密码破译或者是密码分析。</p><p><strong>破译者（cryptanalyst）</strong> 进行密码破译的人被称为破译者，破译者可以是单纯的坏人也可以是专业的研究人员，但并没有本质的差别。这就好像挖坟的可以是单纯的盗墓贼也可以是专业的考古人员，或者某些地区（江西）殡葬改革委员会的工作人员（特指抢棺材砸棺材的这些人）。</p><p><strong>机密性（confidentiality）</strong> 机密性指的是信息安全中所面临的一种威胁，在消息传递过程中如果被窃听导致密码泄露则威胁到了信息的机密性。好比现在有一个消息，只有你知道，你把这个消息发送给我，如果最终的结果是你知道我知道世界上只有我们俩知道该消息，那么就认为该消息是很机密的，而如果最终除了我们俩之外的其他人也知道了该消息（哪怕是天和地也不行），那么我们就认为该消息不再机密。信息安全领域与消息相关了特性除了机密性之外还有<strong>完整性、认证以及不可否认性</strong>。</p><p><strong>密钥（key）</strong> 密钥在很多加密算法中使用，它就好像我们现实生活中的钥匙一样，很多加密算法在加密和解密的时候都需要用到密钥，就好像很多锁在打开和锁起来的时候都需要用到钥匙一样。</p><p><strong>替换技术</strong> <span style="color:#195">将明文消息转换为密文消息的技术主要有两种，其中一种是替换技术，另外一种是变换技术</span>。替换技术的主要特点是在加密的过程中将一个个明文字符替换为一个个的密文字符，应用替换技术的主要加密算法有：<strong>凯撒加密算法、单码加密算法、同音替换加密算法、块替换加密算法、多码替换加密算法以及希尔加密算法等</strong>。</p><p><strong>变换技术</strong> 变换技术是将明文消息转换为密文消息技术中的一种，它的特点是通过对明文字符进行某种特定的置换操作来得到密文字符，因此也称为置换技术。应用变换技术的主要加密算法有：<strong>栅栏加密算法、Vernam加密算法以及运动密钥加密算法等</strong>。</p><p><strong>密码学家的工具箱</strong> 在众多的密码技术中有6种尤为重要，它们在布鲁斯·施奈尔的《网络信息安全的真相》中被提出，这6种加密技术分别是<strong><code>对称密码</code></strong>、<strong><code>非对称密码</code></strong>、<strong><code>单向散列函数</code></strong>、<strong><code>消息认证码</code></strong>、<strong><code>数字签名</code></strong>和<strong><code>伪随机数生成器</code></strong>。(注明：下图参考了结城浩先生的《图解密码技术》插图)</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt003.png?raw=true"></p><p><strong>凯撒密码</strong> 凯撒密码指的是公元前100年左右诞生于古罗马的军事统帅<code>朱利叶斯·凯撒</code>使用的密码。凯撒密码的特点是通过将明文中所使用的字母表按照一定的字数平移来进行加密和解密。在这里如何加密（平移）其实就是加密算法，平移的位数其实就是密钥。凯撒密码本质上使用了替换技术来实现加密和解密操作。</p><p><strong>暴力破解</strong> 在破译密码的时候，把所有的密钥都尝试一遍以试图推出原文的方式被称为<strong>暴力破解（brute-force search）</strong>，因为这种破解的方式其实质是要从所有可能的密钥中找出正确的密钥所以也被称为<code>穷举搜索</code>。</p><p><strong>密钥空间</strong> 一种密码技术能够使用的所有密钥的集合被称为<strong>密钥空间（key space）</strong>, 所有可以使用的密钥的总数就是密钥空间的大小，<span style="color:#195">密钥空间越大，暴力破解的难度就越高</span>。</p><p><strong>编码</strong> 将显示世界中的数据信息映射为比特序列的操作被称为<code>编码（encoding）</code>, 计算机领域中常见的编码模式有ASCII、UTF8、Base64等。</p><p><strong>算法类型</strong> 从广义上理解，明文生成密文的方法共两种，<strong>流加密法（stream ciphers）</strong>和<strong>分组加密法（block ciphers）</strong>, 其中分组加密法也称为块加密法。流加密技术一次加密明文中的一个位，解密时也是一位一位的进行。块加密即时一次加密明文中的一个分组（常见的是64位一组），解密时也是一个分组一个分组的进行。基于性能的考量，分组加密算法适用性更广具体实现也较多。</p><p><strong>算法模式</strong> 在分组加密算法中有多种算法模式，不同的算法模式对应的分组加密方式也很不一样，常用的算法模式主要有<strong>电子密码本模式（ECB）</strong>、<strong>电子密码链条模式（CBC）</strong>、<strong>加密反馈模式（CFB）</strong>以及<strong>输出反馈模式（OFB）</strong>等等。</p><p><strong>电子密码本模式（ECB）</strong> ECB模式的全称是<code>Electronic CodeBook模式</code>，ECB模式是所有算法模式中最简单的一种，它直接将分组的明文数据加密成为分组的密文，因为这种算法模式在处理的时候明文和密文存在一种一一对应的关系，因此主要样本足够大便能够轻易的进行破解，风险性较高。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt0012.png?raw=true"></p><p><strong>加密反馈模式（CFB）</strong> CFB模式的全称是<code>Cipher FeedBack模式</code>,也称为密文反馈模式，它的特点是前一个密文分组会被送回到加密算法的输入端。需要注意的是针对CFB模式可以实施重放攻击。</p><p><strong>输出反馈模式（OFB）</strong> OFB模式的全称是<code>Output-FeedBack模式</code>，在该模式中加密算法的输出会反馈到机密算法的输入中，它通过将明文分组和加密算法的输出进行异或运算来产生密文分组。</p><p><strong>电子密码链条模式（CBC）</strong> CBC模式的全称是<code>Cipher Block Chaining</code>模式，也称为密文分组链接模式。<span style="color:#195">在CBC模式中，首先会将明文分组与前一个密文分组进行异或运算，然后再进行加密</span>。解密的过程刚好相反，因为第一块明文分组前并没有现成的密文分组可以与之进行异或运算，所以CBC模式在使用的时候需要一个初始化向量。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt0013.png?raw=true"></p><p><strong>异或运算（XOR）</strong> 异或运算的全称是<code>exclusiveor</code>用于位运算。异或运算的特点相同为0，相异为1，常用⊕符号来表示。1 ⊕ 1 = 0；1 ⊕ 0 = 1；因为它的“还原”性质，异或运算在密码技术中被广泛应用。</p><p><strong>伪装（spoofing）</strong> 伪装简单说冒名顶替，不是某人却假装是对方，在网络通信模型中主要体现在伪装成消息的发送者和接收者进行通信。</p><p><strong>篡改（distort）</strong> 发送者把消息发送给接收者的中途消息可能会被恶意修改（篡改）。</p><p><strong>伪随机数生成器（Pseudo Random Number Generator,PRNG）</strong> 伪随机数生成器是一种能够模拟产生随机数列的算法，密码技术中主要用于生成密钥。</p><p><strong>对称加密算法</strong> 对称加密是一种应用时间较久且技术成熟的加密算法，因为对称加密算法加密和解密只有一个密钥所以也被称为<strong>秘密密钥加密算法（Secret Key Cryptography）</strong>或者是<strong>私钥加密算法（Private Key Cryptography）</strong>。对称加密算法的特点是安全性高、性能好、加密解密使用相同的密钥。经典的对称加密算法有：<code>DES、双重DES、3DES、AES、RC4、RC5以及Blowfish</code>等。对称加密算法存在的主要问题有：密钥传输安全问题以及每个通信模型都需要一个密钥。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt004.png?raw=true"></p><p><strong>数据加密标准（DES）</strong> DES是一种典型的对称加密算法，也被称为<code>DEA（ANSI称之为数据加密算法）</code>或者是<code>DEA-1（ISO设置的称谓）</code>。DES是一种使用了几十年的分组（块）加密算法，加密的时候会先对明文进行分组，分组的长度为64位（输入64位的明文输出64位的密文），DES加密和解密使用的密钥相同，密钥的有效长度为56位。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt005.png?raw=true"></p><p><strong>双重DES</strong> 双重DES是DES加密算法的变种，为了加强DES加密算法的强度，双重DES使用两个密钥，需要进行两次DES运算。</p><p><strong>3DES</strong> 3DES是DES加密算法的变种，3DES执行3次DES运算，常见的3DES算法有两种版本，一种版本使用3个密钥（使用3个密钥进行3次DES加密运算），另外一种版本使用2个密钥（使用密钥1进行加密-&gt;使用密钥2进行解密-&gt;使用密钥1进行加密）。</p><p><strong>国际数据加密算法（International Data Encryption Algorithm，IDEA）</strong> IDEA由研究员<code>Xuejia Lai</code>和<code>James L. Massey</code>研发，瑞士公司<code>Ascom Systec</code>拥有其专利权。IDEA被认为是最强大的数据加密算法之一，IDEA是典型的对称加密算法和DES算法类型，其使用的也是分组加密方式，分组长度为64位，密钥长度为128位。</p><p><strong>RC4（Rivest Cipher 4）</strong> RC4于1987年由<code>Ron Rivest</code>开发，加密和解密使用相同的密钥，是典型的对称加密算法，但和DES不同的是<code>RC采用的是流加密算法</code>，其密钥长度可变。</p><p><strong>RC5（Rivest Cipher 5）</strong> RC5是<code>Ron Rivest</code>开发出来的基于<code>分组加密算法的对称加密算法</code>，特点是速度快，灵活性更高。</p><p><strong>高级数据加密标准（Advanced Encryption Standard，AES）</strong> 20世纪90年代，美国政府想把已经广泛使用的加密算法标准化以替代DES算法，被称为高级数据加密标准（AES），为此当时提出了很多的草案，经过多次争论后确定使用<code>Rijndael算法</code>。AES算法规定支持的密钥长度和明文分组长度为128位~256位（步长为32位）。常用的AES版本是128位明文分组加128位密钥的版本和128位明文分组加256位密钥的版本。</p><p><strong>非对称加密算法（Asymmetric Key Cryptography）</strong> 非对称加密算法也称为<strong>公钥加密算法（Public Key Cryptography）</strong>，和对称加密算法加密和解密使用相同的密钥不一样的是，非对称加密算法拥有两个密钥（一个密钥对），其中用于<code>加密的密钥称为公钥，用于解密的密钥被称为私钥</code>。非对称加密算法解决了对称加密算法中的密钥传输安全问题（密钥交换问题），经典的非对称加密算法主要有<code>RSA</code>和<code>EIGamal算法</code>。非对称加密算法相对来说性能速度没有对称加密那么好（速度慢、密文大），而且虽然解决了对称加密中的密钥交换问题但自己还存在公钥认证问题。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt006.png?raw=true"></p><p><strong>公钥（Public Key）</strong> 非对称加密算法中用于对消息进行加密处理的密钥，因为加密的密钥一般都是公开的，所以该密钥又被称为公钥。</p><p><strong>私钥（Private Key）</strong> 非对称加密算法中用于对加密后的消息进行解密处理的密钥，因为该密钥是绝对不能公开的，所以该密钥又被称为私钥。</p><p><strong>密钥对（key pair）</strong> &nbsp; &nbsp; <span style="border:1px solid #000"><strong>&nbsp; &nbsp;密钥对 = 公钥 + 私钥 &nbsp; &nbsp;</strong></span> 在非对称加密算法中加密使用的公钥和解密使用的私钥应该是一一对应的，这样的一对匹配的密钥我们称之为密钥对。</p><p><strong>公钥认证</strong> 所谓公钥认证问题就是发送者和接收者在进行通信的时候，发送方无法对公钥进行认证，即无法确证公钥是正确真实的而非伪造的。因为在使用非对称加密算法的时候我们无法对公钥进行认证，所以可能会遭遇<strong>中间人攻击</strong>。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt007.png?raw=true"></p><p><strong>中间人攻击（Man-in-the-MiddleAttack）</strong> 在特定的场景中(比如网络通信)，使用非对称加密的方式来进行安全的通信可能会遭遇到中间人攻击。假设在客户端和服务器端刚建立通信的时候，客户端先发请求给服务器端索要加密中需要用到的公钥，而这个过程如果被窃听，<span style="color:#195">那么当服务器把公钥返回给客户端的时候，窃听者把返回的公钥截留，然后再自己伪造一个密钥对并把伪造的公钥返回给客户端</span>。客户端拿到公钥之后因为无法对公钥进行认证所以并不知道收到的公钥已在中途被替换，客户端使用窃听者伪造的公钥对消息进行加密之后发给服务器，中途窃听者接收到加密的消息后<span style="color:#195">使用配对的私钥来对加密的消息进行解密，篡改消息的内容后再使用之前截留的公钥来对消息加密并转发给服务器端</span>。整个过程中，客户端和服务器端都没察觉通信已经被监听、消息已经被篡改，它们彼此还天真的以为自己在使用着非对称加密算法进行着世界上最隐蔽的交流。上面描述的这个过程就是一个典型的中间人攻击的场景，利用的正是<code>客户端无法对公钥进行认证</code>以及HTTP明文传输，要解决这个问题可以考虑对公钥进行<strong>数字签名</strong>，在Web通信中对公钥进行数字签名其实就是<strong>证书</strong>。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt0008.png?raw=true"></p><p><strong>RSA算法</strong> RSA是最著名和可靠的非对称加密算法，它的名字由它的三位开发者，即<code>Ron Rivest</code>、<code>Adi Shamir</code>和<code>Leonard Adleman</code>的姓氏的首字母组成，也就是（<strong>Rivest - Shamir - Adleman</strong>）, RSA算法实现基于数学中的素数，它基于的数学事实是：<code>两个大的素数相乘很容易而对于得到的积求因子则很困难</code>。</p><p><strong>数字签名（digital signature）</strong> 数字签名是一种在信息安全领域能够解决伪装、篡改和否认等问题的技术，类似于现实世界中的签名盖章。数字签名技术的使用基于这样的事实：<span style="color:#195">使用一个公钥加密的消息只能使用相应的私钥来进行解密，反过来，使用私钥加密的消息只能用相应的公钥进行解密</span>。想象下面的场景，在双方通信的时候，我们如何能够确认收到的消息是对方发送而不是由中间人伪造的呢？在现实中我们采用的方式可能是盖章、签名或者指纹，因为不管是签名还是指纹都只有特定的人拥有，是私有性质的。我们知道在非对称加密中公钥是可以公开的，私钥私有不能公开，所以具体的实现数字签名的时候，发送方<code>使用自己的私钥来来对消息进行加密就可以得到一个数字签名</code>，接收者收到消息（数字签名）之后如果能够用公钥对消息进行加密那么我们就能够实现基本的<strong>认证</strong>。数字签名技术在现代Web商务中至关重要，多数国家已经把数字签名看成是与手工签名具有同等法律效力的授权机制。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt009.png?raw=true"></p><p><strong>生成数字签名</strong> 使用自己的私钥来对特定消息进行加密得到签名字符串的过程，我们称为生成数字签名，该步骤由发送者处理。</p><p><strong>验证数字签名</strong> 接收到签名消息后使用发送者的公钥<span style="color:#195">（签名密钥只能由签名的人持有，而验证公钥则是任何需要验证签名的人都可以持有）</span>来对签名进行解密匹配的过程，我们称为验证数字签名，该步骤由接收者处理。验证数字签名的结果可以是成功或者是失败，如果成功则表示该信息确实是由特定的发送者发出的。</p><p><strong>数字签名机制</strong> 数字签名的机制似乎刚好是把非对称加密的过程反过来，在数字签名技术中，我们使用私钥来对消息加密生成签名，然后使用公钥来对签名进行验证。常用的生成和验证数字签名的方法有两种<strong>① 直接对消息进行签名</strong>以及<strong>② 对消息的散列值进行签名</strong>。</p><p><strong>散列值（Hash Value）</strong> 使用<strong>单向散列函数</strong>来对消息进行散列计算得到的结果被称为散列值，散列值也被称为<strong>消息摘要（Message digest）</strong>或者<strong>指纹（Fingerprint）</strong>。</p><p><strong>单向散列函数（One-way Hash Function）</strong> 单向散列函数也被称为<strong>消息摘要函数（Message Digest Function）</strong>、<strong>哈希函数</strong>或者是<strong>杂凑函数</strong>。单向散列函数根据消息的内容来计算出散列值，在数据加密（如注册-登录）、文件完整性验证、版权处理、云盘秒传等方面有具体的应用。经典的单向散列函数算法有：<code>MD4、MD5、SHA家族以及HMAC</code>等，下面简单罗列单向散列函数的性质特征：</p><blockquote><p>❑ 对任意长度的消息计算得到的散列值是定长的。<br>❑ 计算散列值的速度快、效率高<br>❑ 消息相同，散列值一定相同，消息不同，散列值一定不同。<br>❑ 散列计算的过程是单向的，不可逆</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt0010.png?raw=true"></p><p><strong>碰撞（Collision）</strong> 虽然单向散列函数的性质中有<code>如果消息不同那么散列值一定不同</code>，但这并不是绝对的，两个不同的消息产生同一个散列值的情况称为<strong>碰撞</strong>，如果要将单向散列函数用于文件完整性检验，那么需要确保事实上不可能被认为的发现碰撞。</p><p><strong>抗碰撞性（Collision Resistance）</strong> 难以发现碰撞的性质被称为抗碰撞性，密码技术中所使用的单向散列函数都要求具备抗碰撞性。</p><p><strong>弱抗碰撞性</strong> 单向散列函数必须确保要找到和该条消息具有相同散列值的另外一条消息是非常困难的，这一性质被称为弱抗碰撞性。</p><p><strong>MD4</strong> 消息摘要算法第4版本，<strong>（Message Digest 4）</strong>1990年由Rivest设计，已经被破解并不安全。</p><p><strong>MD5</strong> 消息摘要算法第5版本，<strong>（Message Digest 5）</strong> Rivest于1991年设计的单向散列函数，能够产生128位的散列值，该算法的强抗碰撞性已经被攻破也不安全。</p><p><strong>SHA家族算法</strong> SHA家族拥有一系列的具体算法，包括：<code>SHA-1、SHA-256、SHA-384、SHA-512</code>等，这些算法均是由美国国家标准与技术研究院（National Institute of Standards and Technology，NIST）设计的单向散列函数。目前SHA-1的强抗碰撞性已经被攻破（2005年由山东大学王小云教授带领的团队提出了针对SHA-1的碰撞攻击算法）。</p><p><strong>消息认证码（Message Authentication Code，MAC）</strong> 消息认证码和消息摘要类似，区别在于消息摘要是消息的指纹，其散列计算并不涉及到具体的加密过程，而MAC则要求通信双方知道共享对称密钥用来准备MAC，其涉及到具体的加密过程。</p><p><strong>HAMC</strong> 是基于散列的消息认证码（<code>Hash-based Message Authentication Code ,HMAC</code>）其在IP协议中作为强制的安全实施方法，在SSL安全协议中也广泛使用，其核心思想是复用MD5和SHA-1这样的消息摘要算法，说白了HAMC是包含了加密的消息摘要算法，其本身存在实用性的问题。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/crypt0011.png?raw=true"></p><p><strong>公钥证书（Public-Key Certificate，PKC）</strong> 公钥证书简称为证书，内部包含了姓名、组织、邮箱等个人信息以及属于此人的公钥，并由<strong>第三方的认证机构(Certification Authority、Certifying Authority，CA)</strong>进行数字签名，只要看到公钥证书我们就能够确定该公钥的确属于此人。其实，简单的来理解的话，<code>证书就是对公钥进行数字签名</code>，它解决了非对称加密系统中存在的无法认证公钥问题。</p><p><strong>认证机构（Certification Authority，CA）</strong>是对证书进行管理的人。</p><p><strong>公钥基础设施（Public-Key Infrastructure）</strong> 是为了能够更有效地运用公钥而制定的一系列规范的总称，一般简称为PKI。需要注意的是PKI只是一个总称，而非某一个特定的规范或标准。</p><p><strong>混合加密系统</strong> 基于对称加密和非对称加密等算法的优缺点，在现实中使用的通常都是混合的加密系统。 &nbsp; &nbsp; <span style="border:1px solid #000"><strong>&nbsp; &nbsp; 混合加密系统 = 对称加密 + 非对称加密 + 单向散列函数 + 消息认证码 + 证书 + … &nbsp; &nbsp; </strong></span></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文不详细介绍具体的加密算法，仅仅罗列数据安全领域常见的专业术语，并作出简要释义和说明。大概可以分成两大类，一类是参与的相关方(就是人),另一类则是冷冰冰的词汇了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;密码学（cryptogr
      
    
    </summary>
    
    
      <category term="数据安全系列" scheme="https://weibo.com/u/3800117445/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>数据安全系列 Base64</title>
    <link href="https://weibo.com/u/3800117445/2018/07/31/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%20Base64/"/>
    <id>https://weibo.com/u/3800117445/2018/07/31/数据安全系列 Base64/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-08-02T03:52:23.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文科普数据处理中常用的Base64相关知识，包括Base64编码方案的内部细节、特征及应用，文章末还提供了iOS和JavaScript版本的Base64编码和解码方案。</p></blockquote><h3 id="Base64编码方案介绍"><a href="#Base64编码方案介绍" class="headerlink" title="Base64编码方案介绍"></a>Base64编码方案介绍</h3><p><code>Base64</code>是一种基于64个可打印字符来表示二进制数据的表示方法，简单点说就是<code>Base64编码方案可以使用由64个指定字符的排列组合方式来表示所有的二进制数据</code>。Base64可以用作电子邮件的传输编码，常用于处理(表示、传输和存储)文本数据的业务场景中，在网络安全数据处理方面有应用。</p><p>下面我们使用电脑中的命令行工具先简单感受下Base64的编码方式（我自己使用的Mac OSX系统的终端，如果是windows操作系统可以下载<a href="https://gitforwindows.org/" target="_blank" rel="external">Git终端工具</a>）。</p><p><strong>① 编码文件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">wendingding:Demo wendingding$ base64 123.png -o 123.text</div><div class="line">wendingding:Demo wendingding$ cat 123.text </div><div class="line"></div><div class="line">iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAYAAAAi2ky3AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAO</div><div class="line">I2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gC</div><div class="line">Ao9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5C</div><div class="line">Eh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDE</div><div class="line">L3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfP</div><div class="line">oTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358</div><div class="line">pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcS</div><div class="line">DiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lR</div><div class="line">xc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+</div><div class="line">bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/b</div><div class="line">yMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csd</div><div class="line">azLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o</div><div class="line">/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBl</div><div class="line">q3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6</div><div class="line">mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/S</div><div class="line">bMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2A</div><div class="line">tTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAAkSURBVCgVY2RkZPzPQAXARAUzwEaMGkQ4JEfDaDSMCIcAYRUAP</div><div class="line">hgBHp0GsDQAAAAASUVORK5CYII=</div><div class="line"></div><div class="line">wendingding:Demo wendingding$ base64 123.text -D -o new.png</div><div class="line">wendingding:Demo wendingding$ tree -L 2</div><div class="line">.</div><div class="line">├── 123.png</div><div class="line">├── 123.text</div><div class="line">└── new.png</div><div class="line">wendingding:Demo wendingding$ md5 123.png </div><div class="line">MD5 (123.png) = 314e5198b3d2da9fbfb0d85c398bcbe2</div><div class="line">wendingding:Demo wendingding$ md5 new.png </div><div class="line">MD5 (new.png) = 314e5198b3d2da9fbfb0d85c398bcbe2</div></pre></td></tr></table></figure></p><p>在上面的演示中我们首先对Demo文件目录下的123.png文件（图片）进行base64编码，把结果保存到123.text文件后又对123.text文件进行base64解码操作，并最终匹配解码后得到的文件和源文件。</p><p><strong>命令行说明</strong></p><p><code>$ base64 123.png -o 123.text</code> 表示对当前目录下的123.png图片进行base64编码结果保存到123.text。<br><code>$ cat 123.text</code> 表示列出123.text文件中的文本内容。<br><code>$ base64 123.text -D -o new.png</code> 表示对123.text文件进行base64解码，结果保存为new.png文件。<br><code>$ md5 123.png</code> 表示对123.png原文件进行md5散列计算，得到唯一散列值。<br><code>$ md5 new.png</code> 表示对new.png解码后的文件进行md5散列计算，得到唯一散列值。</p><p><strong>② 编码字符串</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"我失去了一只臂膀，就睁开一只眼睛"</span> | base64</div><div class="line">5oiR5aSx5Y675LqG5LiA5Y+q6IeC6IaA77yM5bCx552B5byA5LiA5Y+q55y8552b</div><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"5oiR5aSx5Y675LqG5LiA5Y+q6IeC6IaA77yM5bCx552B5byA5LiA5Y+q55y8552b"</span> | base64 -D</div><div class="line">我失去了一只臂膀，就睁开一只眼睛</div></pre></td></tr></table></figure><p>Base64可以对任意的二进制数据进行编码，不论原数据是什么样的（可以是图片、视频、文本、字符串等）编码后我们得到的总是一个由众多字符组成的字符串，而且Base64是可逆的。</p><p>Base64编码后得到的字符串由64位字符排列组合而成，这64位字符分别是：<span style="color:#195">字母A-Z、a-z、数字0-9、+和/</span>,下面列出Base64的索引表（摘自<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="external">Base64维基百科</a>）。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/base64_index.png?raw=true" width="400px"></p><div class="tip"><strong>注意</strong> 在进行编码的时候因为可能出现要编码的字节数不能被3整除的情况，所以实际编码得到的字符串文本中还可能出现特殊字符=符号。</div><h3 id="Base64的编码策略"><a href="#Base64的编码策略" class="headerlink" title="Base64的编码策略"></a>Base64的编码策略</h3><p><strong>编码</strong>  我们在写代码的时候直接面对处理的数据通常是文字、图像和声音等信息，计算机在操作的时候，要知道它们操作的对象并不是这些物化的具体的文字|声音|视频等内容，而是无差别的由0和1排列组合而成的比特序列。将现实世界中的内容映射成为比特序列的操作被称为<strong>编码（encoding）</strong>，常见的编码方案有ASCII 、GB2312(简体中文)和UTF-8等等，Base64也是其中的一种。</p><p>我们知道<strong><code>ASCII编码</code>（American Standard Code for Information Interchange，美国信息互换标准代码）</strong>这种通用的单字节编码系统中一共规定了128位字符，在具体进行编码的时候使用每8位一组的方式(即每个字符都使用八位的二进制数据来进行表示，注意这里实际只使用了7位，最前面的1位统一规定为0)来表示128种可能的字符。</p><div class="tip"><br>字节(Byte)是计算机技术中用于计量存储容量的一种计量单位，1字节等于8位(Bit)，即1 Byte = 8 Bit 。每1位可以存储0或1，表示两种状态。因为1个字节中拥有8位，每位存储的数据要么是0要么是1，所以1字节可以表示的数据范围为00000000~11111111，即2^8。<br></div><p>举个例子，如果我们需要处理Nice这个字符串单词，那么计算机使用不同的编码模式得到的比特序列结果是不一样的，下面给出ASCII编码和Base64编码的情况做对照。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/baseAndASCII.png?raw=true"></p><p>Base64在对字符进行连续编码的时候，总是<span style="color:#F58">以24位(3 x 8 = 24，3字节)为最小单位进行处理，把24位的数据以6位一组拆分为4组，把每一组的6位转换为二进制数据后查找Base64对应的索引表得到编码后的字符</span>,Base64编码后的数据比原文数据略长一些，大概是原文的4/3。为了帮助理解，下面给出了对Wen这三个字符进行base64编码的处理过程。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/wen.png?raw=true"></p><p><strong>说明</strong> <code>Wen三个字符</code>在ASCII中刚好占3个字节，使用3 X 8 = 24位二进制数据表示。我们先获取三个字符在ASCII编码中对应的十进制数字，分别为87、101和110，转换为二进制数据表示为：<span style="color:#195">01010111  01100101  01101110</span> ，然后把这24位二进制数据按照6位一组拆分为4组，即<span style="color:#195">010101  110110  010101  101110</span>，转换为十进制的数字对应为<strong>21、54、21和46</strong>，在base64索引表中查找对应的字符，最终得到<code>V2Vu</code>。</p><p><strong>关于结尾补齐的特殊处理</strong> 如果要编码的字节数不能被3整除，最后会多出1个或2个字节，那么在处理的时候会<span style="color:#195">先使用0字节值在末尾补足，使其能够被3整除，然后再进行Base64的编码，在进行编码的时候如果进行了补齐且最后6位全部为0那么转换为=符号</span>，下面以Yu这两个字符实例演示base64的处理过程。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/Yu.png?raw=true"></p><p>我们刚刚给出了Wen和Yu的base64编码案例，下面使用终端命令行进行验证。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"Wen"</span> | base64</div><div class="line">V2Vu</div><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"V2Vu"</span> | base64 -D</div><div class="line">Wen</div><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"Yu"</span> | base64</div><div class="line">WXU=</div><div class="line">wendingding:Source wendingding$ <span class="built_in">echo</span> -n <span class="string">"WXU="</span> | base64 -D</div><div class="line">Yu</div></pre></td></tr></table></figure></p><p>这里推荐一个base64编码和解码的<a href="http://tool.oschina.net/encrypt?type=3" target="_blank" rel="external">在线网站</a>，大家可以使用该网站来进行验证。</p><p><strong> 下面总结Base64编码的处理过程 </strong></p><blockquote><p>❒  将所有字符转化为ASCII码；<br>❒  将ASCII码转化为8位二进制；<br>❒  将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；<br>❒  统一在6位二进制前补两个0凑足8位；<br>❒  将补0后的二进制转为十进制；<br>❒  从Base64编码表获取十进制对应的Base64编码；</p></blockquote><h3 id="Base64编码和解密的代码实现"><a href="#Base64编码和解密的代码实现" class="headerlink" title="Base64编码和解密的代码实现"></a>Base64编码和解密的代码实现</h3><p>   <strong>① iOS开发</strong> 在iOS开发中，从iOS7.0 开始，苹果就提供了base64的编码和解码支持，如果是&lt;7.0的老项目也许您还能看到base64编码和解码的第三方框架，如果当前代码不再需要对iOS7.0以下版本提供支持，则建议使用新的API来进行替换。下面给出两个封装好的方法，其中base64EncodeString用于对字符串进行base64编码，base64DecodeString用于解码操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     <span class="comment">//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果</span></div><div class="line"> - (<span class="built_in">NSString</span> *) base64EncodeString:(<span class="built_in">NSString</span> *)string &#123;</div><div class="line">      </div><div class="line">      <span class="comment">//1.先把字符串转换为二进制数据</span></div><div class="line">      <span class="built_in">NSData</span> *data = [string dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line">         </div><div class="line">      <span class="comment">//2.对二进制数据进行base64编码，返回编码后的字符串</span></div><div class="line">      <span class="keyword">return</span> [data base64EncodedStringWithOptions:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line">         </div><div class="line">     <span class="comment">//对base64编码后的字符串进行解码</span></div><div class="line"> - (<span class="built_in">NSString</span> *) base64DecodeString:(<span class="built_in">NSString</span> *)string&#123;</div><div class="line"> </div><div class="line">       <span class="comment">//1.将base64编码后的字符串『解码』为二进制数据</span></div><div class="line">       <span class="built_in">NSData</span> *data = [[<span class="built_in">NSData</span> alloc]initWithBase64EncodedString:string options:<span class="number">0</span>];</div><div class="line">         </div><div class="line">       <span class="comment">//2.把二进制数据转换为字符串返回</span></div><div class="line">       <span class="keyword">return</span> [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>  <strong>② 前端开发</strong> 在浏览器环境中，JavaScript提供两个方法来处理Base64编码和解码操作：<code>btoa方法</code>将字符串或二进制值转化为Base64编码，<code>atob方法</code>将Base64编码转化为原来的编码。需要说明的是，在进行使用这些方法进行编码和解码的时候需要考虑到非ASCII码字符的情况，如果是非ASCII码字符那么需要插入浏览器转码的操作。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64Encode</span>(<span class="params"> str </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.btoa(<span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>( str )));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64Decode</span>(<span class="params"> str </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">escape</span>(<span class="built_in">window</span>.atob( str )));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 使用方法</span></div><div class="line">base64Encode(<span class="string">'Yu Hui：江湖再见！'</span>);                 <span class="comment">//WXUgSHVp77ya5rGf5rmW5YaN6KeB77yB</span></div><div class="line">base64Decode(<span class="string">"WXUgSHVp77ya5rGf5rmW5YaN6KeB77yB"</span>); <span class="comment">//Yu Hui：江湖再见！</span></div></pre></td></tr></table></figure><p><strong>Base64相关参考</strong></p><p>RFC 1421：<a href="https://tools.ietf.org/html/rfc1421" target="_blank" rel="external">https://tools.ietf.org/html/rfc1421</a><br>RFC 3548：<a href="https://tools.ietf.org/html/rfc3548" target="_blank" rel="external">https://tools.ietf.org/html/rfc3548</a><br>Base64维基百科词条：<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="external">https://zh.wikipedia.org/wiki/Base64</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文科普数据处理中常用的Base64相关知识，包括Base64编码方案的内部细节、特征及应用，文章末还提供了iOS和JavaScript版本的Base64编码和解码方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Base64编码方案介绍
      
    
    </summary>
    
    
      <category term="数据安全系列" scheme="https://weibo.com/u/3800117445/tags/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [012]-可爱的洪水猛兽</title>
    <link href="https://weibo.com/u/3800117445/2018/07/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B012%5D-%E5%8F%AF%E7%88%B1%E7%9A%84%E6%B4%AA%E6%B0%B4%E7%8C%9B%E5%85%BD/"/>
    <id>https://weibo.com/u/3800117445/2018/07/05/读书笔记 [012]-可爱的洪水猛兽/</id>
    <published>2018-07-04T16:11:18.000Z</published>
    <updated>2018-07-07T13:10:35.148Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">其实，韩寒的杂文比他的小说更好。</div><br><div style="color:#195; font-size:16px">※·※ 这一代人 ※·※</div><p><span style="color:#f25">政治可以关心的时代暂时还没有到来。</span></p><p>80后的到现在最大的才28岁，最小的19岁，也就是处长和处男之间，完全没有任何的权势，所以权力使用不当造成的后果再推卸到这代人身上是不公平的。[注：该文写于10年前，现在同样适用于90后]</p><p>有信仰自然是好事，关键是信仰带我们去向何方，如果信仰到我们去沟里，那我们还是暂且留在岸上看天色吧。</p><div style="color:#195; font-size:16px">※·※ 大师们，我等无条件臣服于您 ※·※</div><p>今天在人民网上看见有评论说，文化名人不应该在媒介发表不负责任的言论。尤其是大嘴巴言论导向舆论，出言不逊的结果是伤害整个民族的文学尊严。</p><p>怎么几句话就把整个民族的文学尊严给伤害了呢？</p><p>文学很容易编程政治的妓女，导致的结果就是，你跟对了人，你就是崇高和灵魂，你跟错了人，一模一样的文字，你就变成了反动和毒草。</p><p>一位有责任的文化人的基本修养是有骨气，说真话，不献媚，不阿谀，绝对不是对文学大师心怀尊敬之心，追念之心，文化人不是来烧香的。</p><p>唉，好好的文字狱怎么就没了呢？</p><div style="color:#195; font-size:16px">※·※ 给王唯懿 ※·※</div><p>对于死亡，我以前一直说，那是生命换了种模样，但和我们在分享同一个空间。</p><p>对于我，我希望我死的那天，我的人儿们，都念及我的好，我虽然有好有坏，但那天我的坏已经得到了偿还 ，而没人有能比我更好。</p><div style="color:#195; font-size:16px">※·※ 西 ※·※</div><p>算命的说我要求得功名，就在南方，要发财，就去北方。不能去西面，总之，不能去沾西字的地方。</p><p>明天我就要先飞去西安，然后转机去西宁，最后到西藏。依算命的结果，下一站是西天。</p><p>我就想这个世界，这个世界是不会变的。</p><div style="color:#195; font-size:16px">※·※ 电视台很X很XX ※·※</div><p>这是社会的进步，说明政府更加注重民心了。如果以前是直接强奸的话，现在已经讲究在强奸前做些前戏了。我这话很x很xx，不提倡。</p><p><span style="color:#f25">有些事情，无伤大雅，有些事情，你做错了，需要付出代价。</span></p><p>网民和城管不一样，他们都是光说不练的，都已经不练了还计较些什么呢，去管管那些光练不说的吧。</p><p>照片被大家看见了，以后你的偶像就和你坦诚相见了，所以，你比别的粉丝幸福，应该更加支持你的偶像才是。</p><div style="color:#195; font-size:16px">※·※ 2008年1号文件 ※·※</div><p>大家都知道，在我国，经常出现法律只能制裁守法者的事情。<br>我们老是说，他们的初衷是好的，但是初衷有什么用呢？<br>一刀切这个词其实是行政能力和法律落后的象征，因为一刀切谁都会。</p><p>我的心态和技术已经空前强大，只剩下运气是我不能决定的，狗啊，给我点狗屎运吧。</p><p>不要学我，你让我重来，我都学不像自己。</p><div style="color:#195; font-size:16px">※·※ 关于松岛枫 ※·※</div><p>希望道貌岸然者快点成长吧，然后要么开窍，要么死掉。</p><p>吹牛虽然不上税，但是好歹也得问问牛愿不愿意。</p><p>你说你想关心农民工，结果点到了松岛枫，这也太假了吧。</p><p>我们还有个毛病就是喜欢逼着人家道歉，就为了图自己一个意淫的舒服。</p><p>歪瓜裂枣的摆一排，图个声势嘛。</p><p>他们见坑就跳，见洞就掉。</p><p>在中国，“毒害”这个词语是政治手段。</p><p><span style="color:red">在通往民主的道路上，最大的阻碍就是人民。</span></p><p>你是否像鞭炮一样一点就着？一点就着的下场就是炮灰。</p><div style="color:#195; font-size:16px">※·※ 回答爱国者的问题 ※·※</div><p>爱国者问：祖国就是你的母亲…<br>韩寒回答：祖国是祖国，母亲是母亲。</p><p>爱国者问：你怎么对得起你脚下自己的土地…<br>韩寒回答：我没有自己的土地，你也没有自己的土地。</p><p>爱国主义不是免死金牌，爱国主义有时候反而送你一程。</p><p>人并不容易被煽动，但是人立志要做炮灰的时候，灰是比较容易被煽起来的。</p><p>我们能够统一思想，人家统一不了，这也就是西方世界普遍比较落后的原因。</p><div style="color:#195; font-size:16px">※·※ 关于汶川地震 ※·※</div><p>捐款不是喝喜酒送红包。<br>他们都是道德的小人，自己制定道德的准绳，在大家都忙着做善事没空的时候，他们闲着，指指点点。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.516it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.5it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;其实，韩寒的杂文比他的小说更好。&lt;/div&gt;&lt;br&gt;&lt;div style=&quot;color:#195; font-size:16px&quot;&gt;※·※ 这一代人 ※·※&lt;/div&gt;

&lt;p&gt;&lt;span style=&quot;color:#f25&quot;&gt;政治可以关心的时代
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[08] Gulp构建工具的基本使用</title>
    <link href="https://weibo.com/u/3800117445/2018/06/29/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B08%5D%20Gulp%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/06/29/前端工程化系列[08] Gulp构建工具的基本使用/</id>
    <published>2018-06-29T10:42:13.000Z</published>
    <updated>2018-06-29T16:05:29.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍前端开发中常用的构建工具Gulp，具体包括Gulp的基本情况、安装、使用以及常见插件的安装、配置和使用等内容。</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/gulp.png?raw=true" height="200px"></p><h3 id="Gulp介绍"><a href="#Gulp介绍" class="headerlink" title="Gulp介绍"></a>Gulp介绍</h3><p><strong>Gulp</strong><code>是使用JavaScript编写的，运行在Node.js上的一款自动化构建工具</code>，同类型的构建工具还有Grunt、Npm-script等。Gulp的构建系统基于流来实现，增加了监听文件、读写文件以及流式处理等功能，Gulp作为后起之秀整体来说比Grunt更加强大而且使用起来也更加简单，你值得拥有。</p><p><strong>Gulp优点</strong></p><blockquote><p>❏  基于流的操作，能更快速的构建项目并减少频繁的IO操作，更高效。<br>❏  提供最少的API，降低开发者的学习成本，自动构建相关代码更简单。<br>❏  代码优先的策略，让简单的任务简单处理，让复杂的任务变得可管理。<br>❏  严格的插件指南，确保所有的插件简单，职责单一能按期望方式工作。</p></blockquote><p><strong>Gulp和Grunt简单对比</strong><br><img src="https://github.com/flowerField/Source/blob/master/Blog/gulp01.png?raw=true"></p><p><strong>Gulp的组成结构</strong></p><p>Gulp本身和Grunt还是很相像的，Gulp项目主要由<code>Gulp-Cli</code>、<code>Node模块(本地的gulp和gulp插件)</code>以及<code>Gulpfile文件</code>构成。</p><blockquote><p><strong>Gulp-Cli &nbsp;&nbsp; ✧ </strong>  &nbsp;启动Gulp构建工具的命令行接口，全局安装。<br><strong>本地Gulp ✧ </strong>   &nbsp;构建时实际运行的本地程序,提供基本的API并加载构建指令和运行任务。<br><strong>Gulp插件 ✧ </strong>   &nbsp;Gulp构建工具生态系统中拥有众多高质量的插件，本质上是对特定任务的封装。<br><strong>Gulpfile文件 ✧ </strong> &nbsp;定义所有构建任务的配置文件，告诉本地Gulp如何执行具体构建操作的指令文件。</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/gulp02.png?raw=true"></p><p>上图是Gulp几个部分的关系图，这里做简单说明。</p><p><code>Gulp-cli</code>是Gulp的命令行工具，如果项目中要使用Gulp构建工具，那么必须先安装Gulp-cli，它的作用非常简单，就死检查当前项目里是否安装了本地的Gulp，如果安装了那么Gulp-cli会根据命令行中输入的命令参数来启动本地Gulp接管后续的操作。Gulp-cli通常需要全局安装，这样任何目录下面的Gulp才能够在终端中执行。</p><p><code>本地Gulp</code>主要有两个作用，一个是提供构建必要的基本API，另一个是加载并执行定义好的任务。需要注意的是，本地的Gulp才是真正的Gulp运行时，它负责处理所有的任务，而Gulp-Cli是本地Gulp的全局入口，它负责把所有的命令参数都转交给本地Gulp处理，之后由Gulp来接手具体的构建过程。</p><p>本地Gulp在运行的时候，需要读取<code>Gulpfile.js文件</code>的内容，Gulpfile.js文件主要加载Gulp插件，并且调用Gulp相关的api来定义task（任务）。Gulp具体要做什么操作，应该如何执行这些操作等都由Gulpfile.js文件决定。</p><p><strong>Gulp参考</strong></p><p><a href="https://gulpjs.com/" target="_blank" rel="external">Gulp官网</a><br><a href="https://gulpjs.com.cn" target="_blank" rel="external">Gulp官网（中文）</a><br><a href="https://gulpjs.com/plugins/" target="_blank" rel="external">Gulp官方插件列表页</a><br><a href="https://www.npmjs.com/package/gulp" target="_blank" rel="external">Gulp在npm的发布页</a><br><a href="https://legacy.gitbook.com/book/wizardforcel/gulp-doc/details" target="_blank" rel="external">Gulp中文文档-GitBook</a></p><h3 id="Gulp的安装"><a href="#Gulp的安装" class="headerlink" title="Gulp的安装"></a>Gulp的安装</h3><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;环境支持&nbsp; &nbsp;</strong></span></p><p>Gulp基于Node.js，所以在安装gulp之前，请确认已经在系统环境中安装了Node.js和npm（默认和Node绑定在一起安装）。</p><p>Node.js的安装请参考<a href="https://nodejs.org" target="_blank" rel="external">Node官网</a>，根据提示安装完成后，可以通过下面的命令来检查Node.js和npm是否被正确安装。</p><p><code>$ node --version</code><br><code>$ npm --version</code></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;Gulp-Cli的安装&nbsp; &nbsp;</strong></span></p><p>Node的环境准备好之后，接下来就可以来安装Gulp的命令行工具了。需要注意，Gulp的命令行工具需要全局安装，安装完成后可以通过查看版本号的方式来进行确认，下面给出安装命令。</p><p><code>$ npm install -g gulp-cli</code><br><code>$ gulp --version</code></p><p>这里顺便贴出终端执行细节。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wendingding$ node --version</div><div class="line">v8.9.3</div><div class="line">wendingding$ npm --version</div><div class="line">5.5.1</div><div class="line">wendingding$ npm install -g gulp-cli</div><div class="line">/usr/<span class="built_in">local</span>/bin/gulp -&gt; /usr/<span class="built_in">local</span>/lib/node_modules/gulp-cli/bin/gulp.js</div><div class="line">+ gulp-cli@2.0.1</div><div class="line">added 236 packages <span class="keyword">in</span> 89.58s</div><div class="line">wendingding$ gulp --version</div><div class="line">[17:23:12] CLI version 2.0.1</div></pre></td></tr></table></figure></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;本地Gulp的安装&nbsp; &nbsp;</strong></span></p><p>安装好Gulp的命令行工具后，就可以在您的项目目录中安装本地的局部Gulp了。本地的Gulp是真正运行构建任务的程序，全局的Gulp-Cli仅仅用于检查本地Gulp是否可用，如果可用那么就启动本地Gulp程序。安装成功后，本地的Gulp位于目录结构中的node_modules文件夹下。它包含了Gulpfile文件需要的所有函数和API。</p><p><strong>① 创建项目目录，使用命令行工具先进入当前路径（假设项目名称为GulpDemo）</strong></p><p><code>$ mkdir GulpDemo</code><br><code>$ cd GulpDemo/</code></p><p><strong>② 初始化环境，创建package.json文件</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">wendingding$ mkdir GulpDemo</div><div class="line">wendingding$ <span class="built_in">cd</span> GulpDemo/</div><div class="line">GulpDemo wendingding$ npm init</div><div class="line">This utility will walk you through creating a package.json file.</div><div class="line">It only covers the most common items, and tries to guess sensible defaults.</div><div class="line"></div><div class="line">See `npm <span class="built_in">help</span> json` <span class="keyword">for</span> definitive documentation on these fields</div><div class="line">and exactly what they <span class="keyword">do</span>.</div><div class="line"></div><div class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</div><div class="line">save it as a dependency <span class="keyword">in</span> the package.json file.</div><div class="line"></div><div class="line">Press ^C at any time to quit.</div><div class="line">package name: (gulpdemo)</div><div class="line">version: (1.0.0)</div><div class="line">description:</div><div class="line">entry point: (index.js)</div><div class="line"><span class="built_in">test</span> <span class="built_in">command</span>:</div><div class="line">git repository:</div><div class="line">keywords:</div><div class="line">author: 文顶顶</div><div class="line">license: (ISC)</div><div class="line">About to write to /Users/文顶顶/GulpDemo/package.json:</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"gulpdemo"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"文顶顶"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Is this ok? (yes) yes</div></pre></td></tr></table></figure></p><p><strong>③ 安装Gulp到当前项目中</strong></p><p><code>$ npm install --save-dev gulp</code></p><p><code>save-dev</code>参数的作用是把安装的Gulp版本正确保存在package.json文件中，命令行执行完毕后我们可以通过<code>cat指令</code>来查看package.json文件的内容，可以发现devDependencies字段增加了gulp信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">GulpDemo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"gulpdemo"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"文顶顶"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"gulp"</span>: <span class="string">"^3.9.1"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>④ Gulp安装好后，可以通过<code>--version</code>命令检查版本信息确认</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">GulpDemo wendingding$ gulp --version</div><div class="line">[19:30:11] CLI version 2.0.1</div><div class="line">[19:30:11] Local version 3.9.1</div><div class="line">GulpDemo wendingding$ Tree -L 1</div><div class="line">.</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">└── package.json</div></pre></td></tr></table></figure></p><p>现在全局的Gulp-Cli和本地的Gulp安装完毕，且package.json文件准备好后，就可以创建Gulpfile.js文件来处理具体的Task了。</p><h3 id="Gulp的基本使用"><a href="#Gulp的基本使用" class="headerlink" title="Gulp的基本使用"></a>Gulp的基本使用</h3><p>前面我们对Gulp进行了简单了介绍，并且已经在全局安装好了Gulp命令行工具并把Gulp安装到了当前项目（GulpDemo）中，接下来这里简单介绍下Gulp的基本使用。</p><p>Gulp要执行哪些任务，这些任务的具体执行方式等等的都由Gulpfile文件中的命令来决定，现在我们先在GulpDemo根目录下创建一个空的Gulpfile.js文件，然后编写具体的Task处理代码。</p><p>在根目录创建文件命令：<code>$ touch Gulpfile.js</code></p><p>Gulp的任务可以简单的划分为两种，一种是自定义任务，另外一种是使用Gulp插件，不管是什么类型的任务都通过gulp.task这个API来进行设置。</p><p><strong>自定义Task</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[01] 引入本地的Gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</div><div class="line"></div><div class="line"><span class="comment">//[02] 定义Task（自定义的任务）</span></div><div class="line">gulp.task(<span class="string">"demo"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"这是一个自定义的Task"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>编辑Gulpfile.js文件的内容，这里我们先引入了本地的gulp，然后通过gulp.task这个API定义了一个打印输出字符串的任务。gulp.task方法接收两个参数，第一个参数为任务的名称，第二个参数为表示具体任务的回调函数。当我们执行指定任务的时候，该任务对应的回调函数会被执行。</p><p>在终端中输入<code>$ gulp demo</code>指令来执行自定义任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GulpDemo wendingding$ gulp demo</div><div class="line">[20:22:40] Using gulpfile ~/GulpDemo/gulpfile.js</div><div class="line">[20:22:40] Starting <span class="string">'demo'</span>...</div><div class="line">这是一个自定义的Task</div><div class="line">[20:22:40] Finished <span class="string">'demo'</span> after 260 μs</div></pre></td></tr></table></figure></p><p><strong>Gulp插件Task</strong></p><p>在Gulp作为项目构建工具使用的时候，通常主要是使用现成的相关插件来处理Task的，因为Gulp生态的原因，Gulp的插件数量足够多，质量足够好。这里我们就以一款比较流行的JavaScript代码压缩和混淆插件<code>uglify</code>为例简单说明。</p><p>要使用某个插件，需要先把该插件下载安装到本地。</p><p>安装插件的命令  <code>$ npm install --save-dev gulp-uglify</code></p><p>上面的命令会把Uglify的Gulp插件下载到当前项目的node_modules文件夹下，并在package.json文件中保存相关的依赖信息。</p><p>插件安装完毕之后，我们在Gulpfile.js文件中需要先把要用到的插件引入进来，然后调用相关的API即可，下面给出代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[01] 引入本地的Gulp</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">"gulp"</span>);</div><div class="line"><span class="comment">//[02] 引入gulp-uglify插件</span></div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">"gulp-uglify"</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[03] 定义Task（自定义的任务）</span></div><div class="line">gulp.task(<span class="string">"demo"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"这是一个自定义的Task"</span>);</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//[04] 定义Task（插件）</span></div><div class="line">gulp.task(<span class="string">"uglifyTask"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">"src/js/*.js"</span>).pipe(uglify()).pipe(gulp.dest(<span class="string">"dist"</span>));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>然后通过<code>$ gulp uglifyTask</code>命令来执行uglifyTask任务即可，该任务执行的时候会把src/js/目录下面所有的js文件进行压缩混淆并把结果分别保存到dist目录下，下面简单列一下终端的执行情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GulpDemo wendingding$ gulp uglifyTask</div><div class="line">[23:58:51] Using gulpfile ~/GulpDemo/gulpfile.js</div><div class="line">[23:58:51] Starting <span class="string">'uglifyTask'</span>...</div><div class="line">[23:58:51] Finished <span class="string">'uglifyTask'</span> after 64 ms</div></pre></td></tr></table></figure><p>Gulp执行任务的时候，支持一次性执行多个任务，语法格式为：<code>$ gulp task1 task2</code>，上面的Gulpfile.js文件中如果要依次执行uglifyTask和demo这两个Task，那么可以像下面这样处理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">GulpDemo wendingding$ gulp uglifyTask demo</div><div class="line">[00:01:35] Using gulpfile ~/GulpDemo/gulpfile.js</div><div class="line">[00:01:35] Starting <span class="string">'uglifyTask'</span>...</div><div class="line">[00:01:35] Starting <span class="string">'demo'</span>...</div><div class="line">这是一个自定义的Task</div><div class="line">[00:01:35] Finished <span class="string">'demo'</span> after 185 μs</div><div class="line">[00:01:35] Finished <span class="string">'uglifyTask'</span> after 65 ms</div></pre></td></tr></table></figure></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍前端开发中常用的构建工具Gulp，具体包括Gulp的基本情况、安装、使用以及常见插件的安装、配置和使用等内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [06]-TypeScript语言特性(五)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/24/TypeScript%E7%B3%BB%E5%88%97%20%5B06%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%BA%94)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/24/TypeScript系列 [06]-typeScript语言特性(五)/</id>
    <published>2018-06-24T10:05:13.000Z</published>
    <updated>2018-06-25T09:45:19.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对TypeScript中的泛型进行展开介绍。主要包括以下内容</p><p>❏  泛型函数类型<br>❏  泛型接口（Interface）<br>❏  泛型类（Class）<br>❏  泛型约束</p></blockquote><h3 id="泛型函数的类型"><a href="#泛型函数的类型" class="headerlink" title="泛型函数的类型"></a>泛型函数的类型</h3><p>在<a href="http://wendingding.com/2018/06/23/TypeScript%E7%B3%BB%E5%88%97%20[05]-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E5%9B%9B" target="_blank" rel="external">TypeScript语言特性</a>)这篇文章中，我们已经介绍了什么是泛型函数，它跟普通函数还是有些区别的（泛型函数使用类型变量来占位，具体类型值由函数调用传参决定）。以前文章中介绍过TypeScript中的数据类型，以及可选的类型声明。虽然并没有必要（因为可以通过类型推导机制推导出来），但我们确实能够抽取出普通函数的具体类型。下面代码中demo函数的函数类型为：<code>(name:string,age:number) =&gt; string</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/03-函数的类型.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 函数的类型</span></div><div class="line"><span class="comment">//(1) 声明demo函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">name:string,age:number</span>):<span class="title">string</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名:"</span> +name + <span class="string">"年龄:"</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//(2) 把demo函数赋值给f</span></div><div class="line"><span class="keyword">let</span> f:<span class="function">(<span class="params">name:string,age:number</span>)=&gt;</span>string = demo;</div><div class="line"><span class="comment">//使用demo函数的调用签名</span></div><div class="line"><span class="comment">//let f:&#123;(name:string,age:number):string&#125; = demo;</span></div><div class="line"><span class="built_in">console</span>.log(f(<span class="string">"zs"</span>,<span class="number">18</span>));    <span class="comment">//姓名:zs年龄:18</span></div></pre></td></tr></table></figure><p>接下来，我们花点时间研究，泛型函数的函数类型。其实<span style="color:#195">泛型函数的类型与非泛型函数的类型本质上并没由什么不同，只是在最前面增加一个类型变量参数而已</span>。下面给出具体的代码示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function demoT&lt;T&gt;(arg:T):T&#123;</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="comment">//泛型函数demoT的类型为：&lt;T&gt;(arg:T) =&gt;T</span></div><div class="line">let f1 : &lt;T&gt;(arg:T) =&gt;T = demoT;</div><div class="line"><span class="comment">//使用带有调用签名的对象字面量来定义泛型函数</span></div><div class="line">let f2 : &#123;&lt;T&gt;(arg:T) :T&#125; = demoT;</div><div class="line"><span class="comment">//可以使用不同的泛型参数名（这里为X）</span></div><div class="line">let f3 : &lt;X&gt;(arg:X) =&gt;X = demoT;</div><div class="line"><span class="comment">//不使用类型声明</span></div><div class="line">let f4 = demoT;</div><div class="line"></div><div class="line">console.<span class="built_in">log</span>(f1(<span class="string">"abc"</span>));     <span class="comment">//abc</span></div><div class="line">console.<span class="built_in">log</span>(f2(<span class="string">"哈哈"</span>));     <span class="comment">//哈哈</span></div><div class="line">console.<span class="built_in">log</span>(f3(<span class="string">"嘿嘿"</span>));     <span class="comment">//嘿嘿</span></div><div class="line">console.<span class="built_in">log</span>(f4(<span class="string">"咕噜"</span>));     <span class="comment">//咕噜</span></div></pre></td></tr></table></figure></p><div class="tip"><strong>提示</strong> 泛型函数的类型声明可以使用不同的泛型参数，只要数量和使用方式一致即可。</div><h3 id="泛型接口（Interface）"><a href="#泛型接口（Interface）" class="headerlink" title="泛型接口（Interface）"></a>泛型接口（Interface）</h3><p><strong>接口（Interface）</strong><span style="color:#195">指在面向对象编程语言中，不包含数据和逻辑但使用函数签名定义行为的抽象类型。</span></p><p>TypeScript提供了接口特性，TypeScript的接口可以定义数据和行为，也可以扩展其它接口或者类。</p><p>在传统面向对象编程范畴中，一个类可以被扩展为另外一个类，也可以实现一个或多个接口。实现某个接口可以被看做是签署了一份协议，接口相当于协议，当我们签署协议（实现接口）后，就必须遵守它的规则。</p><p><span style="color:red">接口本身是抽象类型，其内容（规则）就是属性和方法的签名。</span></p><p>在前文中我们定义了泛型函数demoT，可以把demoT函数的签名抽取并定义接口GenericFn，下面给出示例代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/04-泛型接口.ts</span></div><div class="line"></div><div class="line"><span class="comment">//(1) 声明泛型函数demoT</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoT</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//(2) 定义GenericFn接口</span></div><div class="line">interface GenericFn&#123;</div><div class="line">    &lt;T&gt;(arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fn: GenericFn = demoT;</div><div class="line"><span class="built_in">console</span>.log(fn(<span class="string">"哈哈"</span>));  <span class="comment">//哈哈</span></div></pre></td></tr></table></figure></p><p>有时候，我们可能需要把泛型参数(T)抽取成为整个接口的参数，好处是抽取后我们能够清楚的知道使用的具体泛型类型是什么，且接口中的其它成员也能使用。当我们使用泛型接口的时候，传入一个类型参数来指定泛型类型即可，下面给出调整后的示例代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/05-泛型接口02.ts</span></div><div class="line"></div><div class="line"><span class="comment">//(1) 声明泛型函数demoT</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoT</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//(2) 定义泛型接口</span></div><div class="line">interface GenericFn&lt;T&gt;&#123;</div><div class="line">    (arg: T): T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> f1: GenericFn&lt;number&gt; = demoT;</div><div class="line"><span class="built_in">console</span>.log(f1(<span class="number">123</span>));       <span class="comment">//123</span></div><div class="line"><span class="comment">//报错：Argument of type '"字符串"' is not assignable to parameter of type 'number'.</span></div><div class="line"><span class="comment">//console.log(f1("字符串")); //错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> f2: GenericFn&lt;string&gt; = demoT;</div><div class="line"><span class="built_in">console</span>.log(f2(<span class="string">"字符串"</span>)); <span class="comment">//字符串</span></div></pre></td></tr></table></figure><h3 id="泛型类（Class）"><a href="#泛型类（Class）" class="headerlink" title="泛型类（Class）"></a>泛型类（Class）</h3><p>泛型特性可以应用在Class身上，具体的使用方式和接口差不多。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/06-泛型类.ts</span></div><div class="line"></div><div class="line"><span class="comment">//泛型类(Class)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">  <span class="comment">//[1] 属性部分</span></div><div class="line">  name:T;</div><div class="line">  color:T;</div><div class="line">  <span class="comment">//[2] 方法部分</span></div><div class="line">  add:<span class="function">(<span class="params">a:T,b:T</span>)=&gt;</span>T;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取实例对象p1</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person&lt;string&gt;();</div><div class="line">p1.name = <span class="string">"张三"</span>;</div><div class="line"></div><div class="line"><span class="comment">//报错： TS2322: Type '123' is not assignable to type 'string'.</span></div><div class="line"><span class="comment">//p1.name = 123;  错误的演示</span></div><div class="line">p1.color = <span class="string">"Red"</span>;</div><div class="line">p1.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(p1);                      <span class="comment">//&#123;name:"张三",color:"Red",...&#125;</span></div><div class="line"><span class="built_in">console</span>.log(p1.add(<span class="string">"ABC"</span>,<span class="string">"-DEF"</span>));    <span class="comment">//ABC-DEF</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//获取实例对象p2</span></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person&lt;number&gt;();</div><div class="line">p2.name = <span class="number">0</span>;</div><div class="line">p2.color = <span class="number">1</span>;</div><div class="line">p2.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(p2.add(<span class="number">100</span>,<span class="number">200</span>));         <span class="comment">//300</span></div></pre></td></tr></table></figure></p><p>上面的代码提供了泛型类使用的简单示例，在<code>定义泛型类的时候，只需要直接把泛型类型放在类名(这里为Person)后面即可</code>，通过new调用类实例化的时候，以&lt;类型&gt;的方式传递，在Class中应用泛型可以帮助我们确认类中的很多属性都在使用相同的类型，且能够优化代码结构。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>有时候，我们可能需要对泛型进行约束。下面的代码中我们声明了泛型函数fn，并在fn的函数体中执行<code>console.log(&quot;打印length值 = &quot; + arg.length);</code>意在打印参数的长度。这份代码在编译的时候会报错，因为无法确定函数调用时传入的参数一定拥有length属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/02-泛型函数使用注意点.ts</span></div><div class="line"><span class="comment">//说明 该泛型函数使用类型变量T来表示接收参数和返回值的类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"打印length值 = "</span> + arg.length);</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="comment">//报错：error TS2339: Property 'length' does not exist on type 'T'.</span></div><div class="line"><span class="built_in">console</span>.log(fn([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</div></pre></td></tr></table></figure><p>其实相比于操作any所有类型的数据而言，在这里我们需要对参数类型进行限制，要求传入的参数能够拥有length属性，这种场景可以使用泛型约束。</p><p>理想中泛型函数fn的工作情况是：“只要传入的参数类型拥有指定的属性length，那么代码就应该正常执行。 为此，需要列出对于T的约束要求。下面，我们先定义一个接口来描述特定的约束条件。然后使用这个接口和<code>extends关键字</code>来实现泛型约束，代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/07-泛型约束.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 定义用于描述约束条件的接口</span></div><div class="line">interface hasLengthP</div><div class="line">&#123;</div><div class="line">  length: number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] 声明fn函数(应用了泛型约束)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">hasLengthP</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"打印length值 = "</span> + arg.length);</div><div class="line">  <span class="keyword">return</span> arg</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[003] 调用测试</span></div><div class="line"><span class="built_in">console</span>.log(fn([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));   <span class="comment">//打印length值 = 3 [1,2,3];</span></div><div class="line"><span class="built_in">console</span>.log(fn(&#123;<span class="attr">name</span>:<span class="string">"zs"</span>,<span class="attr">length</span>:<span class="number">1</span>&#125;)); <span class="comment">//打印length值 = 1 对象内容</span></div><div class="line"></div><div class="line"><span class="comment">//说明：字符串会被转换为对象类型（基本包装类型）</span></div><div class="line"><span class="built_in">console</span>.log(fn(<span class="string">"测试"</span>));    <span class="comment">//打印length值 = 2 测试</span></div><div class="line"></div><div class="line"><span class="comment">//报错:error TS2345: Argument of type '123' is not assignable to parameter of type 'hasLengthP'.</span></div><div class="line"><span class="built_in">console</span>.log(fn(<span class="number">123</span>));   <span class="comment">//错误的演示</span></div></pre></td></tr></table></figure></p><p>上面代码中的fn<code>泛型函数被定义了约束，因此不再是适用于任意类型的参数。</code>我们需要传入符合约束类型的值，传入的实参必须拥有length属性才能运行。</p><p><strong>泛型约束中使用多重类型</strong></p><p><strong>提示</strong> 当声明泛型约束的时候，我们只能够关联一种类型。但有时候，我们确实需要在泛型约束中使用多重类型，接下来我们研究下它的可能性和实现方式。</p><p>假设现在有一个泛型类型需要被约束，它只允许使用实现Interface_One和Interface_Two两个接口的类型，考虑应该如何实现？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/08-泛型约束中使用多重类型01.ts</span></div><div class="line"></div><div class="line"><span class="comment">//定义接口：Interface_One和Interface_Two</span></div><div class="line">interface Interface_One&#123;</div><div class="line">  func_One();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Interface_Two&#123;</div><div class="line">  func_Two();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型类（泛型约束为Interface_One,Interface_Two）</span></div><div class="line"><span class="class"><span class="keyword">class</span>  <span class="title">classTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Interface_One</span>,<span class="title">Interface_Two</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  propertyDemo:T;</div><div class="line">  propertyDemoFunc()&#123;</div><div class="line">    <span class="keyword">this</span>.propertyDemo.func_One();</div><div class="line">    <span class="keyword">this</span>.propertyDemo.func_Two();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可能会像这样来定义泛型约束，然而上面的代码在编译的时候会抛出错误，也就是说<span style="color:red">我们不能在定义泛型约束的时候指定多个类型</span>（上面的代码中我们指定了Interface_One和Interface_Two两个类型），如果确实需要设计多重类型约束的泛型，可以通过把多重类型的接口转换为一个超接口来处理，下面给出示例代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/09-泛型约束中使用多重类型02.ts</span></div><div class="line"></div><div class="line"><span class="comment">//定义接口：Interface_One和Interface_Two</span></div><div class="line">interface Interface_One&#123;</div><div class="line">  func_One();</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Interface_Two&#123;</div><div class="line">  func_Two();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Interface_One和Interface_Two成为了超接口，它们是Interface_T的父接口</span></div><div class="line">interface Interface_T extends Interface_One,Interface_Two&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//泛型类</span></div><div class="line"><span class="class"><span class="keyword">class</span>  <span class="title">classTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Interface_T</span>&gt;</span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  propertyDemo:T;</div><div class="line">  propertyDemoFunc()&#123;</div><div class="line">    <span class="keyword">this</span>.propertyDemo.func_One();</div><div class="line">    <span class="keyword">this</span>.propertyDemo.func_Two();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  func_One:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"func_One"</span>);</div><div class="line">  &#125;,</div><div class="line">  func_Two:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"func_Two"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//获取实例化对象classTestA</span></div><div class="line"><span class="keyword">let</span> classTestA = <span class="keyword">new</span> classTest();</div><div class="line">classTestA.propertyDemo = obj;</div><div class="line">classTestA.propertyDemoFunc();    <span class="comment">//func_One func_Two</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//下面是错误的演示</span></div><div class="line"><span class="keyword">let</span> classTestB = <span class="keyword">new</span> classTest();</div><div class="line"></div><div class="line"><span class="comment">//报错: Type '&#123; func_Two: () =&gt; void; &#125;' is not assignable to type 'Interface_T'.</span></div><div class="line">classTestA.propertyDemo = &#123;</div><div class="line">  func_Two:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"func_Two_XXXX"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要对TypeScript中的泛型进行展开介绍。主要包括以下内容&lt;/p&gt;
&lt;p&gt;❏  泛型函数类型&lt;br&gt;❏  泛型接口（Interface）&lt;br&gt;❏  泛型类（Class）&lt;br&gt;❏  泛型约束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [05]-TypeScript语言特性(四)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/23/TypeScript%E7%B3%BB%E5%88%97%20%5B05%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E5%9B%9B)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/23/TypeScript系列 [05]-typeScript语言特性(四)/</id>
    <published>2018-06-23T10:05:13.000Z</published>
    <updated>2018-06-28T02:23:47.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要对TypeScript中的函数进行展开介绍。主要包括以下内容</p><p>❏  函数的创建和类型<br>❏  函数参数情况说明<br>❏  泛型函数简单介绍</p></blockquote><h3 id="函数的创建和类型"><a href="#函数的创建和类型" class="headerlink" title="函数的创建和类型"></a>函数的创建和类型</h3><p><strong>函数的创建</strong></p><p>函数的创建主要有两种方式：<code>通过函数声明创建</code>和<code>通过函数表达式创建</code>，在形式上函数又可以被划分文<code>命名函数</code>和<code>匿名函数</code>。此外，TypeScript中还提供了箭头函数支持，在声明箭头函数的时候，我们不再使用function关键字转而使用=&gt;标记。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ..07-函数深入讲解/01-函数的创建.ts</span></div><div class="line"></div><div class="line"><span class="comment">//测试变量声明提升</span></div><div class="line"><span class="built_in">console</span>.log(getName);   <span class="comment">//函数</span></div><div class="line"><span class="built_in">console</span>.log(getNameT);  <span class="comment">//undefined</span></div><div class="line"><span class="built_in">console</span>.log(f1);        <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 函数声明的方式创建(命名函数)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name:string</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"getName函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] 函数表达式的方式创建(匿名函数)</span></div><div class="line"><span class="keyword">var</span> getNameT = <span class="function"><span class="keyword">function</span> (<span class="params">name:string</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"getNameT函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[003] 箭头函数</span></div><div class="line"><span class="keyword">var</span> f1 = (name:string):<span class="function"><span class="params">string</span>=&gt;</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"f1函数=&gt;姓名 ："</span> + name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getName(<span class="string">"文顶顶"</span>));            <span class="comment">//getName函数=&gt;姓名 ：文顶顶</span></div><div class="line"><span class="built_in">console</span>.log(getNameT(<span class="string">"wendingding.com"</span>)); <span class="comment">//getNameT函数=&gt;姓名 ：wendingding.com</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="string">"奥特曼"</span>));                 <span class="comment">//f1函数=&gt;姓名 ：奥特曼</span></div></pre></td></tr></table></figure></p><p>因为JavaScript语言中<code>变量声明提升</code>的特性，所以<strong>通过函数声明方式创建的命名函数</strong>和<strong>通过函数表达式方式创建的匿名函数</strong>其使用特征也很不一样。熟悉JavaScript语言中<code>变量提升</code>特性的开发者应该非常清楚，所谓变量声明的提升，指的是在真正执行JavaScript代码前解释器会有个预解析的阶段，在这个阶段中会检查代码中所有的变量声明并把这些声明提升到当前作用域的顶部。</p><div class="tip">需要注意的是，很多人可能并不能够准确的区分清楚代码中哪部分是变量声明，哪部分不属于它，这里进行简单说明。</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//(1)表示声明一个变量a，并未赋值</span></div><div class="line"><span class="keyword">var</span> a;   </div><div class="line"><span class="comment">//(2)表示声明一个变量b,并把123赋值给变量b</span></div><div class="line"><span class="comment">//这行代码有两部分组成，其结构为 声明 + 赋值</span></div><div class="line"><span class="comment">//等价于 var b; b = 123;两行代码</span></div><div class="line"><span class="keyword">var</span> b = <span class="number">123</span>;</div></pre></td></tr></table></figure><p><span style="color:#195">JavaScript预解析阶段在进行变量声明提升的时候，仅仅会把变量的声明部分进行提升，而赋值操作留在原地</span>。因为函数其实本质上也是变量，所以同样适用上面的规则。</p><p><strong>代码说明：</strong>观察第一份示例代码，代码中以函数声明方式创建的命名函数getName，其作为函数(变量)声明在预解析阶段会被整体提升，而匿名函数（赋值给了变量getNameT）因为有赋值操作，所以在预解析阶段只会将变量声明这部分(var getNameT)提升到作用域顶部，赋值操作会被留在原地。</p><p><strong>函数的类型</strong></p><p>我们知道在TypeScript语言中，可以使用可选的类型声明来显示的指定变量的类型，函数其实也算是变量，多以我们可以在声明函数的时候，显示的声明其类型。</p><p>我们先看下面的函数示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1:number,num2:number</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"传入的参数分别为:"</span>+num1+<span class="string">"和 "</span>+ num2 + <span class="string">"add的结果为:"</span> + (num1 + num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码中声明了add函数，并指定了该函数需要接受两个number类型的参数（分别为num1和num2），返回值为字符串类型。其实作为特殊的变量，我们也可以给函数也声明类型，在进行函数类型声明的时候，其语法结构同变量可选的类型声明没什么两样，结构均为：<span style="color:red">声明变量键字 + 变量(函数)名 ：类型</span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//001 声明变量</span></div><div class="line"><span class="keyword">let</span> str:string;</div><div class="line"><span class="comment">//002 声明变量并做初始化赋值操作</span></div><div class="line"><span class="keyword">let</span> sum:number = <span class="number">123</span>;</div><div class="line"></div><div class="line"><span class="comment">//[001]提供函数变量并显示的声明函数的类型（参数和返回值等情况）</span></div><div class="line"><span class="keyword">let</span> f1:<span class="function">(<span class="params">name:string,age:number</span>) =&gt;</span> string;</div><div class="line"><span class="comment">//赋值操作</span></div><div class="line">f1 = <span class="function"><span class="keyword">function</span> (<span class="params">name:string,age:number</span>):<span class="title">string</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名:"</span> +name + <span class="string">"年龄:"</span> + age;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数调用</span></div><div class="line">str = f1(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(str);   <span class="comment">//姓名:zs年龄:18</span></div></pre></td></tr></table></figure><p><code>let f1:(name:string,age:number) =&gt; string;</code>这行代码中的<code>(name:string,age:number) =&gt; string</code>用于表示函数的具体类型，我们可以发现函数的类型声明由三部分组成：<code>形参</code> + <code>=&gt;标记</code> +<code>返回值类型</code>。上面的代码中函数的类型声明和赋值操作是分开处理的，你当然也可以像普通变量那样把这两个操作合二为一，下面给出改写后的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 声明函数（函数被指定了类型）</span></div><div class="line"><span class="keyword">let</span> str1:string;</div><div class="line"><span class="keyword">let</span> f2:<span class="function">(<span class="params">name:string,age:number</span>) =&gt;</span> string = <span class="function"><span class="keyword">function</span> (<span class="params">name:string,age:number</span>):<span class="title">string</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名:"</span> +name + <span class="string">"年龄:"</span> + age;</div><div class="line">&#125;  </div><div class="line">str1 = f2(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(str1);    <span class="comment">//姓名:zs年龄:18</span></div></pre></td></tr></table></figure><p><strong>建议：</strong><span style="color:#195">在使用TypeScript设计函数的时候，不建议像上面示例代码这样来为函数指明类型，因为函数的类型可以从被赋值的函数推断出来，因此我们给函数添加类型声明并不是必需的，相反这样做还会让代码变得冗余且难以理解和阅读。</span></p><h3 id="函数参数情况说明"><a href="#函数参数情况说明" class="headerlink" title="函数参数情况说明"></a>函数参数情况说明</h3><p><strong>可选参数</strong></p><p>在使用JavaScript设计函数的时候，如何函数调用时传入的实参和声明时的形参不一致也能工作，但TypeScript中会对函数参数的类型以及参数的个数进行更严格的检查，我们来看下面的代码示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:string,age:number,isStudent:boolean</span>) : <span class="title">string</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> result:string;</div><div class="line">  result = <span class="string">"姓名: "</span> + name + <span class="string">"年龄: "</span> + age;</div><div class="line">  <span class="keyword">if</span>(isStudent)</div><div class="line">  &#123;</div><div class="line">    result += <span class="string">" 是否为学生? "</span> + isStudent;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">18</span>,<span class="literal">true</span>));  <span class="comment">//姓名: 文顶顶 年龄: 18 是否为学生? true</span></div><div class="line"></div><div class="line"><span class="comment">//错误的演示：error TS2554: Expected 3 arguments, but got 2.</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">20</span>));</div></pre></td></tr></table></figure><p>如果函数中某些参数并非必须的，我们希望该函数在调用的时候无论是否传递某些参数，函数都要能够继续工作，这需要用上TypeScript为我们提供的<span style="color:#195">可选参数特性</span>。</p><p><span style="color:#f25">函数可选参数的具体用法非常简单，我们只需要在函数形参名称后面加上一个？字符即可</span>，调整getInfo方法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../07-函数深入讲解/03-函数的可选参数02.ts</span></div><div class="line"></div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:string,age:number,isStudent?:boolean</span>) : <span class="title">string</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> result:string;</div><div class="line">  result = <span class="string">"姓名: "</span> + name + <span class="string">" 年龄: "</span> + age;</div><div class="line">  <span class="keyword">if</span>(isStudent)</div><div class="line">  &#123;</div><div class="line">    result += <span class="string">" 是否为学生? "</span> + isStudent;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">18</span>,<span class="literal">true</span>));  <span class="comment">//姓名: 文顶顶 年龄: 18 是否为学生? true</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">20</span>));       <span class="comment">//姓名: 文顶顶 年龄: 20</span></div></pre></td></tr></table></figure></p><div class="tip">注意：所有的可选参数必须位于必选参数列表的最后。</div><p><strong>参数的默认值</strong></p><p>当函数中存在可选参数的时候，在函数体中我们必须要对可选参数是否传递进行检测，这种情况我们使用<code>为可选参数设置默认值</code>会更合适。</p><p>在上面的代码中，因为getInfo函数的isStudent属性是可选的，所以我们在函数体内的实现代码中访问isStudent前必须先进行检查，而通过<code>形参名称 ： 参数类型 = 默认值的</code>方式能够避免这样做，还能够大大的提升代码的可阅读性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../07-函数深入讲解/05-函数的可选参数03.ts</span></div><div class="line"></div><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">name:string,age:number,isStudent:boolean = false</span>) : <span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"姓名: "</span> + name + <span class="string">" 年龄: "</span> + age +  <span class="string">" 是否为学生? "</span> + isStudent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">18</span>,<span class="literal">true</span>));  <span class="comment">//姓名: 文顶顶 年龄: 18 是否为学生? true</span></div><div class="line"><span class="built_in">console</span>.log(getInfo(<span class="string">"文顶顶"</span>,<span class="number">20</span>));       <span class="comment">//姓名: 文顶顶 年龄: 20 是否为学生? false</span></div></pre></td></tr></table></figure></p><div class="tip">注意：所有设置默认值的参数必须位于所有必选参数列表的最后。</div><p><strong>参数不确定的函数</strong></p><p>我们在设计函数的时候，有时该函数能够接受的参数个数是不确定的，比如说现在需要设计一个计算累加和的函数，该函数能够接受任意多个number类型的数据。我们可以通过<code>...形参名:参数类型</code>的方式来处理这种情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../07-函数深入讲解/06-函数的参数不确定.ts</span></div><div class="line"><span class="comment">//[001] 在声明函数的时候，不提供形参和类型声明</span></div><div class="line"><span class="comment">//TypeScript编译不通过，当调用时候报错：sum函数接收的参数个数为0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">        result += <span class="built_in">arguments</span>[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</div><div class="line">sum(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[002] 在声明函数的时候，不提供形参和类型声明</span></div><div class="line"><span class="comment">//TypeScript编译不通过，当调用时候报错：sum函数接收的参数个数为0</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">...numbers:number[]</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result:number = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</div><div class="line">        result += numbers[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line">sum1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);      <span class="comment">//7</span></div><div class="line">sum1(<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>);  <span class="comment">//24</span></div></pre></td></tr></table></figure><p><strong>建议:</strong> 使用<code>...形参</code>的语法来处理函数参数不确定情况其编译为JavaScript代码后本质还是遍历arguments，所以其实这种情况，在设计的时候可以考虑让函数接收一个数组参数。</p><h3 id="泛型函数简单介绍"><a href="#泛型函数简单介绍" class="headerlink" title="泛型函数简单介绍"></a>泛型函数简单介绍</h3><p><strong>泛型说明</strong></p><p><strong>泛型编程</strong><code>是一种程序语言的编程风格，它允许开发者使用以后才会定义的类型，并在实例化的时候作为参数指定这些类型</code>。简而言之，当函数中某些参数或返回值的数据类型不确定时，使用泛型编程能够把数据类型作为一种参数传递进来。</p><p><strong>类型变量T</strong></p><p>我们先看一个简单的示例。</p><p>假设现在需要设计这样一个函数，它接收一个参数并返回任何传给它的值，参数的类型不指定。在实现这种设计需求的时候，因为函数参数的类型不指定，所以我们可能首先想到的就是使用any类型，给出下面的代码示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/01-泛型函数简单介绍.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 示例代码1</span></div><div class="line"><span class="comment">//说明 该函数接收一个string类型的参数，并返回传入的数据</span></div><div class="line"><span class="comment">//缺点 限定了函数的参数类型以及返回值类型必须是string</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">str:string</span>):<span class="title">string</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//wendingding.com</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="string">"wendingding.com"</span>));</div><div class="line"></div><div class="line"><span class="comment">//[002] 示例代码2</span></div><div class="line"><span class="comment">//说明 该函数接收一个任意类型的参数，并返回传入的数据</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">arg:any</span>):<span class="title">any</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f2(<span class="string">"字符串测试"</span>));   <span class="comment">//字符串测试</span></div><div class="line"><span class="built_in">console</span>.log(f2(<span class="number">123</span>));          <span class="comment">//123</span></div><div class="line"><span class="built_in">console</span>.log(f2(<span class="literal">true</span>));        <span class="comment">//true</span></div></pre></td></tr></table></figure><p>示例代码002解决了参数可以是任意类型的问题，但简单使用any类型并不足以表达<code>传入参数和返回值参数必须类型一致</code>这个要求，简单说<code>传入的类型与返回的类型应该是相同的</code>这个信息点丢失了或者说表现得不够明确。</p><p>因此，我们需要一种方法来明确的表示返回值的类型与传入参数的类型应该是相同的。下面的代码中，我们使用类型变量来设计一个泛型函数，类型变量是一种特殊的变量，只用于表示类型而不是值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[003] 示例代码3</span></div><div class="line"><span class="comment">//说明 该泛型函数使用类型变量T来表示接收参数和返回值的类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f3&lt;string&gt;(<span class="string">"字符串"</span>));      <span class="comment">//字符串</span></div><div class="line"><span class="built_in">console</span>.log(f3&lt;number&gt;(<span class="number">345</span>));          <span class="comment">//345</span></div><div class="line"><span class="built_in">console</span>.log(f3&lt;boolean&gt;(<span class="literal">false</span>));        <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="string">"字符串-类型推导"</span>));      <span class="comment">//字符串-类型推导</span></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="number">123</span>));                 <span class="comment">//123</span></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="literal">true</span>));                <span class="comment">//true</span></div></pre></td></tr></table></figure><p>代码中函数接收参数的类型以及返回值的类型我们使用T这个类型变量来表示，T表示的具体类型由函数调用时具体的实参类型决定。如果实参是字符串，那么T就是string类型，如果实参是布尔类型的值，比如true或者是false，那么T就是boolean类型的。</p><blockquote><p><strong>定义了泛型函数后，有两种调用方式</strong><br>❏  调用函数的时候，使用<code>&lt; &gt;</code>明确的传入T的类型。<br>❏  利用类型推导来确定T的类型。</p></blockquote><p><strong>泛型函数使用注意</strong></p><p><strong> 注意 </strong> <span style="color:red">使用泛型函数的时候，编译器要求我们在函数体内必须正确的使用这个通用的类型。 换句话说，我们必须把这些参数当做是任意类型的数据来组织代码，否则可能会出现编译错误。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../08-泛型函数/02-泛型函数使用注意点.ts</span></div><div class="line"></div><div class="line"><span class="comment">//说明 该泛型函数使用类型变量T来表示接收参数和返回值的类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"打印length值 = "</span> + arg.length);</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//报错：error TS2339: Property 'length' does not exist on type 'T'.</span></div><div class="line"><span class="built_in">console</span>.log(fn([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));</div></pre></td></tr></table></figure><p>上面的代码在编译的时候，编译器报错<code>T类型</code>没有length这个属性。错误的原因在于我们在函数体中使用了arg的.length属性，但是却没有在任何地方指明arg具有这个属性。</p><p>类型变量(T)表示的是任意类型，而调用这个函数时传入实参可能是数字或true，它们并不具有.length属性。如果我们能够确定函数参数是数组类型的，而数组元素的类型不确定，那么可以像下面这样来组织代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//调整组织代码的方式[001]</span></div><div class="line">function f1&lt;T&gt;(arg:T[]):T[]&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"打印length值 = "</span> + arg.length);</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f1([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]));                    <span class="comment">//打印length值 = 3 [1,2,3]</span></div><div class="line"><span class="built_in">console</span>.log(f1([<span class="string">"str1"</span>,<span class="string">"str2"</span>,<span class="string">"demo"</span>]));     <span class="comment">//打印length值 = 3 ["str1","str2","demo"]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//调整组织代码的方式[002]</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:Array&lt;T&gt;</span>):<span class="title">Array</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"数组的长度为 = "</span> + arg.length);</div><div class="line">  <span class="keyword">return</span> arg;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f2([<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>]));                    <span class="comment">//打印length值 = 4 [2,4,8,16]</span></div></pre></td></tr></table></figure></p><div class="tip"><strong>提示</strong> 使用泛型函数的时候千万不能先入为主想当然。</div><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要对TypeScript中的函数进行展开介绍。主要包括以下内容&lt;/p&gt;
&lt;p&gt;❏  函数的创建和类型&lt;br&gt;❏  函数参数情况说明&lt;br&gt;❏  泛型函数简单介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;函数的创建和类型&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [04]-TypeScript语言特性(三)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/21/TypeScript%E7%B3%BB%E5%88%97%20%5B04%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%89)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/21/TypeScript系列 [04]-typeScript语言特性(三)/</id>
    <published>2018-06-21T10:05:13.000Z</published>
    <updated>2018-06-21T11:50:30.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文简单介绍TypeScript语言中的以下特性：<br>❏  解构赋值<br>❏  函数介绍<br>❏  命名空间</p></blockquote><h3 id="解构-amp-展开"><a href="#解构-amp-展开" class="headerlink" title="解构&amp;展开"></a>解构&amp;展开</h3><p><span style="color:red">解构赋值语法</span>使得我们可以将值从数组或者将属性从对象中提取对应的变量中。下面我们将简单介绍解构赋值特性在数组、对象以及函数声明中的用法。因为解构特性存在被误用的问题且复杂的表达式常常难以理解，所以<strong><span style="color:red">建议我们在设计代码的时候表达式要尽量保持小而简单</span></strong>。</p><p><strong>解构数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径  ../04-解构和展开/01-解构数组.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构数组简单介绍</span></div><div class="line"><span class="comment">//声明变量arrM(数组)</span></div><div class="line"><span class="keyword">let</span> arrM:number[] = [<span class="number">100</span>,<span class="number">200</span>];</div><div class="line"></div><div class="line"><span class="comment">//解构操作</span></div><div class="line"><span class="comment">//从arrM数组中提取索引为0和1的元素赋值给新声明的变量one和two</span></div><div class="line"><span class="keyword">let</span> [one,two] = arrM;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"one = "</span> + one);    <span class="comment">//one = 100</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"two = "</span> + two);    <span class="comment">//one = 200</span></div></pre></td></tr></table></figure><p>我们通过<code>let [one,two] = arrM</code>这行代码，提取了arrM数组中的前两个元素分别赋值给新声明的变量one和two，这行代码等价于<code>var one = arrM[0], two = arrM[1];</code>分别取值并赋值操作。</p><p>下面给出代码示例，简单演示了如何解构数组中的部分元素（包括：开头位置、结尾位置、指定位置等情况）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 解构数组中的部分元素</span></div><div class="line"><span class="keyword">let</span> arr:string[] = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>];</div><div class="line"><span class="comment">//开始位置</span></div><div class="line"><span class="keyword">let</span> [first] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"first = "</span> + first); <span class="comment">//first = one</span></div><div class="line"></div><div class="line"><span class="comment">//结尾位置</span></div><div class="line"><span class="keyword">let</span> [,,,last] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"last = "</span> + last); <span class="comment">//last = four</span></div><div class="line"></div><div class="line"><span class="comment">//指定位置（提取数组中第一个元素赋值给a,第三个元素赋值给c）</span></div><div class="line"><span class="keyword">let</span> [a,,c,] = arr;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span> + a + <span class="string">" c = "</span> + c); <span class="comment">//a = one c = three</span></div></pre></td></tr></table></figure></p><p><strong>解构对象</strong></p><p>除了解构数组外，我们还能够以同样的方式来提取对象中的属性值赋值给声明的同名变量，下面给出代码示例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/02-解构对象.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构对象简单介绍</span></div><div class="line"><span class="keyword">let</span> objM:any = &#123;<span class="attr">author</span>:<span class="string">"文顶顶"</span>,<span class="attr">address</span>:<span class="string">"wendingding.com"</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">color</span>:<span class="string">"red"</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;author,age,address&#125; = objM;</div><div class="line"></div><div class="line"><span class="comment">//解构的顺序并不重要</span></div><div class="line"><span class="comment">//let &#123;author,address,age&#125; = objM;  </span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"author = "</span>+author);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"age = "</span>+age);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"address = "</span>+address);</div><div class="line"></div><div class="line"><span class="comment">//解构对象的操作说白就就是通过指定的key到对象中取值</span></div><div class="line"><span class="comment">//let &#123;author,age,address&#125; = objM;代码和下面的代码等价</span></div><div class="line"><span class="keyword">var</span> author = objM.author, age = objM.age, address = objM.address;</div></pre></td></tr></table></figure></p><div class="tip"><strong>注意:</strong> 因为对象和数组组织数据的方式不太一样，对象在存储数据的时候是以键值对（key-value）的方式处理，所以<span style="color:#195">我们在解构对象的时候，声明的变量需要和对象中待提取的键值对同名,顺序关系并不重要</span>。</div><p>对象在解构的时候要求声明的变量和提取的对象属性同名，但是在业务场景中我们可能希望声明新的变量（即不使用属性的同名变量），这种情况需要在解构的时候进行重命名操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 对象解构属性重命名</span></div><div class="line"><span class="keyword">let</span> obj:any = &#123;<span class="attr">className</span>:<span class="string">"软件工程"</span>,<span class="attr">classNumber</span>:<span class="string">"软件工程_02"</span>,<span class="attr">date</span>:<span class="string">"2016-09-01"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//在解构对象的时候，支持重命名的方式</span></div><div class="line"><span class="keyword">let</span> &#123;className,<span class="attr">classNumber</span>:classNO,<span class="attr">date</span>:classDate&#125; = obj;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"班级名称 className = "</span> + className); <span class="comment">//班级名称 className = 软件工程</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"班级编号 classNO = "</span> + classNo);     <span class="comment">//班级编号 classNO = 软件工程_02</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"开学日期 classDate = "</span> + classDate); <span class="comment">//开学日期 classDate = 2016-09-01</span></div></pre></td></tr></table></figure></p><p>上面的代码中，在解构对象obj的时候，classNumber被重命名为classNO，date被重命名为classDate，需要注意的是重命名后，classNumber和date均不能使用。此外，对象解构的时候还支持对没使用关键字声明的变量解构以及静态类型声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[003] 支持使用字面量对象来解构赋值</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> a:string;</div><div class="line"><span class="keyword">let</span> b:string;</div><div class="line">(&#123;a , b &#125; = &#123;<span class="attr">a</span>:<span class="string">"我是A"</span>,<span class="attr">b</span>:<span class="string">"我是B"</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"a = "</span> + a);  <span class="comment">//a = 我是A</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"b = "</span> + b);  <span class="comment">//b = 我是B</span></div><div class="line"></div><div class="line"><span class="comment">//[004]支持对变量进行类型声明</span></div><div class="line"><span class="keyword">let</span> o = &#123;<span class="string">"des"</span>:<span class="string">"描述信息"</span>,<span class="string">"num"</span>:<span class="number">20</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;des, num&#125;: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = o;</div><div class="line"><span class="built_in">console</span>.log(des);   <span class="comment">//描述信息</span></div><div class="line"><span class="built_in">console</span>.log(num);   <span class="comment">//20</span></div></pre></td></tr></table></figure><div class="tip"><strong>注意:</strong><code>({a , b } = {a:&quot;我是A&quot;,b:&quot;我是B&quot;})</code>外层必须要加上（），因为JavaScript在解析的时候通常把 { 起始的语句解析为一个块。</div><p><strong>交换变量和设置默认值</strong></p><p>TypeScript中的解构特性为我们提供了一种方便的交换两个变量值的机制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[001] 交换变量</span></div><div class="line"><span class="keyword">let</span> first:string = <span class="string">"我是第一个_first"</span>;</div><div class="line"><span class="keyword">let</span> last:string = <span class="string">"我是最后一个_last"</span>;</div><div class="line"></div><div class="line">[first , last] = [last,first];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"first =&gt;"</span> + first);  <span class="comment">//first =&gt;我是最后一个_last</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"last  =&gt;"</span> + last);   <span class="comment">//last  =&gt;我是第一个_first</span></div></pre></td></tr></table></figure></p><p><strong>说明</strong>：交换变量在具体处理的时候，会生成一个内部的临时变量(请参考编译成JavaScript后的代码)。</p><p>为了有效防止从数组或对象中取出一个值为undefined的数据，我们可以在解构的时候为它们设置默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[002] 解构数组或对象的时候设置默认值</span></div><div class="line"><span class="keyword">let</span> [a,b = <span class="number">20</span>,c] = [<span class="number">10</span>];  <span class="comment">//解构操作</span></div><div class="line"><span class="built_in">console</span>.log(a,b,c);       <span class="comment">//10 20 undefined</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> color,age;</div><div class="line">(&#123;color = <span class="string">"yellow"</span>,age&#125; = &#123;<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">color</span>:<span class="literal">undefined</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(color);   <span class="comment">//yellow</span></div><div class="line"><span class="built_in">console</span>.log(age);     <span class="comment">//18</span></div><div class="line"></div><div class="line"><span class="comment">//解构对象的时候重命名属性并设置默认值</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">one</span>:_one = <span class="string">"哈哈哈"</span>, <span class="attr">two</span>:_two = <span class="string">"嘿嘿"</span>&#125; = &#123;<span class="attr">one</span>:<span class="string">"我是one"</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(_one);    <span class="comment">// 我是one</span></div><div class="line"><span class="built_in">console</span>.log(_two);    <span class="comment">// 嘿嘿</span></div></pre></td></tr></table></figure><p>观察上面的代码，数组中只有一个元素，对象中的color属性对应的值为undefined，我们可以通过在解构的代码中为变量设置默认值的方式来避免取出的值为undefined，其逻辑是：<span style="color:#195">如果解构提取的值非undefined那么就使用，如果是undefined，则检查该变量是否设置默认值，若有则使用</span>。</p><p><strong>解构用于函数参数</strong></p><p>解构除用于对象和数组外，还能作用于函数参数，如果函数调用时候可能缺省部分参数，那么还可以设置默认值增加函数的健壮性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/03-解构用于函数参数.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 解构用于函数参数(数组)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">[first, second]: [number, number]</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(first);   <span class="comment">//1</span></div><div class="line">    <span class="built_in">console</span>.log(second);  <span class="comment">//2</span></div><div class="line">&#125;</div><div class="line">x([<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line"></div><div class="line"><span class="comment">//[002] 解构用于函数参数(对象)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; a, b &#125;: &#123; a: string, b?: number &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行函数"</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"a的值为: "</span> + a,<span class="string">"b的值为: "</span> + b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">f(&#123;<span class="attr">a</span>:<span class="string">"AAAA"</span>,<span class="attr">b</span>:<span class="number">20</span>&#125;);   <span class="comment">//a的值为: AAAA b的值为: 20</span></div><div class="line"></div><div class="line"><span class="comment">/*****=======================******/</span></div><div class="line"><span class="comment">//[003]解构用于函数参数并设置默认值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">&#123; color, age = <span class="number">99</span> &#125;: &#123; color: string, age?: number &#125;</span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"color的值为: "</span> + color,<span class="string">"age的值为: "</span> + age);</div><div class="line">&#125;</div><div class="line"></div><div class="line">t(&#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;);  <span class="comment">//color的值为: red age的值为: 20</span></div><div class="line">t(&#123;<span class="attr">color</span>:<span class="string">"red"</span>&#125;);         <span class="comment">//color的值为: red age的值为: 99</span></div></pre></td></tr></table></figure><p><strong>剩余模式(…语法)</strong></p><p>解构特性支持剩余模式也就是<code>...语法</code>，这种模式能够帮助我们将剩余的数组元素或者是对象内容赋值给一个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/04-剩余模式.ts</span></div><div class="line"></div><div class="line"><span class="comment">//将数组中除了前两个之外的元素（剩余的元素）赋值给c</span></div><div class="line"><span class="keyword">let</span> [a,b, ...c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>];</div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(c); <span class="comment">// [3,4,8]</span></div><div class="line"></div><div class="line"><span class="comment">//剩余模式用于对象解构</span></div><div class="line"><span class="keyword">let</span> o = &#123;<span class="attr">testA</span>:<span class="string">"我是A"</span>,<span class="attr">testB</span>:<span class="string">"我是B"</span>,<span class="attr">testC</span>:<span class="string">"我是C"</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123; testA, ...passthrough &#125; = o;</div><div class="line"><span class="built_in">console</span>.log(testA);       <span class="comment">// 我是A</span></div><div class="line"><span class="built_in">console</span>.log(passthrough); <span class="comment">// &#123;testB:"我是B",testC:"我是C"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">//报错: A rest parameter or binding pattern may not have a trailing comma.</span></div><div class="line"><span class="comment">//let &#123; testB, ...Other,&#125; = o;  //错误的演示</span></div></pre></td></tr></table></figure></p><div class="tip"><strong>特别注意</strong>：剩余元素必须是数组的最后一个元素，如果剩余元素右侧有一个逗号，则会抛出SyntaxError错误。</div><p><strong>数组和对象的展开操作</strong></p><p>展开操作与解构操作刚好相反。<span style="color:red">展开操作它允许我们将数组展开为另一个数组，或将对象展开为另一个对象。</span></p><p>在操作数组的时候展开操作会对指定的数组执行浅拷贝，它们本身并不会因展开操作被修改。对象的展开操作和数组相比略显不同，虽然它和数组展开操作一样也是从左至右进行处理的，但因为其处理的结果仍然是对象，而对象中要求所有的key都具有唯一性，所以这也就意味着在<span style="color:#195">对象的展开操作可能存在属性覆盖的问题</span>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../04-解构和展开/06-数组和对象的展开操作.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] 数组的展开操作</span></div><div class="line"><span class="keyword">let</span> one:number[] = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line"><span class="keyword">let</span> two:number[] = [<span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">let</span> resultArrM = [<span class="number">0</span>, ...one, ...two, <span class="number">5</span>];</div><div class="line"><span class="built_in">console</span>.log(one);   <span class="comment">//[1,2]</span></div><div class="line"><span class="built_in">console</span>.log(two);   <span class="comment">//[3,4]</span></div><div class="line"><span class="built_in">console</span>.log(resultArrM);  <span class="comment">//[0,1,2,3,4,5]</span></div><div class="line"></div><div class="line"><span class="comment">//[002] 对象的展开操作</span></div><div class="line"><span class="keyword">let</span> defaultObj = &#123; <span class="attr">name</span>: <span class="string">"zhangsan"</span>, <span class="attr">age</span>: <span class="number">18</span>,<span class="attr">color</span>: <span class="string">"yellow"</span> &#125;;</div><div class="line"><span class="keyword">let</span> targetObj = &#123; ...defaultObj, <span class="attr">des</span>:<span class="string">"描述信息"</span>,<span class="attr">name</span>: <span class="string">"文顶顶"</span> &#125;;</div><div class="line"><span class="built_in">console</span>.log(defaultObj);  <span class="comment">//&#123; name: "zhangsan", age: 18,color: "yellow" &#125;;</span></div><div class="line"><span class="built_in">console</span>.log(targetObj);   <span class="comment">//&#123; name: "文顶顶", age: 18,color: "yellow",des:"描述信息"&#125;;</span></div></pre></td></tr></table></figure><blockquote><p><strong>注意</strong> 对象的展开操作存在限制情况</p><p>首先，它仅包含对象自身的可枚举属性（不包括原型成员）。<br>其次，TypeScript编译器不允许展开泛型函数上的类型参数。</p></blockquote><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>TypeScript语言中的函数在JavaScript函数基础上增加了参数类型声明、返回值类型指定、箭头函数等特征，这里简单介绍。</p><p><strong>指定参数和返回值类型</strong></p><p>同JavaScript一样，我们可以用函数声明的方式或函数表达式的方式来创建得到一个函数对象，<span style="color:#195">在定义（声明）函数的时候，我们可以选择性的给函数的参数加上类型，也可以指定函数返回值的类型</span>。如果指定了类型，那么TypeScript会进行类型检查。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../05-函数说明/01-函数简单说明.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] javaScript风格的函数（声明函数）</span></div><div class="line"><span class="comment">//下面的代码以“函数声明”的方式创建了add函数</span></div><div class="line"><span class="comment">//add函数拥有两个参数，形参a和形参b</span></div><div class="line"><span class="comment">//add函数的作用为对传入的两个参数进行+运算符计算，并返回结果</span></div><div class="line"><span class="comment">//如果设计的该函数只能接收number类型的两个参数，那么函数体中还应该对参数类型进行校验</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] TypeScript中的函数（声明函数）</span></div><div class="line"><span class="comment">//f1函数接收两个参数，并指定了参数的类型均为number</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a:number,b:number</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="keyword">let</span> result = f1(<span class="number">10</span>,<span class="number">20</span>);    <span class="comment">//返回结果为30</span></div><div class="line"></div><div class="line"><span class="comment">//报错：Argument of type '"字符串"' is not assignable to parameter of type 'number'.</span></div><div class="line"><span class="comment">//result = f1(10,"字符串");  错误的演示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[003] TypeScript中的函数（匿名函数|函数表达式）</span></div><div class="line"><span class="comment">//f2函数的指定了返回值类型为number</span></div><div class="line"><span class="keyword">let</span> f2 = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a:number,b:number</span>) : <span class="title">number</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f2(<span class="number">100</span>,<span class="number">200</span>);    <span class="comment">//300</span></div></pre></td></tr></table></figure><p><strong>箭头函数</strong></p><p>TypeScript遵循ES6的规范，提供了表示函数的另外一种方式即<code>箭头函数</code>。箭头函数最典型的特征是在创建函数的时候<code>在函数返回值类型的后面加上箭头(=&gt;)操作符</code>而并不使用function关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../05-函数说明/02-箭头函数.ts</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 这是TypeScript中典型的普通函数，下面提供等价的箭头函数代码</span></div><div class="line"><span class="comment">let add = function (a:number,b:number) : number&#123;</span></div><div class="line"><span class="comment">  return a + b;</span></div><div class="line"><span class="comment">&#125;</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> add = (a:number,<span class="attr">b</span>:number) :<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">10</span>,<span class="number">200</span>);  <span class="comment">//210</span></div></pre></td></tr></table></figure><p>接下来我们给出一个高阶函数的例子，所谓高阶函数指的是参数或返回值也是函数的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> sume = <span class="function">(<span class="params">a:number,b:number,callBack:(result:number</span>) =&gt;</span> <span class="keyword">void</span>) : <span class="function"><span class="params">void</span> =&gt;</span>&#123;</div><div class="line">  callBack(a +b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sume(<span class="number">10</span>,<span class="number">20</span>,(result:number) : <span class="function"><span class="params">void</span> =&gt;</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result)；</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//输出结果为：result = 30</span></div></pre></td></tr></table></figure><p>代码稍微有点复杂，简单来说，<span style="color:#195">我们声明了两个函数，其中一个是sume匿名函数，另外一个是调用sume时作为参数传递给sume的匿名函数，这两个函数均使用箭头函数表示法</span>。</p><p>作为参数传递给sume的匿名函数需要接受一个number类型的参数（形参为result），没有返回值。而sume这个函数需要接受三个参数，其中前两个参数是number类型的值（形参a和b）, 第三个参数为函数（形参为callBack）。</p><p>需要注意的是<code>(result:number) =&gt; void</code>为<strong>作为参数的匿名函数</strong>的类型。</p><p>通过下面的图示，可以加深大家对箭头函数的理解。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/typeScript_00.png?raw=true"><br>（函数声明图示）<br><img src="https://github.com/flowerField/Source/blob/master/Blog/typeScript_02.png?raw=true"><br>（函数调用图示）</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><strong>命名空间</strong>，在以前也称为内部模块。命名空间主要用来把一些存在内在联系的变量、类、接口以及对象等代码组织起来。使用命名空间来组织代码，可以让代码的整体结构更清晰，而且通过把某些相关联的代码包裹起来放在一个命名空间内，而不是暴露在全局命名空间中可以避免命名冲突。</p><p>在TypeScript中，可以通过namespace关键字来声明命名空间，其语法格式为<code>namespace 命名空间的名称{ //.......被包裹的代码块}</code>。命名空间中的代码无法被外界直接访问，如果外界需要访问可以通过<code>export</code>关键字来暴露接口。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a:string = <span class="string">"全局作用域中的变量"</span>;</div><div class="line"></div><div class="line">namespace WenDemo&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> a:string = <span class="string">"命名空间WenDemo中的变量a"</span>;</div><div class="line"></div><div class="line">  <span class="comment">//接口</span></div><div class="line">  interface PersonInterface &#123;</div><div class="line">      name: string;</div><div class="line">      getInfo();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//实现了PersonInterface接口的Person类</span></div><div class="line">  <span class="comment">//通过export关键字暴露接口</span></div><div class="line">  <span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">PersonInterface</span></span>&#123;</div><div class="line">    name:string;</div><div class="line">    <span class="keyword">constructor</span>(name:string)&#123;</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">      <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//let p = new Person("wendingding.com");</span></div><div class="line"></div><div class="line"><span class="comment">//如果把相关代码包裹到指定命名空间中，那么需要通过包裹的命名空间来访问暴露的接口</span></div><div class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> WenDemo.Person(<span class="string">"wendingding.com"</span>);</div><div class="line"><span class="built_in">console</span>.log(p);   <span class="comment">//&#123;name:"wendingding.com"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a);   <span class="comment">//全局作用域中的变量</span></div></pre></td></tr></table></figure><p> 把上面TypeScript代码编译为JavaScript的代码，我们可以发现<span style="color:red">命名空间实现的机制非常简单，只是使用了立即调用函数（闭包）包裹代码</span>而已，下面贴出JavaScript对应的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"全局作用域中的变量"</span>;</div><div class="line"><span class="keyword">var</span> WenDemo;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">WenDemo</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="string">"命名空间WenDemo中的变量a"</span>;</div><div class="line">    <span class="comment">//实现了PersonInterface接口的Person类</span></div><div class="line">    <span class="comment">//通过export关键字暴露接口</span></div><div class="line">    <span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line">        Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> Person;</div><div class="line">    &#125;());</div><div class="line">    WenDemo.Person = Person;</div><div class="line">&#125;)(WenDemo || (WenDemo = &#123;&#125;));</div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//let p = new Person("wendingding.com");</span></div><div class="line"><span class="comment">//如果把相关代码包裹到指定命名空间中，那么需要通过包裹的命名空间来访问暴露的接口</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> WenDemo.Person(<span class="string">"wendingding.com"</span>);</div><div class="line"><span class="built_in">console</span>.log(p); <span class="comment">//&#123;name:"wendingding.com"&#125;</span></div><div class="line"><span class="built_in">console</span>.log(a); <span class="comment">//全局作用域中的变量</span></div></pre></td></tr></table></figure></p><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文简单介绍TypeScript语言中的以下特性：&lt;br&gt;❏  解构赋值&lt;br&gt;❏  函数介绍&lt;br&gt;❏  命名空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解构-amp-展开&quot;&gt;&lt;a href=&quot;#解构-amp-展开&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [03]-TypeScript语言特性(二)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/20/TypeScript%E7%B3%BB%E5%88%97%20%5B03%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%BA%8C)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/20/TypeScript系列 [03]-typeScript语言特性(二)/</id>
    <published>2018-06-20T10:05:13.000Z</published>
    <updated>2018-06-20T10:07:58.902Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">TypeScript简单介绍</a>和<a href="http://wendingding.com/2018/06/19/TypeScript%E7%B3%BB%E5%88%97%20[02]-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%80" target="_blank" rel="external">TypeScript语言特性(一)</a>)这两篇文章中我们对TypeScript进行了简短的介绍并罗列了部分语言特性，这篇文章中我们将继续在语言特性方面展开探讨，主要介绍了TypeScript中流程控制结构、类以及接口等方面的内容，需要说明的是这篇文章中并不会就相关特性的细节深入展开，你能得到的将只有对它们进行的浅尝辄止介绍。</p></blockquote><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>我们知道世界上所有的程序都可以简单划分为<code>顺序、分支和循环</code>这三种结构，使用这三种基本结构组合能够表示所有复杂的结构。<strong>顺序结构</strong>就是按固定的顺序来执行特定的代码（通常是自上而下执行），<strong>分支结构</strong>根据条件判断结果来确定执行那条路径，而<strong>循环结构</strong>用于处理需要重复执行的任务，通常循环结构由<code>初始条件、循环检测条件、循环体以及退出机制</code>组成。TypeScript语言中的流程控制结构和JavaScript保持一致。</p><p><strong>循环结构</strong></p><p>TypeScript语言中的循环结构主要有：<strong><code>while循环</code></strong>、<strong><code>do..while循环</code></strong>、<strong><code>for..in循环</code></strong>以及常用的<strong><code>for循环</code></strong>，下面分别介绍并给出示例代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../02-流程控制结构/01-循环结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//[001] while循环结构</span></div><div class="line"><span class="comment">//说明：while语句用来在满足判断条件的情况下重复执行一段代码,代码在执行的时候会先检查判断条件是否满足，</span></div><div class="line"><span class="comment">//如果条件满足则执行循环体（更新条件变量）,否则就结束当前循环执行后面的代码，重复这个过程</span></div><div class="line"><span class="keyword">let</span> i:number = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span>)</div><div class="line">&#123;</div><div class="line">  i++;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[002] do..while循环结构</span></div><div class="line"><span class="comment">//说明：do...while循环结构能够保证循环体至少会被执行一次,当循环体执行完后，代码会检查判断条件是否满足,</span></div><div class="line"><span class="comment">//如果满足条件则继续执行循环体，否则就结束当前循环执行后面的代码，重复这个过程</span></div><div class="line"><span class="keyword">let</span> j:number = <span class="number">5</span>;</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">  j--;</div><div class="line">  <span class="built_in">console</span>.log(j);</div><div class="line">&#125;<span class="keyword">while</span>(j&gt;<span class="number">0</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[003] for循环</span></div><div class="line"><span class="comment">//说明:执行for循环的时候的执行顺序为</span></div><div class="line"><span class="comment">//(1) 执行初始化语句，初始化变量n</span></div><div class="line"><span class="comment">//(2) 检查是否满足循环条件</span></div><div class="line"><span class="comment">//    A: 如果满足循环条件，那么就执行循环体,并跳转到（3）</span></div><div class="line"><span class="comment">//    B: 如果不满足循环条件，那么就结束当前循环，继续执行后面的任务</span></div><div class="line"><span class="comment">//(3) 更新循环变量，这里为n++操作</span></div><div class="line"><span class="comment">//(4) 跳转到（2）</span></div><div class="line"></div><div class="line"><span class="comment">//关于break、continue和return</span></div><div class="line"><span class="comment">//在循环体中，如果遇到break和return则表示结束循环(循环本身以及循环内后面的代码不再执行)，执行循环后面的任务</span></div><div class="line"><span class="comment">//如果遇到continue则表示结束当前循环，继续执行后面的循环任务</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> n:number = <span class="number">0</span> ; n &lt; <span class="number">5</span>; n++)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(n === <span class="number">3</span>) <span class="keyword">continue</span>;</div><div class="line">    <span class="built_in">console</span>.log(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//[004] for..in循环</span></div><div class="line"><span class="comment">//说明:for..in循环主要用于遍历代码中的对象</span></div><div class="line"><span class="comment">//注意：不推荐使用for..in循环来遍历数组或伪数组对象，因为它会把原型成员迭代出来。</span></div><div class="line"><span class="keyword">let</span> obj:any = &#123;<span class="attr">name</span>:<span class="string">"zs"</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="string">"des"</span>:<span class="string">"描述信息"</span>&#125;;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"当前循环的key: "</span>+key+<span class="string">" value:"</span>+obj[key]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>分支结构</strong></p><p>TypeScript语言中的分钟结构主要有<code>if..else语句</code>和<code>switch语句</code>，同JavaScript语言保持一致。下面还是贴出简短的代码示例:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件目录 ../02-流程控制结构/02-分支结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//分支结构其实就是林中路在某个节点分叉为多条，而只能选择其中一条路继续走下去</span></div><div class="line"><span class="comment">//具体走哪条路就像是人生抉择，得出结选择论的部分被称为判断条件，是布尔类型的值（true/fasle）</span></div><div class="line"></div><div class="line"><span class="comment">//[01] if条件语句结构</span></div><div class="line"><span class="comment">//当条件满足的时候，执行&#123;&#125;中的代码，否则就忽略</span></div><div class="line"><span class="keyword">let</span> temp:boolean = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(temp)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为true"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">//.....</span></div><div class="line"></div><div class="line"><span class="comment">//[02] if...else语句结构</span></div><div class="line"><span class="comment">//给定两条路，只能也必须走某一条</span></div><div class="line"><span class="keyword">if</span>(temp)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为true"</span>)</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"temp的值为false"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[03] if...else if...语句结构</span></div><div class="line"><span class="comment">//给定多条路，根据条件进行选择其中的一条</span></div><div class="line"><span class="keyword">let</span> i:number = <span class="number">85</span>;</div><div class="line"><span class="keyword">if</span>(i &gt;= <span class="number">90</span>)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"优秀"</span>)</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">80</span>)&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"良好"</span>)</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= <span class="number">60</span>)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"及格"</span>)</div><div class="line">&#125;<span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"不及格"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出结果为:良好</span></div><div class="line"></div><div class="line"><span class="comment">//[04] switch结构</span></div><div class="line"><span class="comment">//switch语句接受一个表达式，会将表达式的值和case语句进行匹配，然后执行关联的语句块。</span></div><div class="line"><span class="comment">//为提高代码的可读性，避免魔法数字等出现，常结合枚举类型组织代码结构</span></div><div class="line">enum Animal&#123;</div><div class="line">  Dog,</div><div class="line">  Cat,</div><div class="line">  Pig</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> animalType:any = Animal.Dog;</div><div class="line"><span class="keyword">switch</span>(animalType)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">case</span> Animal.Dog:</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Dog: 汪汪汪!!!"</span>);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Animal.Cat:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Cat: 喵喵喵!!!"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">case</span> Animal.Pig:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Pig: 呵呵呵!!!"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  <span class="keyword">default</span>:</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"其他动物..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><p>我们知道JavaScript本身支持面向对象编程，但实现的方式和其它典型面向对象编程语言截然不同，JavaScript中没有Class的概念，其多态、继承等特性主要依靠函数和原型机制来实现，这种实现机制让很多java/C++型开发者困惑不已。</p><p><span style="color:#0b0">从ES6开始，JavaScript将支持基于类的面向对象实现。</span><span style="color:red"> 在TypeScript中，允许开发者现在就使用Class特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。<span></span></span></p><p>下面给出TypeScript中类的典型结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/01-Class的典型结构.ts</span></div><div class="line"></div><div class="line"><span class="comment">//类的定义</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  age:number;       <span class="comment">//age属性</span></div><div class="line">  name:string;      <span class="comment">//name属性</span></div><div class="line">  <span class="keyword">constructor</span>(name:string,age:number)&#123;    <span class="comment">//调用时内部自动执行该代码段</span></div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">  &#125;</div><div class="line">  getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding"</span>,<span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>上面的代码中，我们定义了一个名为Person的类，这个类拥有四个成员为：<code>name属性、 age属性、getInfo方法和constructor构造函数</code>。在Class的内部，我们可以通过 this来引用类中的成员。</p><p>当类被定义之后，我们可以使用 new来调用这个Class。 具体执行的时候，它会先调用Class中定义的构造函数执行初始化操作，并创建出一个当前类的实例对象返回。</p><p>下面贴出上面代码编译为JavaScript代码后的结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">    &#125;</div><div class="line">    Person.prototype.getInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding"</span>, <span class="number">18</span>);</div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>通过观察可以发现，<strong><code>类其本质上是依靠闭包函数和原型对象来实现的</code></strong>。</p><div class="tip"><strong>注意</strong>：当我们在TypeScript语言中定义类的时候，该类中所有的属性和方法默认都是公开的。对于Class的其它细节，这里我们不做展开。</div><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><p>TypeScript提供了接口机制。其实，TypeScript其核心原则之一就是<code>能够对值所具有的结构进行类型检查</code>,这种处理方式被称为“鸭式辨型法”。我们可以利用接口来为代码定义契约。</p><p>如果在设计某个函数的时候，我们希望该函数接受的参数对象（即函数的参数是一个对象）必须包含某个指定的属性，且类型固定。假设函数名为logNameAndOtherInfo，传递给该函数的对象参数必须要拥有name这个属性，且类型必须为string，我们可以尝试给出如下代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndOtherInfo</span>(<span class="params">obj:any</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name："</span>+obj.name);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Other：默认的其它信息，这里不做处理"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1:any = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">let</span> obj2:any = &#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line">logNameAndOtherInfo(obj1);  <span class="comment">//name：文顶顶 //Other：默认的其它信息，这里不做处理</span></div><div class="line">logNameAndOtherInfo(obj2);  <span class="comment">//undefined   //Other：默认的其它信息，这里不做处理</span></div></pre></td></tr></table></figure></p><p>观察上面的代码，我们会发现logNameAndOtherInfo函数无力在展示函数参数对象内部属性和类型方面有所作为。这种场景下，接口就可以派上用场。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/03-接口简单示例02.ts</span></div><div class="line"></div><div class="line">interface ObjWithNameValue &#123;</div><div class="line">  name: string;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logNameAndOtherInfo</span>(<span class="params">obj:ObjWithNameValue</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"name："</span> + obj.name);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Other：默认的其它信息，这里不做处理"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> obj1:any = &#123;<span class="attr">name</span>:<span class="number">234</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"><span class="keyword">let</span> obj2:any = &#123;<span class="attr">color</span>:<span class="string">"red"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line">logNameAndOtherInfo(obj1);  <span class="comment">//name：文顶顶 //Other：默认的其它信息，这里不做处理</span></div><div class="line">logNameAndOtherInfo(obj2);  <span class="comment">//undefined   //Other：默认的其它信息，这里不做处理</span></div></pre></td></tr></table></figure><p>除此之外，TypeScript中的接口与C#或Java里的基本作用一样，也能够用它来明确的强制一个类去符合某种契约。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../03-Class的使用/03-接口简单示例03.ts</span></div><div class="line"></div><div class="line">interface PersonInterface &#123;</div><div class="line">    name: string;</div><div class="line">    getInfo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//类的定义,需要遵循接口的约定</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">PersonInterface</span></span>&#123;</div><div class="line">  <span class="comment">//报错：Property 'name' in type 'Person' is not assignable to the same property in base type 'PersonInterface'.</span></div><div class="line">  <span class="comment">//name:number;      错误的演示（类型和接口不一致）</span></div><div class="line">  name:string;</div><div class="line">  <span class="keyword">constructor</span>(name:string)&#123;    <span class="comment">//调用时内部自动执行该代码段</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"执行内部的构造函数."</span>);</div><div class="line">  &#125;</div><div class="line">  getInfo()&#123;      <span class="comment">//getInfo方法</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new来构造Greeter类的实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"wendingding.com"</span>);</div></pre></td></tr></table></figure></p><p><strong>代码说明：</strong>在上面的代码中，我们定义了一个名为PersonInterface的接口，和一个实现了该接口的Person类，它能够确保实现了接口的类一定拥有指定的结构。</p><div class="tip"><code>注意</code>：类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型匹配即可。</div><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript系列 [02]-TypeScript语言特性(一)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/19/TypeScript%E7%B3%BB%E5%88%97%20%5B02%5D-typeScript%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7(%E4%B8%80)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/19/TypeScript系列 [02]-typeScript语言特性(一)/</id>
    <published>2018-06-19T10:05:13.000Z</published>
    <updated>2018-06-19T09:49:19.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">TypeScript简单介绍</a>这篇文章中对TypeScript进行了简短的介绍，这篇文章我们开始来探讨TypeScript的语言特性，主要介绍数据类型方面的内容。</p></blockquote><h3 id="var、let和const关键字"><a href="#var、let和const关键字" class="headerlink" title="var、let和const关键字"></a>var、let和const关键字</h3><p>在ES6前，JavaScript中只能通过var关键字来声明变量，且没有块级作用域。<br>在TypeScript中，我们声明变量的时候可以使用<code>var、let或者是const</code>关键字。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径  ../01-数据类型/00-声明变量的关键字</span></div><div class="line"></div><div class="line"><span class="comment">//[01] var 关键字声明变量</span></div><div class="line"><span class="built_in">console</span>.log(var_zero);      <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> var_zero:number = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(var_zero);      <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">//全局作用域</span></div><div class="line"><span class="keyword">var</span> var_one:string = <span class="string">'我是字符串_wendingding'</span>;</div><div class="line"> <span class="comment">//函数作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> var_two:string = <span class="string">'我是函数内的字符串'</span>;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"><span class="built_in">console</span>.log(var_one);         <span class="comment">//输出:我是字符串_wendingding</span></div><div class="line"></div><div class="line"><span class="comment">//报错： Cannot find name 'var_two'.</span></div><div class="line"><span class="comment">//console.log(var_two);    错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> var_i = <span class="number">0</span>; var_i &lt; <span class="number">3</span>; var_i++) &#123;</div><div class="line">    <span class="comment">//循环三次，输出的结果均为3</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(var_i); &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(var_i);   <span class="comment">//打印结果为：3</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****························****/</span></div><div class="line"><span class="comment">//[02] let关键字声明变量</span></div><div class="line"></div><div class="line"><span class="comment">//注意点：let关键字使用的时候必须先声明然后才能使用</span></div><div class="line"><span class="comment">//报错：Block-scoped variable 'let_zero' used before its declaration.</span></div><div class="line"><span class="comment">//console.log(let_zero);        //错误的演示</span></div><div class="line"><span class="comment">//let let_zero:number = 1;</span></div><div class="line"></div><div class="line"><span class="comment">//全局作用域</span></div><div class="line"><span class="keyword">let</span> let_one:string = <span class="string">"wendingding"</span>;</div><div class="line"></div><div class="line"><span class="comment">//函数作用域</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="keyword">var</span> let_two:string = <span class="string">'我是函数内的字符串'</span>;</div><div class="line">&#125;</div><div class="line">bar();</div><div class="line"><span class="built_in">console</span>.log(let_one);</div><div class="line"></div><div class="line"><span class="comment">//报错：Cannot find name 'let_two'.</span></div><div class="line"><span class="comment">//console.log(let_two); //错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> let_i = <span class="number">0</span>; let_i &lt; <span class="number">3</span>; let_i++) &#123;</div><div class="line">    <span class="comment">//循环3次，输出的结果为0，1，2</span></div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(let_i); &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//报错：Cannot find name 'let_i' 因为let_i的作用域为块级作用域</span></div><div class="line"><span class="comment">//console.log(let_i);   //错误的演示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/****························****/</span></div><div class="line"><span class="comment">//[03] const关键字声明变量</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> T1:number = <span class="number">12345</span>;</div><div class="line"><span class="keyword">const</span> T2:string = <span class="string">"建议那些不希望不修改的变量均使用const声明"</span>;</div><div class="line"></div><div class="line"><span class="comment">//报错  Cannot assign to 'T1' because it is a constant or a read-only property.</span></div><div class="line"><span class="comment">//T1 = 234;   错误的演示</span></div><div class="line"></div><div class="line"><span class="comment">//报错： 'const' declarations must be initialized.</span></div><div class="line"><span class="comment">//const T3:boolean; 错误的演示</span></div></pre></td></tr></table></figure></p><p>let关键字声明变量的主要特点有<code>块级作用域</code>、<code>变量先声明后使用</code>以及不能重复定义等。const关键字和let在声明变量的时候基本一致，只是const声明的变量被赋值后不能再改变（注意：对于const来说，只声明不赋值会报错），作用域同let。</p><p><strong>关于变量的作用域说明</strong></p><p><code>var声明的变量</code> 保存在最近的函数作用域中，如果不在任何函数中则在全局作用域中。<br><code>let和const声明的变量</code>保存在最近的比函数作用域小的块级作用域中，如果不在任何代码块中，则在全局作用域中。</p><h3 id="可选的静态类型声明"><a href="#可选的静态类型声明" class="headerlink" title="可选的静态类型声明"></a>可选的静态类型声明</h3><p>TypeScript通过向JavaScript增加<strong>可选的静态类型声明</strong>(<code>Optional static type notation</code>)来把JavaScript编程强类型的程序语言。可选的静态类型声明可以用来约束变量、函数等实体，这样编译器和开发工具就可以在开发过程中提供更好的正确性验证。另外，这种强类型的语言特性也能为代码提供更直观的表达，便于构建大型的程序架构。</p><p>需要注意的是，强类型的语言特性因为增加了类型检测机制所以需要额外的性能开销，但对于TypeScript来说，这些开销是在代码的编译过程中发生的，所以其实<strong>TypeScript并没有额外的运行时性能开销。</strong></p><p><span style="color:#195">TypeScript能够对变量进行类型推导，但是在有些特殊情况下还无法准确的自动侦测出某些对象和变量的类型。在这些情况下，TypeScript允许我们对变量的类型进行明确的声明。这种允许声明变量类型的特性就被称为<strong>可选的静态类型声明</strong>(<code>Optional static type notation</code>)。</span></p><p>选的静态类型的声明方式为<code>关键字 变量名:类型</code>，这种风格源于类型理论，而且更加强调类型的声明时可选的，如果类型声明没有提供，那么TypeScript会通过检查赋给当前变量的值的类型来推导出变量类型，这个过程被称为<strong><code>类型推导(Type inference)</code></strong>，当变量的类型无法被推测出来时（比如变量并没有被赋值），那么TypeScript会把该变量的类型设置为any，any类型可以表示任意的JavaScript值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01.可选的静态类型声明.ts</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> num0;                   <span class="comment">//未知的数据类型(any)</span></div><div class="line"><span class="keyword">let</span> num1 = <span class="number">0</span>;               <span class="comment">//number类型(类型推导)</span></div><div class="line"><span class="keyword">let</span> num2:number;            <span class="comment">//number类型(声明)</span></div><div class="line"><span class="keyword">let</span> num3:number = <span class="number">123</span>;      <span class="comment">//number类型(声明)</span></div><div class="line"><span class="keyword">let</span> num4:number = <span class="string">"string"</span>; <span class="comment">//报错:Type '"string"' is not assignable to type 'number'.</span></div></pre></td></tr></table></figure><p><strong>代码说明</strong>：上面代码中变量num2和num3通过类型声明的方式确定了它们是number类型的，num1因为没有提供类型声明，所以TypeScript尝试检测0的数据类型，然后推导出num1为number类型，num0因为既没有提供类型声明也没有任何赋值操作，所以TypeScript无法推导出其真实类型，因此设置其类型为any。</p><h3 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h3><p>JavaScript语言中数据类型可以分为<code>基本数据类型</code>（Primitive data types）和<code>对象类型</code>（Object types）两种。其中，基本数据类型包括：<code>布尔值、数值、字符串、null、undefined以及Symbol</code>，而对象类型主要有：<code>对象、数组、函数</code>等。</p><p>TypeScript中的数据类型和JavaScript稍有不同，下面主要介绍TypeScript中的基本数据类型，主要有<strong><span style="color:#195">布尔类型(boolean)、数值类型(number)、字符串类型(string)、数组类型(array)、void类型以及枚举类型</span></strong>。</p><p><strong>数值(number)</strong><br>数值类型等同于JavaScript中的number类型，在TypeScript中所有的数字都是浮点数，它们全部都是number类型的。</p><p><strong>字符串(string)</strong><br>连续的一个或多个字符，在代码中需要使用单引号或双引号包住，可以交叉。</p><p><strong>布尔类型(boolean)</strong><br>布尔类型有两个可选的值，true或false。</p><p><strong>数组类型(array)</strong><br>TypeScript中的数组类型和JavaScript不太一样。数组类型在声明的时候比较特殊，通常有两种声明方式：<code>关键字 数组名:类型[]</code>或者<code>关键字 数组名:Array&lt;类型&gt;</code>后一种格式被称为泛型，后面会专门介绍。</p><p><strong>枚举类型(enum)</strong><br>枚举类型和其他面向对象语言中保持一致。我们可以通过<code>enum 类型名{选项1，选项2，选项3,···}</code>的方式来定义，枚举类型中的成员默认从0开始依次递增。</p><p><strong>void类型</strong><br>void类型在所有类型都不存在的时候使用，是any类型的反面。</p><p><strong>any类型</strong><br>any类型可以表示任何类型，即能够表示任意的JavaScript数据。如果变量被声明为某个特定的基本类型，那么在赋值过程中改变其原本的类型是不被允许的，但如果该变量被声明为 any 类型，则允许接受任意类型的值。</p><p>any类型的值支持所有在JavaScript中对变量的操作，且在对any类型的值进行操作时仅仅进行最小静态检查，下面给出基本类型的代码示例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径 ../01-数据类型/02-基本数据类型.ts</span></div><div class="line"></div><div class="line"><span class="comment">//01 布尔类型的值</span></div><div class="line"><span class="comment">//类型关键字(boolean)</span></div><div class="line"><span class="comment">//说明 true或者false</span></div><div class="line"><span class="keyword">let</span> bool1:boolean = <span class="literal">true</span>;</div><div class="line"><span class="keyword">let</span> bool2:boolean = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">//02 字符串类型的值</span></div><div class="line"><span class="comment">//类型关键字(string)</span></div><div class="line"><span class="comment">//说明 用双引号或单引号括住一个或多个字符</span></div><div class="line"><span class="keyword">let</span> str1:string = <span class="string">"文顶顶"</span>;</div><div class="line"><span class="keyword">let</span> str2:string = <span class="string">'wen_dingd_ding'</span>;</div><div class="line"><span class="keyword">let</span> str3:string = <span class="string">"Hi '王二!' 你好，我是老实人。"</span></div><div class="line"></div><div class="line"><span class="comment">//03 数值类型</span></div><div class="line"><span class="comment">//类型关键字(number)</span></div><div class="line"><span class="comment">//说明 同JavaScript中的number类型</span></div><div class="line"><span class="keyword">let</span> num1:number = <span class="number">123</span>;</div><div class="line"><span class="keyword">let</span> num2:number = <span class="number">123.321</span>;</div><div class="line"></div><div class="line"><span class="comment">//04 数组类型</span></div><div class="line"><span class="comment">//类型关键字(array)</span></div><div class="line"><span class="comment">//数组类型声明方式(一) 关键字 数组名:类型[]</span></div><div class="line"><span class="keyword">let</span> arr1:number[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="comment">//let arr2:number[] = [1,3,5,'T',6];            //错误的演示，仅仅允许数字作为数组的元素</span></div><div class="line"><span class="comment">//let arr2:(string | number)[] = [1,3,5,'T',6]; //正确的处理方式</span></div><div class="line"></div><div class="line"><span class="comment">//数组类型声明方式(二) 关键字 数组名:array&lt;类型&gt;</span></div><div class="line"><span class="keyword">let</span> arr3:<span class="built_in">Array</span>&lt;number&gt; = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>];</div><div class="line"><span class="keyword">let</span> arr4:<span class="built_in">Array</span>&lt;any&gt; = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="string">"T"</span>,<span class="literal">false</span>];</div><div class="line"></div><div class="line"><span class="comment">//05 any类型的值</span></div><div class="line"><span class="keyword">let</span> any1 ;    <span class="comment">//声明变量的时候没有进行初始化操作，无法通过类型推导得出真实类型，通常总是设置为any类型</span></div><div class="line"><span class="keyword">let</span> any2:any = <span class="string">"我现在是字符串"</span>;   <span class="comment">//如果某个变量其类型可能会变化，建议使用any类型</span></div><div class="line">any2 = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="comment">//错误的演示</span></div><div class="line"><span class="comment">//报错：Type '123' is not assignable to type 'string'.</span></div><div class="line"><span class="keyword">let</span> test:string = <span class="string">"字符串类型的值"</span>;</div><div class="line"><span class="comment">//test = 123;     //把数值赋值给test变量</span></div><div class="line"></div><div class="line"><span class="comment">//06 枚举类型</span></div><div class="line">enum Color &#123;Red , Green , Yellow , Blue&#125;;</div><div class="line"><span class="keyword">let</span> a:Color = Color.Yellow;</div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">//打印的结果为2，每个选项从0开始依次递增</span></div><div class="line"></div><div class="line"><span class="comment">//void类型</span></div><div class="line"><span class="comment">//声明一个返回值为void类型（没有返回值）的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"这是一个没有返回值的函数，返回值的类型为void"</span>);</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"></div><div class="line"><span class="comment">//关于null和undefined</span></div><div class="line"><span class="keyword">let</span> test1:<span class="literal">null</span> = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> test2:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</div></pre></td></tr></table></figure><div class="tip">在JavaScript 语言中存在null和undefined这两种基本的数据类型，它们都只有一个值，分别为null和undefined。在JavaScript语言中，<code>null表示变量的值赋值为空（主动设置变量的值为null外，变量的值不可能自动为空），而undefined表示变量未定义</code>，如果声明了变量但是没有进行初始化赋值操作，那么其值为undefined。需要说明的是，null和undefined它们在TypeScript中作为类型来使用似乎毫无意义。</div><h3 id="联合类型和类型别名"><a href="#联合类型和类型别名" class="headerlink" title="联合类型和类型别名"></a>联合类型和类型别名</h3><p>联合类型用来声明那些可以存储多种类型值的变量。想象以下，如果您在设计变量的时候，希望该变量可以存储字符串类型或者数字类型的值，不能存储除此之外的其它类型数据，那么这个时候就可以使用联合类型来声明了。</p><p>联合类型声明变量的语法格式=&gt; <code>声明变量的关键字 变量名：（类型1 | 类型2）= 值</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件路径: ../01-数据类型/03-联合类型.ts</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> test0 :number = <span class="number">1</span>;</div><div class="line"><span class="comment">//报错：Type 'false' is not assignable to type 'number'.</span></div><div class="line"><span class="comment">//test0 = false;    //错误的演示</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> test1:(number | boolean) = <span class="number">123</span>;</div><div class="line">test1 = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(test1);</div><div class="line"></div><div class="line"><span class="keyword">let</span> test2:(number[] | string) = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">test2 = <span class="string">"我是字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(test2);</div></pre></td></tr></table></figure><p>TypeScript中允许我们使用type关键字来给类型设置别名。类型别名这种特性可以提高代码的可阅读性，缩短代码，但需要有节制的使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//文件目录：../01-数据类型/04-类型别名.ts</span></div><div class="line"></div><div class="line">type MyType = (string | boolean | number);</div><div class="line"><span class="keyword">let</span> value1:MyType = <span class="string">"我是字符串"</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line">value1 = <span class="number">123</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line">value1 = <span class="literal">true</span>;</div><div class="line"><span class="built_in">console</span>.log(value1);</div><div class="line"><span class="comment">//报错： Type 'number[]' is not assignable to type 'false'.</span></div><div class="line"><span class="comment">//value1 = [1,2,3];  错误的演示</span></div></pre></td></tr></table></figure></p><p>备注：该文章所有的示例代码均可以<a href="https://github.com/flowerField/TypeScript-Demo" target="_blank" rel="external">点击在Github托管仓库获取</a></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/06/12/TypeScript%E7%B3%BB%E5%88%97%20[01]-typeScript%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
      <category term="TypeScript系列" scheme="https://weibo.com/u/3800117445/tags/TypeScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[07] Yeoman-generator的创建</title>
    <link href="https://weibo.com/u/3800117445/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B07%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/"/>
    <id>https://weibo.com/u/3800117445/2018/06/14/前端工程化系列[07] Yeoman脚手架generator创建/</id>
    <published>2018-06-14T10:42:13.000Z</published>
    <updated>2018-06-15T04:03:30.179Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：在<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">Yeoman脚手架使用入门</a>和<a href="http://wendingding.com/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[06]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Yeoman脚手架核心机制</a>这两篇文章中已经对Yeoman脚手架工具的基本使用以及去核心运转机制进行了深入的介绍，这篇文章将以实例的方式来教会如何从零开始创建属于我们自己的generator。</div><p><a href="https://github.com/flowerField/generator-wendingding" target="_blank" rel="external">点击获取本文示例的generator</a></p><h3 id="generator创建准备"><a href="#generator创建准备" class="headerlink" title="generator创建准备"></a>generator创建准备</h3><p>这里我们一切从零开始，在创建自己的generator之前需要做一些准备工作，比如准备好yo命令行工具，比如对生成器生成的项目结构和目录文件有清晰的规划等。</p><p><strong>yo命令行工具</strong></p><p>在安装了NodeJS和npm的前提下，可以通过下面的命令来安装yo命令行工具，并检查安装是否成功。</p><p><code>$ npm install -g yo</code><br><code>$ yo --version</code></p><p><strong>generator-generator的安装</strong></p><p>创建generator可以完全从零开始，也可以使用Yeoman官方提供的generator引导，这里我们选择使用Yeoman官方推荐的方式来处理。<br><code>$ mkdir YeomanTest &amp;&amp; cd YeomanTest/</code> 创建新的目录并进入<br><code>$ npm install -g generator-generator</code> 安装Yeoman引导generator</p><p>列出具体的执行情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">wendingding$ mkdir YeomanTest</div><div class="line">wendingding$ <span class="built_in">cd</span> YeomanTest/</div><div class="line">wendingding$ <span class="built_in">pwd</span></div><div class="line">/Users/文顶顶/Desktop/Yeoman/YeomanTest</div><div class="line">wendingding$ npm install -g generator-generator + generator-generator@4.0.2</div><div class="line"></div><div class="line">updated 1 package <span class="keyword">in</span> 117.639s</div><div class="line"></div><div class="line">   ╭─────────────────────────────────────╮</div><div class="line">   │                                     │</div><div class="line">   │   Update available 5.5.1 → 6.1.0    │</div><div class="line">   │     Run npm i -g npm to update      │</div><div class="line">   │                                     │</div><div class="line">   ╰─────────────────────────────────────╯</div></pre></td></tr></table></figure></p><p>执行Yeoman官方的引导generator，并处理交互式配置部分，下面列出具体的执行情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">wendingding$ yo generator</div><div class="line">? Your generator name generator-wendingding</div><div class="line">Your generator must be inside a folder named generator-wendingding</div><div class="line">I<span class="string">'ll automatically create this folder.</span></div><div class="line"><span class="string">? Description 博客文章测试创建生成器</span></div><div class="line"><span class="string">? Project homepage url http://www.wendingding.com</span></div><div class="line"><span class="string">? Author'</span>s Name 文顶顶</div><div class="line">? Author<span class="string">'s Email 18681537032@163.com</span></div><div class="line"><span class="string">? Author'</span>s Homepage http://www.wendingding.com</div><div class="line">? Package keywords (comma to split) wendingding</div><div class="line">? Send coverage reports to coveralls Yes</div><div class="line">? GitHub username or organization flowerField</div><div class="line">? Which license <span class="keyword">do</span> you want to use? Apache 2.0</div><div class="line">   create package.json</div><div class="line">   create README.md</div><div class="line">   create .editorconfig</div><div class="line">   create .gitattributes</div><div class="line">   create .gitignore</div><div class="line">   create generators/app/index.js</div><div class="line">   create generators/app/templates/dummyfile.txt</div><div class="line">   create __tests__/app.js</div><div class="line">   create .travis.yml</div><div class="line">   create .eslintignore</div><div class="line">   create LICENSE</div><div class="line">I<span class="string">'m all done. Running npm install for you to install the required dependencies.</span></div><div class="line"><span class="string">If this fails, try running the command yourself.</span></div></pre></td></tr></table></figure><p>在执行generator-generator这个生成器的过程中，会询问项目名称、作者、使用协议、主页地址等等信息，依次选择填空即可。</p><div class="tip">注意：按照约定，Yeoman generator的名字必须以“generator-”的前缀开头，这是因为所有的generator其实都是全局安装的node模块，所以Yeoman其实是完全依靠文件系统来对这些生成器进行查找操作的。</div><p>当上面的命令执行完毕后，会发现在当前的路径下面生成了<code>generator-wendingding</code>目录，进入到<code>generator-wendingding</code>目录，使用tree命令查看当前目录结构，显示如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── LICENSE</div><div class="line">├── README.md</div><div class="line">├── __tests__</div><div class="line">├── generators</div><div class="line">├── app</div><div class="line">│    ├── index.js</div><div class="line">│    └── templates</div><div class="line">│        └── dummyfile.txt</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">└── package.json</div></pre></td></tr></table></figure></p><p>上面目录结构中虽然有很多文件，但我们<span style="color:red">真正需要关注的应该是generators路径下面的app/index.js文件以及templates目录，其中index文件对应是generators的组装指令部分，templates路径用于存放项目所有的模板文件。</span></p><h3 id="项目模板文件准备"><a href="#项目模板文件准备" class="headerlink" title="项目模板文件准备"></a>项目模板文件准备</h3><p>上面这些准备工作完成之后，接下来我们开始着手分析目标项目的文件结构，即我们使用自己创建的这个脚手架来搭建项目，其结构目录应该是怎样的？需要包含哪些文件等等。任何时候，明确知道你的目标，知道自己正在做什么至关重要。</p><p>下面试着给出目标项目的文件结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── build</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div></pre></td></tr></table></figure></p><p>我们可以看到该项目应该包含<code>bulid</code>、<code>src</code>以及<code>dist</code>三个目录，其中src目录中需要创建名为<code>css</code>、<code>js</code>、<code>libs</code>和<code>template</code>的文件夹，分别用来保存样式文件、脚本文件、依赖的框架以及模板文件等。</p><p>除了这些必要的文件外，假设目标项目需要使用bower来进行依赖管理，使用Grunt来进行自动化构建，所以自然还应该拥有Gruntfile.js、bower.json以及package.json文件。</p><p>假设目标项目中一定会使用到jQuery框架，可能会使用到bootstrap框架。</p><p>现在我们可以开始分析生成器中应该包含项目模板文件了，也就是在generators/templates路径中应该包含哪些文件。</p><p><strong>固定文件</strong></p><p><code>index.js</code>和 <code>style.css</code>创建空文件即可。<br><code>Gruntfile.js文件</code>因为内容固定不变，所以选择直接从旧项目中拷贝。<br><code>.jshintrc文件</code>用于js文件语法检查，内容也是固定不变的。<br><code>.bowerrc文件</code>用于重置Bower下载包的安装路径，内容为{“directory”: “src/libs/“}</p><p><strong>灵活文件</strong></p><p><code>package.json文件</code>中项目名称、作者以及开源协议等需要用户配置<br><code>bower.json文件</code>的项目名称、作者、开源协议以及依赖框架等需要用户配置</p><p><strong>可选文件</strong></p><p><code>bootstrap框架相关的部分</code>为可选文件，需要根据用户配置进行处理。</p><p><strong>依赖文件</strong></p><p><code>jQuery框架相关的部分</code>为依赖文件，在组装指令部分通过在代码中调用方法来下载和安装。</p><p>根据上面的分析，我们在generators/templates准备了多个模板文件，下面列出文件结构以及主要文件的具体内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">└── app</div><div class="line">    ├── index.js</div><div class="line">    └── templates</div><div class="line">        ├── Gruntfile.js</div><div class="line">        ├── bower.json</div><div class="line">        ├── css</div><div class="line">        │   └── style.css</div><div class="line">        ├── index.html</div><div class="line">        ├── js</div><div class="line">        │   └── index.js</div><div class="line">        └── package.json</div></pre></td></tr></table></figure></p><p>package.json文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"&lt;%= appName %&gt;"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"&lt;%= appAuthor %&gt;"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"&lt;%= appLicense %&gt;"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"grunt"</span>: <span class="string">"^1.0.2"</span>,</div><div class="line">    <span class="string">"grunt-contrib-concat"</span>: <span class="string">"^1.0.1"</span>,</div><div class="line">    <span class="string">"grunt-contrib-cssmin"</span>: <span class="string">"^2.2.1"</span>,</div><div class="line">    <span class="string">"grunt-contrib-jshint"</span>: <span class="string">"^1.1.0"</span>,</div><div class="line">    <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"^3.3.0"</span>,</div><div class="line">    <span class="string">"grunt-contrib-watch"</span>: <span class="string">"^1.0.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>bower.json文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"&lt;%= appName %&gt;"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">"\"测试使用\""</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">"js/index.js"</span>,</div><div class="line">  <span class="string">"authors"</span>: [</div><div class="line">    <span class="string">"&lt;%= appAuthor %&gt;"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"license"</span>: <span class="string">"&lt;%= appLicense %&gt;"</span>,</div><div class="line">  <span class="string">"keywords"</span>: [</div><div class="line">    <span class="string">"generator-wendingding"</span>,</div><div class="line">    <span class="string">"yeoman-generator"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"https://github.com/flowerField/generator-wen"</span>,</div><div class="line">  <span class="string">"ignore"</span>: [</div><div class="line">    <span class="string">"**/.*"</span>,</div><div class="line">    <span class="string">"node_modules"</span>,</div><div class="line">    <span class="string">"bower_components"</span>,</div><div class="line">    <span class="string">"test"</span>,</div><div class="line">    <span class="string">"tests"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"jquery"</span>: <span class="string">"^3.3.1"</span>&lt;% <span class="keyword">if</span>(isIncludeBootstrap) &#123; %&gt;,</div><div class="line">    <span class="string">"bootstrap"</span>: <span class="string">"^4.1.1"</span> &lt;% &#125; %&gt;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>index.html文件内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">appName</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>Gruntfile.js文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">// 项目配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//代码合并</span></div><div class="line">        concat:&#123;</div><div class="line">            options:&#123;</div><div class="line">                stripBanners:<span class="literal">true</span>,</div><div class="line">             banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt; 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">            &#125;,</div><div class="line">            target:&#123;</div><div class="line">                src:[<span class="string">"src/js/*.js"</span>],</div><div class="line">                dest:<span class="string">'build/js/index.js'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js代码压缩</span></div><div class="line">        uglify:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"build/js/index.js"</span>,</div><div class="line">                dest:<span class="string">"build/js/index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//css代码压缩</span></div><div class="line">        cssmin:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"src/css/style.css"</span>,</div><div class="line">                dest:<span class="string">"build/css/style.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js语法检查</span></div><div class="line">        jshint:&#123;</div><div class="line">            target:[<span class="string">'Gruntfile.js'</span>,<span class="string">"dist/js/index.js"</span>],</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//监听 自动构建</span></div><div class="line">        watch:&#123;</div><div class="line">            target:&#123;</div><div class="line">                files:[<span class="string">"src/js/*.js"</span>,<span class="string">"src/css/*.css"</span>],</div><div class="line">                <span class="comment">//只要指定路径的文件(js和css)发生了变化，就自动执行tasks中列出的任务</span></div><div class="line">                tasks:[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//通过命令行安装插件（省略...）</span></div><div class="line">    <span class="comment">//从node_modules路径加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-jshint"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-watch"</span>);</div><div class="line">    <span class="comment">//注册任务：在执行$ grunt命令的时候依次执行代码的合并|检查|压缩等任务并开启监听</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>,<span class="string">"watch"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><div class="tip">注意：上面部分文件中很多地方使用模板语法来传递参数，Yeoman所用的模板语言是EJS，具体用法请参考<a href="http://www.embeddedjs.com/" target="_blank" rel="external">EJS官网</a></div></p><h3 id="组装指令"><a href="#组装指令" class="headerlink" title="组装指令"></a>组装指令</h3><p>处理完上面这些工作之后，接下来就是最最核心的部分了，我们需要在<code>app/index.js文件</code>中编写组装指令，这部分代码控制着这个生成器应该怎么执行，包括交互式配置的具体内容、如何复制文件以及框架依赖和Node模块下载等内容。</p><p>下面列出该示例中的index.js文件内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">'yeoman-generator'</span>);</div><div class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</div><div class="line"><span class="keyword">const</span> yosay = <span class="built_in">require</span>(<span class="string">'yosay'</span>);</div><div class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</div><div class="line">  prompting() &#123;</div><div class="line">    <span class="keyword">this</span>.log(</div><div class="line">      <span class="comment">// yosay(`Welcome to the transcendent $&#123;chalk.red('generator-wen')&#125; generator!`)</span></div><div class="line">      yosay(<span class="string">`欢迎使用\n<span class="subst">$&#123;chalk.red(<span class="string">'generator-wen'</span>)&#125;</span> !\n Author：文顶顶`</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">const</span> prompts = [</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'input'</span>,</div><div class="line">        name    : <span class="string">'appName'</span>,</div><div class="line">        message : <span class="string">'请输入项目名称:'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="keyword">this</span>.appname        <span class="comment">//appname是内置对象，代表工程名，这里就是ys</span></div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">       type    : <span class="string">'input'</span>,</div><div class="line">       name    : <span class="string">'appAuthor'</span>,</div><div class="line">       message : <span class="string">'请输入作者姓名:'</span>,</div><div class="line">       <span class="keyword">default</span> : <span class="string">'文顶顶'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'list'</span>,</div><div class="line">        name: <span class="string">'appLicense'</span>,</div><div class="line">        message: <span class="string">'请选择使用的license:'</span>,</div><div class="line">        choices: [<span class="string">'MIT'</span>, <span class="string">'ISC'</span>, <span class="string">'Apache-2.0'</span>, <span class="string">'AGPL-3.0'</span>]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'confirm'</span>,</div><div class="line">        name    : <span class="string">'isIncludeBootstrap'</span>,</div><div class="line">        message : <span class="string">'是否需要使用bootStrap框架？'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="literal">false</span></div><div class="line">     &#125;,</div><div class="line"></div><div class="line">    ];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></div><div class="line">      <span class="keyword">this</span>.props = props;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  writing() &#123;</div><div class="line">    mkdirp(<span class="string">"build"</span>);</div><div class="line">    mkdirp(<span class="string">"dist"</span>);</div><div class="line">    mkdirp(<span class="string">"src/template"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'index.html'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/index.html'</span>),</div><div class="line">      &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName&#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'css/style.css'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/css/style.css'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'js/index.js'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/js/index.js'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'.bowerrc'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'.bowerrc'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'Gruntfile.js'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'Gruntfile.js'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'.jshintrc'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'.jshintrc'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'package.json'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'package.json'</span>),</div><div class="line">       &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName,<span class="attr">appAuthor</span>:<span class="keyword">this</span>.props.appAuthor,<span class="attr">appLicense</span>:<span class="keyword">this</span>.props.appLicense&#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'bower.json'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'bower.json'</span>),</div><div class="line">       &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName,<span class="attr">appAuthor</span>:<span class="keyword">this</span>.props.appAuthor,<span class="attr">appLicense</span>:<span class="keyword">this</span>.props.appLicense,<span class="attr">isIncludeBootstrap</span>:<span class="keyword">this</span>.props.isIncludeBootstrap&#125;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  install() &#123;</div><div class="line">    <span class="comment">//this.installDependencies();</span></div><div class="line">    <span class="keyword">this</span>.bowerInstall();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码大概由三部分组成，<span style="color:red">第一部分为prompting函数用来处理安装提示，第二部分为writing函数用来设置模板文件的复制操作，第三部分为install函数用来处理框架依赖和node包的安装。</span></p><h3 id="generator的发布和测试"><a href="#generator的发布和测试" class="headerlink" title="generator的发布和测试"></a>generator的发布和测试</h3><p>项目模板文件和组装指令都准备好了后，我们就可以发布自己的generator了，可以先通过<code>$ npm link</code>命令以软连接的方式生成一个全局的npm包，测试使用。<br>具体的执行细节如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wendingding:generator-wendingding wendingding$ npm link</div><div class="line">up to date <span class="keyword">in</span> 3.897s</div><div class="line">/usr/<span class="built_in">local</span>/lib/node_modules/generator-wendingding -&gt; /Users/文顶顶/Desktop/Yeoman/YeomanTest/generator-wendingding</div><div class="line">wendingding:generator-wendingding wendingding$</div></pre></td></tr></table></figure></p><p><strong>测试·使用自己创建的generator来生成初始化项目</strong></p><p>随便找个目录新建文件夹，使用<code>$ yo wendingding</code>命令即可完成项目的初始化工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">wendingding:YeomanTest wendingding$ mkdir Demo</div><div class="line">wendingding:YeomanTest wendingding$ <span class="built_in">cd</span> Demo/</div><div class="line">wendingding:Demo wendingding$ yo wendingding</div><div class="line"></div><div class="line">     _-----_     ╭──────────────────────────╮</div><div class="line">    |       |    │         欢迎使用           │</div><div class="line">    |--(o)--|    │      generator-wen !      │</div><div class="line">   `---------´   │      Author：文顶顶        │</div><div class="line">    ( _´U`_ )    ╰──────────────────────────╯</div><div class="line">    /___A___\   /</div><div class="line">     |  ~  |     </div><div class="line">   __<span class="string">'.___.'</span>__   </div><div class="line"> ´   `  |° ´ Y `</div><div class="line"></div><div class="line">? 请输入项目名称: Demo</div><div class="line">? 请输入作者姓名: 文顶顶</div><div class="line">? 请选择使用的license: Apache-2.0</div><div class="line">? 是否需要使用bootStrap框架？ Yes</div><div class="line">   create bower.json</div><div class="line">   create package.json</div><div class="line">   create src/index.html</div><div class="line">   create src/css/style.css</div><div class="line">   create src/js/index.js</div><div class="line">   create .bowerrc</div><div class="line">   create Gruntfile.js</div><div class="line">   create .jshintrc</div><div class="line">bower invalid-meta  <span class="keyword">for</span>:/Users/文顶顶/Desktop/Yeoman/YeomanTest/Demo/bower.json</div><div class="line">bower invalid-meta  The <span class="string">"name"</span> is recommended to be lowercase, can contain digits, dots, dashes</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git<span class="comment">#3.3.1</span></div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git<span class="comment">#^3.3.1</span></div><div class="line">bower cached        https://github.com/twbs/bootstrap.git<span class="comment">#4.1.1</span></div><div class="line">bower validate      4.1.1 against https://github.com/twbs/bootstrap.git<span class="comment">#^4.1.1</span></div><div class="line">bower install       jquery<span class="comment">#3.3.1</span></div><div class="line">bower install       bootstrap<span class="comment">#4.1.1</span></div><div class="line"></div><div class="line">jquery<span class="comment">#3.3.1 src/libs/jquery</span></div><div class="line"></div><div class="line">bootstrap<span class="comment">#4.1.1 src/libs/bootstrap</span></div><div class="line">wendingding:Demo wendingding$ tree -L 3</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── build</div><div class="line">├── dist</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   ├── bootstrap</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div><div class="line"></div><div class="line">9 directories, 6 files</div></pre></td></tr></table></figure><p>如果需要把这个生成器发布到社区，可以参考官网的说明。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：在&lt;a href=&quot;http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[06] Yeoman脚手架核心机制</title>
    <link href="https://weibo.com/u/3800117445/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B06%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/06/14/前端工程化系列[06] Yeoman脚手架工具核心机制/</id>
    <published>2018-06-14T04:42:13.000Z</published>
    <updated>2018-06-14T13:03:34.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman02.png?raw=true"></p><div class="tip">在<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">前端工程化系列[05] Yeoman脚手架使用入门</a>这边文章中，对Yeoman的使用做了简单的入门介绍，这篇文章我们将接着探讨Yeoman这个脚手架工具内部的核心机制，主要包括以下内容</div><blockquote><p>❏  Yeoman脚手架工具的价值讨论<br>❏  generator[<code>生成器</code>]的内部结构<br>❏  generator[<code>生成器</code>]的项目模板<br>❏  Yeoman脚手架工具的核心运转机制<br>❏  Yeoman 的主要组装流程</p></blockquote><h3 id="Yeoman这样的脚手架工具解决了什么问题？"><a href="#Yeoman这样的脚手架工具解决了什么问题？" class="headerlink" title="Yeoman这样的脚手架工具解决了什么问题？"></a>Yeoman这样的脚手架工具解决了什么问题？</h3><p>所有新事物都不是凭空产生的，它们的出现总有某些内在的驱动力。一项新技术，一个新工具的出现更是如此。不知道从什么时候开始起，我接触新事物新技术以及某些工具的时候，总愿意多花点时间想一想它出现的原因是什么？因为时间、精力等等这些东西都很宝贵，IT从业人员对这些资源尤其敏感，所以新技术或者新工具的出现我认为有几种情况：</p><ul><li>已有的技术或工具存在缺陷，作者们靠自己的才学推出<strong><code>更完美的替代方案</code></strong></li><li>已有的技术或工具无法解决既定的需求，作者们探索出<strong><code>解决问题的技术方案</code></strong></li><li>纯粹闲的蛋疼（这种情况一般比较少见）</li></ul><p>现在，我们来研究下Yeoman的价值，或者说<span style="color:#195">Yeoman出现的意义是什么？Yeoman的出现解决了什么样的问题？</span></p><p>我们假设有这样的开发场景：公司的开发团队，基于某些特定的技术栈已经完成了项目A的开发和上线等工作，项目A的基本情况如下</p><blockquote><p>技术栈：JavaScript + HTML + CSS + Bootstrap + jQuery<br>工作流：npm（包管理工具） + bower（下载器） +  grunt<br>版本管理工具：Git</p></blockquote><p>项目整体目录结构（简化后）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── bower.json</div><div class="line">├── node_modules</div><div class="line">│   ├── abbrev</div><div class="line">···</div><div class="line">│   └── xtend</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">├── build</div><div class="line">│   ├── css</div><div class="line">│   │   └── style.min.css</div><div class="line">│   └── js</div><div class="line">│       ├── index.js</div><div class="line">│       └── index.min.js</div><div class="line">├── dist</div><div class="line">└── src</div><div class="line">    ├── css</div><div class="line">    │   └── style.css</div><div class="line">    ├── index.html</div><div class="line">    ├── js</div><div class="line">    │   └── index.js</div><div class="line">    ├── libs</div><div class="line">    │   ├── bootstrap</div><div class="line">    │   └── jquery</div><div class="line">    └── template</div></pre></td></tr></table></figure></p><div class="tip">说明：上面的目录中src为代码的工作目录，bulid为构建后目录，dist为发布目录。</div><p>因为项目A已经上线发布，现在公司要求着手开展新的项目B，经过需求评审和技术选型后，新项目B采用的工作流和项目A保持一致，技术栈在原有的基础上尝试使用TypeScript来处理脚本部分引入Vue框架，其它部分保持不变。我们发现项目A和项目B它们的结构基本上是一致的（比如项目的目录就够，都需要拥有Gruntfile.js和package.json等文件），但是有些部分又不太一样，比如package.json文件中的项目名称、开发依赖等。</p><p>这个时候，我们在对项目B进行初始化的方式可以尝试以下操作方式：</p><ul><li><span style="color:red">方案①</span> <strong>从0开始创建目录结构，集成工作流配置开发环境</strong></li><li><span style="color:red">方案②</span> <strong>从项目A中拷贝目录结构和固定文件，对于不同的部分一个个修改</strong></li></ul><p>如果我们采用方案① 你会发现这个过程你在初始化项目A的时候就已经做过了，是重复性的工作，毫无技术含量但是又费时费力。<br>如果我们采用方案② 你会发现要修改的文件有些多，每个文件要改的字段也比较多，而且容易遗漏总是调不通会出现各种问题，心烦意乱。</p><p>如果你会使用Yeoman脚手架工具的话，那么对于上面的开发场景你就会多一个方案③，在使用方案③来初始化项目B的时候，你只需要动动手指在终端中输入<code>$ yo 生成器名称</code>再使用交互方式简单配置某些特定值，初始化的工作就完成了。这就是Yeoman的价值所在，初始化项目的时候你不必再把自己沉入到琐碎重复无技术成长的费力工作中，也不必总是像个机器人般进入到拷贝-粘贴-修改这样无止境的循环中。<span style="color:#0b0">脚手架工具是那么的简单直接和高效，你甚至可以省出点加班的时间来看世界杯了 : ) </span></p><p>我知道有一些杠精要出来喷了。<code>“解决这种初始化问题不用搞的这么复杂，我完全可以把项目结构和固定不变的部分抽取出来托管到gitHub仓库，要初始化项目的时候 $ git clone一下不就好了吗？”</code></p><p>说的很有道理，但是clone下来的仓库虽然结构和必要文件已经准备好了，但很多文件是不是还得修改？那你会顶回来<code>“难道使用Yeoman初始化就不需要修改了吗？”</code>当然也要修改，不过就算是修改那改起来也很有趣味还So快！<div class="tip">Yeoman使用交互式的方式来对项目文件中需要灵活处理的部分进行配置，这部分内容我们称为组装指令，具体再文章的后面会进行讲解。</div>另外，如果新项目的整体结构以及技术选型和已有的项目很不一样，那你抽取后交由git管理的仓库就没用了，因为八字不合啊。使用Yeoman就没用这样的顾虑，在<a href="http://yeoman.io/generators/" target="_blank" rel="external">Yeoman-generator列表</a>有好几千现成的generator供你选择，总有一款适合你！！！</p><p> 我要求太太…太高，实在谁也看不上？没关系，generator这家伙还可以私人订制，你完全可以根据自己的需求来定制需要的generator，你一高兴甚至还能把它发布到社区造福全人类。</p><h3 id="Yeoman-generator的内部结构"><a href="#Yeoman-generator的内部结构" class="headerlink" title="Yeoman-generator的内部结构"></a>Yeoman-generator的内部结构</h3><p>搞清楚 generator的价值所在和应用场景之后，我们就可以开始谈论generator相关的话题了，前面介绍过Yeoman脚手架工具的作用是帮助我们依据特定的技术栈需求来初始化项目，在安装了yo工具之后，只需要在终端中使用类似<code>$ yo generator--xx</code>的命令先安装对应的generator然后再<code>$ yo xx</code>搭建即可。至于如何找到匹配当前技术选型的generator，可以去官网的generator列表搜索，这些生成器中有很大一部分来自于对应框架的作者或者Yeoman官方团队，质量有保证且更新很及时。当然，我们也可以创建自己的generator并发布。关于如何创建自己的generator，我们放到另一篇文章<a href="http://wendingding.com/2018/06/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[07]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6generator%E5%88%9B%E5%BB%BA/" target="_blank" rel="external">Yeoman脚手架生成器创建</a>来解决。</p><p>简单说Yeoman做的工作其实就是根据当前的生成器（generator）来复制固定的项目模板文件到新项目中，而新项目中的某些文件需要配置，这部分工作由安装时候的交互式指令来完成（相当于传递参数给模板文件）。</p><div class="tip">需要注意的是，Yeoman的设计仅仅只提供了一小部分核心的API，而真正繁重的初始化工作是交给每个具体的generator来完成的。</div><p>generator主要由<strong><code>组装指令</code></strong>和<strong><code>项目模板</code></strong>两部分组成。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman03.png?raw=true" width="600px"></p><p><strong>组装指令</strong></p><p>Yeoman generator中的generators/app/index.js文件是整个生成器的核心部分，该文件用于告知Yeoman该如何来组织并搭建项目，我们可以在该文件中设置初始化项目时必要的安装提示和选项来让用户选择，以及每个文件应该如何复制和修改，是否需要加载依赖和Node包等内容。</p><p><strong>项目模板</strong></p><p>项目模板包括初始化项目需要的所有必须文件。这些文件又可以简单的划分为<strong><code>固定文件</code></strong>、<strong><code>灵活文件</code></strong>、<strong><code>可选文件</code></strong>和<strong><code>依赖文件</code></strong>。所谓<code>固定文件</code>就是在每个初始项目中都一模一样的文件，譬如index.js、style.css等文件，在具体处理的时候这些文件只需要简单复制即可。<code>灵活文件</code>指的是那些需要根据用户选择来做简单修改然后才能复制的文件，譬如index.html文件（title等信息需根据用户输入来指定）。对于<code>可选文件</code>来说，它们并不是必须的，譬如某些基础框架有的项目中需要，有的项目中也许并不需要，这部分文件的处理方式需要<strong>交给用户来决定</strong>。</p><h3 id="项目模板文件的类别"><a href="#项目模板文件的类别" class="headerlink" title="项目模板文件的类别"></a>项目模板文件的类别</h3><p>前面已经介绍过了Yeoman生成器的组成部分主要是组装指令和项目模板。对于整个Yeman脚手架工具来说，项目模板这部分就相当于是搭建脚手架需要用到的原材料，而组装指令用来决定和控制所有的具体行动是什么。</p><p>现在我们开始深入的来讨论项目模板这部分内容，需要先明白的是<code>“能够满足所有需求的万能的项目模板是不存在的”</code>。因为这世界上每个项目组，每个产品甚至每个人的需求(要求)都各有不同。所以，在实践中你必须要对当前项目的需求和采用的技术栈有深入的理解，这样你才能知道目标项目的目录结构会是什么样的? 哪些文件是必不可少的。</p><p>如果你的项目和采用的技术栈比较大众化，那么搜索一个合适的generator基本就能满足需求，拿来主义即可。如果你的项目不管结构还是所采用的技术看上去都那么的非凡和特别，那么就多花一点点时间创建个自己的generator吧，如果你需要处理多个这样的项目，那就更应该了。在创建或者理解generator的时候，我们可以根据前面对项目模板文件的划分情况来区别对待不同的文件。</p><p><strong>固定文件</strong></p><p><span style="color:#195">固定文件是在每个项目中初始内容都一样的必要文件。</span></p><p>比如我们可能总是会把代码的结构划分为<code>src</code>、<code>build</code>和<code>dist</code>三个目录，在src目录下面拥有js、css和lib文件目录，index.js和style.css等文件。这些文件都是必要的，刚开始的时候可能是空的或者只有几行简单的代码。这些文件的特点是，在使用组装指令操作(通常是复制-移动)这些文件的时候，不需要对它们进行任何的修改。</p><p><strong>灵活文件</strong></p><p><span style="color:#195">灵活文件和固定文件差不多，也是初始化项目所必须的，但不同的项目中这些文件的内容也会稍有不同</span>，这些不同之处可能很细微(比如仅仅是名字、协议这些)，也可能差异巨大。比如，我们常用的构建工作流中的<code>bower.json</code>和<code>package.json</code>文件，它们是必不可少的，但是它们都需要当前项目的项目名称和协议等信息才能正常工作。像这样的灵活文件还有index.html，在这个文件中的title标签中应该使用当前项目的名称。</p><p>灵活文件中的部分内容需要在安装该生成器的时候，由用户交互式配置输入的信息来进行设定。</p><p><strong>可选文件</strong></p><p><span style="color:#195">可选文件并不是搭建初始化项目时所必须的文件，如果没有那么没关系，如果有那似乎更好。</span>这些一般在用户交互式配置的时候，以是否题的方式交由用户决定，譬如是否使用less 是否安装Bootstrap等。</p><p><strong>依赖文件</strong></p><p><span style="color:#195">依赖文件指的是某些常用的框架、插件或者是Node模块</span>，这些文件并不需要你在项目模板文件中提供，然后通过组装指令去一个个复制。因为基本上成熟的项目中都会使用既定的工作流(主要包括依赖和包的下载、项目的自动化构建等)，所以我们完全只需要在<code>package.json</code>或者<code>bower.json</code>等文件中设置好依赖即可，然后在组装指令的相关代码中通过<code>this.installDependencies（）</code>类似的代码来调用npm或者是bower执行install命令即可。</p><h3 id="Yeoman脚手架运转的核心机制"><a href="#Yeoman脚手架运转的核心机制" class="headerlink" title="Yeoman脚手架运转的核心机制"></a>Yeoman脚手架运转的核心机制</h3><p>当您为项目准备好(搜索或自己创建)合适的generator之后，就可以用它们来搭建项目了。generator的执行需要在终端中使用yo命令来操作。yo是Yeoman的核心命令，主要用来连接生成器和项目结构。<span style="color:#f25">我们可以把yo命令理解为generator的执行器，它知道怎么找到对应的generator，也知道该如何执行它们。</span></p><div class="tip">注意：yo基于NodeJS且需要在任何文件目录中使用，所以在安装yo命令的时候应该使用-g来进行全局安装。安装过程请参考：<a href="http://wendingding.com/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[05]%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" target="_blank" rel="external">Yeoman脚手架使用入门</a>。</div><p>在使用yo命令行工具和生成器来初始化项目之前，需要先把指定的生成器(generator)下载安装到本地（如果是自己创建的生成器，那么可以通过<code>$ npm link</code>命令以软连接的方式生成一个全局的npm包，我的是mac OSX系统，生成的npm包会保存在/usr/local/lib/node_modules/路径，如果使用的是别人发布的generator，那么请使用<code>$ npm install -g generator-xxx</code>的方式来安装）。</p><p>这里需要注意的是<code>yo命令行工具主要负责前期工作，在使用的时候它主要检查当前安装的generator有哪些，指定的generator是否能够正常工作，如果能，那么它就会调用generator的组装指令，把剩下部分的工作交接给generator来完成。generator接管项目的组装流程之后，会按app/index.js中的要求来处理文件的复制等工作</code>。</p><p>下面给出脚手架工具初始化项目时的核心流程。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman04.png?raw=true"></p><p>这里对yo的主要命令进行简单说明</p><p><code>$ yo</code> 执行该命令的时候，yo会搜索并列出所有本地可用的生成器<br><code>$ yo 生成器名称</code> 比如对于<code>generator-typescript</code>生成器，那么执行的命令就是<code>$ yo typescript</code>。该命令会先检查<code>enerator-typescript</code>生成器是否可用。如果可用，那么就接着以 ①交互式配置 ② 写入文件 ③ 下载安装依赖的顺序来执行组装指令。</p><h3 id="Yeoman的主要组装流程"><a href="#Yeoman的主要组装流程" class="headerlink" title="Yeoman的主要组装流程"></a>Yeoman的主要组装流程</h3><p>组装指令是用来让Yeoman创建项目所需文件的一系列具体的命令(代码)。典型的组装流程分为三个步骤：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman05.png?raw=true"></p><blockquote><p><strong>① 交互式配置</strong>。这个步骤通过向用户提问或直接输入配置信息来完成模板传参。<br><strong>② 写入文件</strong>。把项目模板中的指定文件复制到新项目的指定目录中。<br><strong>③ 安装依赖</strong>。下载并安装所有保存在bower.json和package.json文件中的依赖和Node模块。</p></blockquote><p><strong>① 交互式配置</strong></p><p>Yeoman在执行生成器的时候，首先会执行安装提示以交互式的方式来询问用户，目的是为了获取生成器所需要的一些参数，比如项目的名称、作者、使用的开原协议以及是否安装和使用某些组件等。</p><p>这部分功能，需要使用到inquirer包，这个包的作用是生成选项来让用户选择。下面给出代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">prompting() &#123;</div><div class="line"><span class="keyword">const</span> prompts = [</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'input'</span>,</div><div class="line">        name    : <span class="string">'appName'</span>,</div><div class="line">        message : <span class="string">'请输入项目名称:'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="keyword">this</span>.appname        <span class="comment">//appname是内置对象，代表工程名，这里就是ys</span></div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">       type    : <span class="string">'input'</span>,</div><div class="line">       name    : <span class="string">'appAuthor'</span>,</div><div class="line">       message : <span class="string">'请输入作者姓名:'</span>,</div><div class="line">       <span class="keyword">default</span> : <span class="string">'文顶顶'</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        type: <span class="string">'list'</span>,</div><div class="line">        name: <span class="string">'appLicense'</span>,</div><div class="line">        message: <span class="string">'请选择使用的license:'</span>,</div><div class="line">        choices: [<span class="string">'MIT'</span>, <span class="string">'ISC'</span>, <span class="string">'Apache-2.0'</span>, <span class="string">'AGPL-3.0'</span>]</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        type    : <span class="string">'confirm'</span>,</div><div class="line">        name    : <span class="string">'isIncludeBootstrap'</span>,</div><div class="line">        message : <span class="string">'是否需要使用bootStrap框架？'</span>,</div><div class="line">        <span class="keyword">default</span> : <span class="literal">false</span></div><div class="line">     &#125;,</div><div class="line"></div><div class="line">    ];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">      <span class="comment">// To access props later use this.props.someAnswer;</span></div><div class="line">      <span class="keyword">this</span>.props = props;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p><p>我们可以看到在代码中，这些交互式配置都由prompts来进行维护，prompts是一个对象数组，数组中的每个元素对象就代表着一个具体的安装提示，在使用yo命令运行该生成器的时候，它的执行情况如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">     _-----_     ╭──────────────────────────╮</div><div class="line">    |       |    │         欢迎使用            │</div><div class="line">    |--(o)--|    │      generator-wen!        │</div><div class="line">   `---------´   │      Author：文顶顶         │</div><div class="line">    ( _´U`_ )    ╰──────────────────────────╯</div><div class="line">    /___A___\   /</div><div class="line">     |  ~  |     </div><div class="line">   __'.___.'__   </div><div class="line"> ´   `  |° ´ Y `</div><div class="line"></div><div class="line">? 请输入项目名称: wendingdingTest</div><div class="line">? 请输入作者姓名: 文顶顶</div><div class="line">? 请选择使用的license: Apache-2.0</div><div class="line">? 是否需要使用bootStrap框架？ (y/N) yes</div></pre></td></tr></table></figure></p><p>prompts中的每个对象元素就代表着一个安装提示，上面代码一共提供了四个安装提示。每个对象中的type属性用于表明交互的类型，其中输入项目名称和作者姓名是<code>input型的</code>,表示接收用户的输入，相当于填空题。选择使用的license是<code>list</code>型的，它提供了多个选项供用户选择，您可以认为这种类型是单选题。是否需要使用bootStrap框架是<code>confirm</code>型的，默认为false，如果需要安装那么需要输入YES，这相当于是非题。</p><div class="tip">交互式配置这部分可以根据项目的实际情况来设置prompts中的对象元素，除上面介绍的这些类型外，您还可以通过查看<a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="external">inquirer.js的文档</a>来获取更多内容。</div><p>交互式配置过程中用户做出的所有选择和输入都会被保存到this.props对象中，可以通过访问this.props.isIncludeBootstrap属性来确定是否需要安装Bootstrap。</p><p><code>message属性</code>保存是每一条安装提示的提示信息。<br><code>name属性</code>是最重要的属性之一，它作为key用来访问用户的选择结果。<br><code>default属性</code>保存的是默认值，即当用户跳过当前安装提示的时候，name对应的value值将使用default中保存的默认值来设置。</p><p><strong>② 写入文件</strong></p><p>写入文件这个过程会把项目模板复制到指定的目录中，如果是固定文件那么就直接拷贝，如果是灵活文件那么还需要把某些参数传递给指定的模板文件。这个过程在代码中由writing() 函数体现，另外系统还提供了两个函数（<code>fs.copyTpl和fs.copy</code>）用来执行具体的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">writing() &#123;</div><div class="line">    mkdirp(<span class="string">"build"</span>);          <span class="comment">//创建build文件目录</span></div><div class="line">    mkdirp(<span class="string">"dist"</span>);           <span class="comment">//创建dist文件目录</span></div><div class="line">    mkdirp(<span class="string">"src/template"</span>);   <span class="comment">//创建src/template文件目录</span></div><div class="line"></div><div class="line"><span class="comment">//传递参数this.props.appName渲染index.html文件</span></div><div class="line"><span class="comment">//把项目模板中的index.html文件复制到新项目的src路径下</span></div><div class="line">    <span class="keyword">this</span>.fs.copyTpl(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'index.html'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/index.html'</span>),</div><div class="line">      &#123;<span class="attr">appName</span>: <span class="keyword">this</span>.props.appName&#125;</div><div class="line">    );</div><div class="line"></div><div class="line"><span class="comment">//把项目模板中的style.css文件复制到新项目的src/css路径下</span></div><div class="line">    <span class="keyword">this</span>.fs.copy(</div><div class="line">      <span class="keyword">this</span>.templatePath(<span class="string">'css/style.css'</span>),</div><div class="line">      <span class="keyword">this</span>.destinationPath(<span class="string">'src/css/style.css'</span>)</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><span style="color:#195">fs.copy方法会把指定文件复制到目标路径。</span><br><span style="color:#195">fs.copyTpl方法会先传递参数给模板文件，经过模板引擎处理后再进行复制。</span></p><p><strong>③ 下载和安装依赖</strong></p><p>这个阶段做的事情非常简单，就是调用npm或者是bower来下载并安装依赖和相关的node模块。Yeoman提供了几个对应的方法来处理这个过程。</p><p><strong><code>this.npmInstall()</code></strong><br> 使用Npm来安装package.json中的依赖和模块，相当于在终端中输入<code>$ npm install</code>指令。</p><p><strong><code>this.bowerInstall()</code></strong><br>使用Bower来安装bower.json中的依赖和模块，相当于在终端中输入<code>$ bower install</code>指令。</p><p><strong><code>this.installDependencies()</code></strong><br>调用Bower和Npm并且安装package.json和bower.json中依赖的所有模块，相当于先后调用了npmInstall和bowerInstall方法。</p><p>最后，为了帮助更好的理解Yeoman组装流程的三个阶段，给出下面的示意图。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman06.png?raw=true"></p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/yeoman02.png?raw=true&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;tip&quot;&gt;在&lt;a href=&quot;http://wendingdin
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[05] Yeoman脚手架使用入门</title>
    <link href="https://weibo.com/u/3800117445/2018/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B05%5D%20Yeoman%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/06/12/前端工程化系列[05] Yeoman脚手架工具使用入门/</id>
    <published>2018-06-12T13:42:13.000Z</published>
    <updated>2018-06-12T14:28:00.259Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/flowerField/Source/blob/master/Blog/yeoman.png?raw=true"></p><p><code>Yeoman</code>是一款流行的前端的脚手架工具。</p><p><span style="color:red">脚手架工具可以用来快速的自动生成项目的必要文件和基础文件结构。Yeoman使用的内建命令为yo，同时它自己也是一个包管理工具和自动化任务工具，它基于特定的模板来初始化项目。</span></p><p>考虑这样的开发场景：现在我们需要开始一个全新的前端项目，通常需要先处理项目的文件结构，创建包括img、JavaScript、CSS 等静态资源的文件夹，如果团队开发，可能还需要添加 .gitignore忽略文件以及<code>.editorconfig</code>、<code>.eslintrc</code>、<code>package.json</code>、<code>Gruntfile.js</code>以及README.md等配置文件。</p><p>如果你进行的多个前端项目，它们的技术选型差不多(比如都是：<span style="color:#0b0">jQuery + grunt + Vue + Bootstrap</span>)，你会发现这些项目的整体文件结构是相同的。我们在初始化项目的时候，当然可以从0开始搭建，也可以直接把旧项目的结构和相关文件拷贝过来，这其实都是些重复性没有技术含量的工作，而Yeoman 的作用就是减少这些重复性的工作，通过调用 Yeoman 生态圈中的现成的生成器(<code>generator</code>)即可自动生成项目初始化所需要的文件结构、配置文件等。所以简单来说，<strong><code>Yeoman 是一个用于初始化项目的模版工具，用完就可以扔在一边了</code></strong>。</p><p>关于Yeoman的更多信息可以参考<a href="http://yeoman.io" target="_blank" rel="external">Yeoman官网</a>和<a href="https://github.com/yeoman" target="_blank" rel="external">Github托管仓库</a>。</p><h3 id="Yeoman的安装和使用"><a href="#Yeoman的安装和使用" class="headerlink" title="Yeoman的安装和使用"></a>Yeoman的安装和使用</h3><p>用于初始化项目的模板被称为生成器（<code>generator</code>）, 在开源社区中已经有众多现成的generator可以供我们使用（可以在<a href="http://yeoman.io/generators/" target="_blank" rel="external">生成器列表页</a>使用关键字搜索）。在开始项目的时候，我们可以先搜寻是否有匹配当前项目技术栈的生成器，如果有的话直接用就好了，如果找不到合适的generator，那么可以考虑自己来写一个Yeoman生成器，甚至通过很简单的方式我们就可以把自己写的生成器发布出来造福社区。</p><div class="tip">这篇文章并不包含自己创建Yeoman生成器的内容，我只是想简单介绍下Yeoman的特征，以及如何使用Yeoman的生成器来初始化项目这个部分。</div><p><strong>环境准备</strong></p><p>安装yeoman之前，你需要先安装以下环境</p><ul><li>Node.js 6或更高版本</li><li>npm 3或更高版本（通常安装Node的时候默认安装）</li><li>Git版本控制工具</li></ul><p>点击<a href="https://nodejs.org/en/" target="_blank" rel="external">NodeJS官网</a>选择对应系统和版本根据提示完成NodeJS的安装，我们可以通过在终端输入下面的命令来检查Node和npm的安装是否成功。</p><p><code>$ node --version &amp;&amp; npm --version</code></p><p>有些 Node 版本可能安装的是旧版本的 npm，你可以通过以下命令来更新npm</p><p><code>$ npm install -g npm@latest</code></p><p>Git的安装过程请自行百度(OSX 默认安装)，您可以通过以下命名来检查Git</p><p><code>$ git --version</code></p><p><strong>安装Yeoman</strong></p><p>通过下面的命令来安装Yeoman并检查是否安装成功，当前最新版本为<code>2.0.1</code>，<code>-g</code>表示全局安装。</p><p><code>$ npm install -g yo</code><br><code>$ yo --version</code></p><p><strong>generator-typeScript初始化项目示例</strong></p><p> 接下来我们将选择一个生成器(<code>这里以typescript为例</code>)来演示初始化项目的操作，Yeoman将会根据对应的生成器替我们创建好package.json和bower.json等文件，然后自动安装依赖。</p><p><span style="color:#195">① 新建 mytodo 文件夹，生成器生成的脚手架文件会放在这个文件夹中。</span></p><p><code>$ mkdir mytodo &amp;&amp; cd mytodo</code></p><p><span style="color:#195">② 根据项目技术栈需求到官网列表搜索合适的生成器。</span><br><span style="color:#195">③ 通过npm来安装指定的generator。</span></p><p><code>$ npm install -g generator-typescript</code></p><p><span style="color:#195">④ typescript生成器安装完成后，使用yo命令来开始。</span></p><p><code>$ yo typescript</code></p><p>下面给出终端处理的具体细节：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">wendingding:Blog wendingding$ mkdir mytodo &amp;&amp; <span class="built_in">cd</span> mytodo</div><div class="line">wendingding:mytodo wendingding$ npm install -g generator-typescript</div><div class="line">npm WARN deprecated npmconf@2.1.3: this package has been reintegrated into npm and is now out of date with respect to npm</div><div class="line"></div><div class="line">&gt; spawn-sync@1.0.15 postinstall /usr/<span class="built_in">local</span>/lib/node_modules/generator-typescript/node_modules/spawn-sync</div><div class="line">&gt; node postinstall</div><div class="line"></div><div class="line">&gt; yo@1.8.5 postinstall /usr/<span class="built_in">local</span>/lib/node_modules/generator-typescript/node_modules/yo</div><div class="line">&gt; yodoctor</div><div class="line"></div><div class="line">Yeoman Doctor</div><div class="line">Running sanity checks on your system</div><div class="line"></div><div class="line">✔ Global configuration file is valid</div><div class="line">✔ NODE_PATH matches the npm root</div><div class="line">✔ Node.js version</div><div class="line">✔ No .bowerrc file <span class="keyword">in</span> home directory</div><div class="line">✔ No .yo-rc.json file <span class="keyword">in</span> home directory</div><div class="line">✔ npm version</div><div class="line"></div><div class="line">Everything looks all right!</div><div class="line">+ generator-typescript@0.3.0</div><div class="line">added 608 packages <span class="keyword">in</span> 138.302s</div><div class="line">wendingding:mytodo wendingding$ yo typescript</div><div class="line"></div><div class="line">     _-----_</div><div class="line">    |       |    ╭──────────────────────────╮</div><div class="line">    |--(o)--|    │  Let<span class="string">'s make some awesome │</span></div><div class="line"><span class="string">   `---------´   │    typescript project!   │</span></div><div class="line"><span class="string">    ( _´U`_ )    ╰──────────────────────────╯</span></div><div class="line"><span class="string">    /___A___\   /</span></div><div class="line"><span class="string">     |  ~  |</span></div><div class="line"><span class="string">   __'</span>.___.<span class="string">'__</span></div><div class="line"><span class="string"> ´   `  |° ´ Y `</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I will include JSHint and Editorconfig by default.</span></div><div class="line"><span class="string">? First off, how would you like to name this project? wendingdingDemo</span></div><div class="line"><span class="string">? Where should it be compiled to? app/build</span></div><div class="line"><span class="string">? Where should your typescript go? app/src</span></div><div class="line"><span class="string">   create package.json</span></div><div class="line"><span class="string">   create app/src/index.ts</span></div><div class="line"><span class="string">   create app/src/app.ts</span></div><div class="line"><span class="string">   create tslint.json</span></div><div class="line"><span class="string">   create gulpfile.js</span></div><div class="line"><span class="string">   create test/test-greeting.js</span></div><div class="line"><span class="string">   create test/test-load.js</span></div><div class="line"><span class="string">   create README.md</span></div><div class="line"><span class="string">   create .editorconfig</span></div><div class="line"><span class="string">   create .jshintrc</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">I'</span>m all <span class="keyword">done</span>. Running npm install &amp;&amp; bower install <span class="keyword">for</span> you to install the required dependencies. If this fails, try running the <span class="built_in">command</span> yourself.</div></pre></td></tr></table></figure></p><p>按上面的步骤在终端中执行对应命令，我们就可以得到一个基于基于typescript模板生成的初始化项目了，下面列出该项目的目录结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">wendingding:mytodo wendingding$ tree</div><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── app</div><div class="line">│   ├── build</div><div class="line">│   └── src</div><div class="line">│       ├── app.ts</div><div class="line">│       └── index.ts</div><div class="line">├── gulpfile.js</div><div class="line">├── package.json</div><div class="line">├── <span class="built_in">test</span></div><div class="line">│   ├── <span class="built_in">test</span>-greeting.js</div><div class="line">│   └── <span class="built_in">test</span>-load.js</div><div class="line">└── tslint.json</div><div class="line"></div><div class="line">4 directories, 8 files</div></pre></td></tr></table></figure></p><p>最后，根据Yeoman终端中的提示通过<code>$ npm install &amp;&amp; bower install</code>命令来安装必要的依赖即可。</p><hr><ul><li>获取更多、更专业的IT技能，请猛戳~<a href="http://www.520it.com/" target="_blank" rel="external">小码哥教育</a>︎</li><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">Coder_文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a><br><img src="https://github.com/flowerField/Source/blob/master/Blog/banner.jpg?raw=true" onclick="window.open('http://www.520it.com/zt/t30/');"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://github.com/flowerField/Source/blob/master/Blog/yeoman.png?raw=true&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Yeoman&lt;/code&gt;是一款流行的前端的脚手架工具。&lt;/p&gt;
&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
