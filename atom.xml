<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>花田半亩</title>
  
  <subtitle>文顶顶的Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://weibo.com/u/3800117445/"/>
  <updated>2018-06-07T04:02:03.885Z</updated>
  <id>https://weibo.com/u/3800117445/</id>
  
  <author>
    <name>文顶顶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程系列 DOM和DOM操作基础</title>
    <link href="https://weibo.com/u/3800117445/2018/06/06/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20DOM%E5%92%8CDOM%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://weibo.com/u/3800117445/2018/06/06/网络编程系列 DOM和DOM操作基础/</id>
    <published>2018-06-06T05:12:13.000Z</published>
    <updated>2018-06-07T04:02:03.885Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-0-关于DOM"><a href="#1-0-关于DOM" class="headerlink" title="1.0  关于DOM"></a>1.0  关于DOM</h3><p><strong>简单介绍</strong></p><p>DOM（全称为Document Object Model）即<strong><code>文档对象模型</code></strong>，<span style="color:#195">是用于表示和操作HTML或XML文档内容的一套基础API。</span></p><div class="tip"><br>✧ 有时候我们可能会看到DHTML这个专业术语：<span style="color:#195">DHTML是动画HTML的简称</span>，其并不是一项新的技术，而是描述HTML CSS JavaScript技术组合的术语。它曾被认为是HTML/XHTML CSS和JavaScript相结合的产物，像今天的HTML5，但真正凝聚它们的是DOM。<br></div><p>当网页被加载时，浏览器会内部的引擎会根据DOM模型，将结构化文档（比如HTML和XML）解析成一系列的节点，再由这些节点构建出一种树状结构（DOM Tree）。</p><p>下面给出一段简单的HTML示例代码和对应的DOM树结构图。图示中的的方框代表着文档中的一个个节点，每个方框（节点）暨一个Node对象，所有这些节点组成了DOM树。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM树演示代码<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"className"</span>&gt;</span>Hi! 文顶顶<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wendingding.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/dom1.png?raw=true"></p><p><strong>节点的类型</strong></p><p>HTML页面中拥有众多类型的节点，不同类型的节点其表示和操作的方式有很大的差异，下面分别列出：</p><blockquote><p>❏ Text：标签之间或标签包含的文本内容<br>❏ Comment：HTML或XML中的注释<br>❏ Element：网页的各种HTML标签，如a标签 div标签等<br>❏ Document：整个DOM树的根，代表整个文档<br>❏ Attribute：网页元素的属性节点<br>❏ DocumentType：文档类型（doctype）标签<br>❏ DocumentFragment：文档的片段，如果感觉费解请移步<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="external">MDN-DocumentFragment</a></p></blockquote><p>尽管在HTML页面中存在着如此众多类型的节点，但我们真正需要关注的主要还是：<strong><code>元素节点</code></strong>、<strong><code>属性节点</code></strong>和<strong><code>文本节点</code></strong>。在(HTML|XHTML)文档中，文本节点总是被包含在元素节点的内部，属性节点用来对元素做出更具体的描述。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/dom2.png?raw=true"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在上面的图示中，我们提供了一个div标签，该标签拥有“上坡和下坡不就是同一条路吗”文本内容和两个属性节点。</div><div class="line">① 个div标签由开始标签和结尾标签组成，本身是Element类型的。</div><div class="line">② “上坡和下坡不就是同一条路吗”作为div标签的文本内容，本身是Text类型的。</div><div class="line">③ div标签中的class和title是属性节点(key-value)，本身是Attribute类型的。</div></pre></td></tr></table></figure><p><strong>节点关系</strong></p><p>DOM中节点的关系主要有以下几种情况</p><p><strong><code>子节点</code></strong> <strong><code>父节点</code></strong> <strong><code>后代节点(子孙节点)</code></strong> <strong><code>祖先节点</code></strong> <strong><code>兄弟节点</code></strong></p><div class="tip">通常来说<span style="color:#195">Document和HTMLDocument</span>以及<span style="color:#195">Element类型与和HTMLElement类型</span>是严格区分的。Document类型代表一个HTML或XML文档，Element类型代表该文档中的一个元素。而HTMLDocument和HTMLElement通常只针对HTML文档和其元素。</div><h3 id="2-0-Node-amp-amp-Elemet-amp-amp-nodeType"><a href="#2-0-Node-amp-amp-Elemet-amp-amp-nodeType" class="headerlink" title="2.0 Node &amp;&amp; Elemet &amp;&amp; nodeType"></a>2.0 Node &amp;&amp; Elemet &amp;&amp; nodeType</h3><p><span style="color:red">Node（节点）和 Element（元素节点）是严格区分的</span>。也就是说Node和Element不能简单的混为一谈，因为很多人都搞不清楚它们的关系，所以这里单独拿出来讨论。</p><p><strong><code>Node</code></strong> 节点，表示构成DOM树的最小组成部分。换句话来说，在页面中不论是元素节点、文本节点还是注释或者别的东西本质上都是Node节点。</p><p><strong><code>Element</code></strong>元素节点，是Node节点中的一种类型。</p><p>通俗的来讲，node节点就像人一样，是一种基本的类型。（大哲学家柏拉图对人的定义是：人是两腿无毛会直立行走的动物  <span style="color:#0b0">：）</span> 而人这种基本类型中，又存在着小孩、中年人、老年人、学生、教师、司机、男人、女人等种种具体的类型。</p><p>对应到这里的关系，那么Element其实是node的一种更具体的类型。不止Element，像Text、Comment以及Attribute等等这些其实都是特殊的Node，它们拥有自己的类型常量（<span style="color:#f88">TEXT_NODE、COMMENT_NODE以及ATTRIBUTE_NODE</span>）用于区分彼此。</p><p>文档中所有的node节点都拥有nodeType属性，我们可以通过该属性的值来确定节点的具体类型，下面列出对应关系。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/dom4.png?raw=true"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 可以直接在开发者工具的控制台中像下面这样检测和验证节点的类型</div><div class="line">document.body.nodeType //输出结果为1</div><div class="line">document.body.ELEMENT_NODE                           //输出结果为1</div><div class="line">document.body.ELEMENT_NODE == document.body.nodeType //输出结果为true</div><div class="line"></div><div class="line"># 需要注意的是ELEMENT_NODE是常量</div></pre></td></tr></table></figure><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-0-关于DOM&quot;&gt;&lt;a href=&quot;#1-0-关于DOM&quot; class=&quot;headerlink&quot; title=&quot;1.0  关于DOM&quot;&gt;&lt;/a&gt;1.0  关于DOM&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;简单介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DOM（全称为Docu
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 浏览器、HTML和内核(引擎)</title>
    <link href="https://weibo.com/u/3800117445/2018/06/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81HTML%E5%92%8C%E5%86%85%E6%A0%B8(%E5%BC%95%E6%93%8E)/"/>
    <id>https://weibo.com/u/3800117445/2018/06/05/网络编程系列 浏览器、HTML和内核(引擎)/</id>
    <published>2018-06-05T03:11:13.000Z</published>
    <updated>2018-06-06T07:37:46.122Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-0-浏览器的发展和特性"><a href="#1-0-浏览器的发展和特性" class="headerlink" title="1.0 浏览器的发展和特性"></a>1.0 浏览器的发展和特性</h3><p><strong>浏览器的发展</strong></p><blockquote><p>浏览器的历史并不长，即便到今天来算也只有短短的27年，下面列出浏览器历史中的重要节点。</p></blockquote><p><strong>Tim Berners-Lee</strong> 在80年代末期90年代初期发明了世界上第一个浏览器<strong><code>WorldWideWeb(后改名Nexus)</code></strong>，并于1991年公布了源代码。该浏览器支持早期的HTML编辑语言，功能和实现简单但已经能够做到可视化网页内容，于1997年1月7日正式终止开发和支持。</p><p>1993年Marc Andreessen领导的团队开发了真正有影响力的<strong>Mosaic浏览器</strong>，这就是<strong><code>Netscape（网景）浏览器</code></strong>的前身，此时的网景浏览器虽然既没有JavaScript也没有CSS，只能简单的显示静态的HTML元素，但这不影响它在世界范围内取得巨大的成功。</p><p>1995年，受 Mosaic的深刻影响，微软推出了著名的<strong><code>Internet Explorer（IE浏览器）</code></strong>，IE根植于自家的操作系统，逐渐了取代网景的地位，随着网景浏览器的消亡，第一次浏览器大战(微软和网景)宣告结束。</p><p>1995年，Jon和Geir组建了OperaSoftwareASA公司(挪威)，1996年首次公开发布了<strong><code>Opera浏览器</code></strong>。</p><p>1998年，末路的网景公司成立了Mozilla基金会，并主导开发了开源的<strong><code>火狐浏览器(后更名为Firefox)</code></strong>，并于2004年发布1.0版本。因火狐浏览器功能丰富、扩展众多，其市场份额也逐年攀升。</p><p>2003年，苹果发布了<strong><code>Safari浏览器</code></strong>，并于2005年开源了Safari的内核<strong><code>Webkit</code></strong>，加入了第二次浏览器大战（<span style="color:#195">微软-苹果-Mozilla</span>）。</p><p>2008年，谷歌公司以苹果开源的<a href="https://webkit.org/" target="_blank" rel="external">WebKit</a>作为内核，创建了Chromium项目，目标是创建一个快速的、拥有多操作系统(包括桌面和移动端)支持的浏览器。在Chromium的基础上，谷歌发布了自己的浏览器产品<span style="color:#195">Chrome</span>。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/browser_01.png?raw=true"><span style="color:#195"><br>Safari和Chromium使用的都是苹果公司开源的Webkit内核，需要注意的是Chromium本身就是浏览器而不是内核，Chrome浏览器一般选择Chromium的稳定版本作为它的基础来实现。<br></span></p><p>桌面系统中：微软的IE和Mozilla的火狐以及谷歌的Chrome成为三足鼎立之势，它们几乎占据了90%的浏览器市场份额。</p><p>移动系统中：因苹果iOS操作系统和谷歌安卓系统在移动端中的统治地位，移动系统中的浏览器主要是Chrome和Safari二人转。</p><div class="tip">据<a href="https://netmarketshare.com" target="_blank" rel="external">NetMarketShare</a>最新公布的浏览器市场份额数据桌面系统市场份额排名前三的浏览器分别是：<span style="color:red">Chrome(61%)、Internet Explorer(12%) 和Firefox(11%)。</span><br> 移动系统市场份额排名前三的浏览器分别是：<span style="color:red">Chrome(62%)、Safari(27%) 和UC Browser(2.7%)</span>。<br> </div><p><strong>浏览器的特性</strong></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/browser.png?raw=true"></p><p>上图列出了现代浏览器的主要特性，包括网络处理、页面浏览以及多操作系统支持等功能，下面就一些重要的特性做简要说明。</p><p><strong><code>资源管理</code></strong>主要处理各种资源（下载的图片、视频等文件），包括缓存处理、重复下载检查等内容。</p><p><strong><code>开发工具</code></strong>该部分主要面向开发者，主要提供页面HTML元素审查、JavaScript代码调试等内容。</p><p><strong><code>插件扩展</code></strong> 插件和扩展机制是现代浏览器的重要特征，主流浏览器均支持各种形式的插件和功能扩展。</p><p><strong><code>账户同步</code></strong>主要用来同步用户的历史记录、书签等重要信息，为用户提供了多系统下的统一体验。</p><p><strong><code>网络处理</code></strong> 这是浏览器的核心功能，浏览器的账户同步、网页浏览等功能均需要不同程度的依赖于网络模块的处理。</p><p><strong><code>安全机制</code></strong> 该部分旨在提供安全的浏览器环境，包括但不限于显示用户访问网站是否安全、设置网站的安全级别、浏览器证书处理等内容。</p><p><strong><code>网页浏览</code></strong>这是浏览器最重要、最核心也最基本的功能，它通过调用网络模块下载互联网上的资源（网页）并通过资源管理器来获取资源并把它们转化为可视化的内容呈现给用户。</p><p><strong>浏览器的主要组件(结构)</strong></p><p>我们已经简单介绍了浏览器的特性（主要功能），其实作为浏览器来说它最核心的功能是<span style="color:red">通过向服务器发送请求并在得到响应后在浏览器窗口上显示对应的Web资源</span>，而浏览器解释和显示web资源的方式由HTML和CSS规范指定。</p><p><div class="tip"><br>web资源主要包括：<span style="color:#195">html文件 &amp;&amp; CSS文件 &amp;&amp; JS文件 &amp;&amp; 图片、PDF等资源。</span></div><img src="https://github.com/flowerField/Source/blob/master/Blog/html4.png?raw=true"></p><p>上图展示了浏览器的主要组件，下面简单说明。</p><p><strong><code>用户界面</code></strong> 包括地址栏，后退/前进按钮，书签菜单等部分。<br><strong><code>渲染引擎</code></strong> 负责显示网络请求得到的内容。<br><strong><code>网络模块</code></strong> 用于网络请求等处里，与具体的平台无关。<br><strong><code>UI后端</code></strong> 用于绘制组合框和窗口等基本UI部件。<br><strong><code>数据存储</code></strong>用于存储和处理浏览器使用中的必要数据。<br><strong><code>浏览器引擎</code></strong> 浏览器最核心的部分。<br><strong><code>JavaScript解释器</code></strong>用于解析和执行JavaScript代码。</p><p><div class="tip"><br>小贴士：chrome浏览器可以通过在地址栏中输入<span style="color:#195">chrome://version/</span>来查看相关版本信息<br></div>譬如，我所使用的Chrome浏览器相关信息如下<br><img src="https://github.com/flowerField/Source/blob/master/Blog/html9.png?raw=true"></p><h3 id="2-0-HTML的发展和特性"><a href="#2-0-HTML的发展和特性" class="headerlink" title="2.0 HTML的发展和特性"></a>2.0 HTML的发展和特性</h3><p><strong>HTML的发展</strong></p><blockquote><p>HTML（HpperText Markup Language）超文本标记语言，用于网页的创建和显示。现已经发展为HTML5，下面列出HTML发展过程中的关键节点。</p></blockquote><p>1991年，<strong><code>Tim Berners-Lee</code></strong>编写了一份叫做“HTML标签”的文档，里面包含了大约20个用来标记网页的HTML标签，里面直接借用了SGML的标记格式，用于在浏览器中表示文字等信息。</p><p>1993年6月作为IETF（互联网工程工作小组）发布了HTML的草案（并非标准）。后来，<a href="https://www.w3.org/" target="_blank" rel="external">W3C组织,全称World Wide Web Consortium万维网联盟</a>取代IETF的角色，成为HTML的标准组织。</p><p>1997年12月18日，W3C发布<strong><code>HTML 4.0</code></strong>推荐标准。</p><p>1999年12月24日，W3C发布<strong><code>HTML4.0.1</code></strong>推荐标准。</p><p>HTML 4.0.1发布后，HTML到达了一个拐点，这之后很长时间里HTML的发展走向了另外的方向。</p><p>2000年1月26日，W3C发布了<strong><code>XHTML1.0</code></strong>，这是在HTML 4.01之后的第一个修订版本，其中X代表“EXtensible”，扩展的意思。新的标准并没有引入任何新标签或属性，而是要求使用XML般的严格语法，被称为XML风格的HTML。</p><p>XHTML1.0的推出刚好碰上了CSS的崛起，Web开发设计者们开始意识到Web标准问题，基于XHTML的严格语法规范被视为编写 HTML代码的最佳实践。</p><p>2001年5月31日，W3C发布了<strong><code>XHTML1.1</code></strong>。如果说XHTML 1.0是XML风格的HTML，那么XHTML 1.1则是货真价实的XML。这意味着XHTML 1.1无法使用<strong><code>text/html MIMEType</code></strong>直接输出，而如果Web开发者使用<strong><code>XML MIMEType</code></strong>，则当时的主流浏览器压根不支持。看上去，W3C似乎正在与当时的Web脱节。</p><p>2002年8月5日，W3C发布了<strong><code>XHTML 2.0</code></strong>工作草案，XHTML 2不向前兼容，甚至不兼容之前的HTML，它是一种全新的语言。现在来看这实在是一场灾难，这是吃力不讨好的无用功。</p><p>W3C闭门造车的作风导致Opera，苹果以及Mozilla的代表们开始发出反对声音。2004年，Opera的 Ian Hickson提议在HTML基础上进行扩展以适应新的Web应用，该提议遭到W3C的拒绝。于是，他们自发组织成立了超文本应用技术工作组(Web Hypertext Application Technology Working Group)<a href="https://whatwg.org/" target="_blank" rel="external">WHATWG</a>。WHATWG和W3C组织开始在HTML发展的这条路上走向了不同的方向。</p><p>WHATWG组织的主要工作包括两部分，<strong><code>Web Forms 2.0和Web Apps 1.0</code></strong>，它们都是HTML的扩展，后来合并到一起成为现在的HTML 5规范。</p><p>在WHATWG致力于HTML5的同时，W3C继续他们的XHTML 2.0，然而，他们慢慢地陷入困境。2006年10月，<strong><code>Tim Berners-Lee</code></strong>发表了一篇博客文章，表示从HTML走向XML的路是行不通的，几个月后（2007年）W3C组建了一个新的HTML工作组，他们非常明智地选择了WHATWG的成果作为基础来立项HTML 5。也就是说，W3C同时在进行着两套规范，XHTML 2.0 和HTML 5，而WHATWG也在进行着HTML5规范的工作。</p><p><span style="color:red">2012年，HTML 5被两大组织WHATWG和W3C接纳为候选标准。好在经过长达八年的扯皮和博弈之后，2014年10月底W3C宣布HTML5正式定稿。</span></p><p>纵观HTML5的发展史，有用户的需求在推动，有技术开发者的需求在推动，更有巨大的商业利益在推动，关于HTML5发展史中的博弈可以参考<a href="https://www.cnblogs.com/yy-hh/p/4509748.html" target="_blank" rel="external">html5的发展历程和由此引起的政治斗争</a>。下面给出HTML发展的主要节点图示。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html.png?raw=true"></p><p><strong>HTML5的特性</strong></p><p>HTML5包含了一系列的标准，其构建思想和前瞻性意义深远。更重要的是，HTML5不仅仅可以用来构建内容更丰富的网页，更对作为平台来开发提供了能力支持。当前，所能在W3C官网找到的HTML5最新版本为2018年4月26日发布的<a href="https://www.w3.org/TR/2018/WD-html53-20180426/" target="_blank" rel="external">HTML 5.3工作草案</a>,也可以在<a href="https://github.com/w3c/html" target="_blank" rel="external">W3C组织github发布页</a>查看详情。</p><p>HTML5标准大概可以分为10个类别，它们分别是Offline（离线）、Storage（存储）、Connectivity（连接）、File access（文件访问）、audio/video（音频和视频）、3D/graphics（3D和图形）、presentation（展示）、performance（性能）、semantics（语义）和Nuts and bolts（其它）。其中每个类别都由众多的技术和规范组成。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html2.png?raw=true"></p><p>更对关于HTML5规范的说明可以参考<a href="https://www.w3.org/" target="_blank" rel="external">W3C官网</a>或者<a href="http://www.chinaw3c.org/" target="_blank" rel="external">W3C中国</a>或者<a href="http://blog.shaochuancs.com/" target="_blank" rel="external">HTML5标准阅读技术博客</a></p><p><strong>单独说说HTML5</strong></p><p>现在我们都知道2007年的时候，W3C开始从WHATWG接手相关工作，重新开始发展HTML5。W3C为什么突然决定重新发展HTML5，推动新标准呢？我们可以试着从三个方面来试着分析。</p><p><span style="border:1px solid #000">&nbsp;用户需求的推动</span></p><p>在2005年左右的时候，互联网的发展进入到新的时期。随着宽带的普及和电脑硬件的发展和性能增强，消费者不单单通过互联网来浏览网页、收发邮件，流媒体和网页游戏开始进入到用户的视野。</p><p>对于这块需求，由于当时的HTML标准并没有把握住互联网产业的变化及时演进，相关的浏览器产品也没有升级，因此这块新需求就自然被浏览器插件满足了，那就是Flash。这个部署在亿万浏览器里的商业插件俨然成为了事实标准。</p><p><span style="border:1px solid #000">&nbsp;技术需求和商业利益的推动&nbsp;</span></p><p>2005年<a href="http://tech.sina.com.cn/focus/Adobe_Mm/" target="_blank" rel="external">Adobe花费34亿美元巨资收购Macromedia</a>，把Flash收归旗下，紧接着大幅推广FLV流媒体。</p><p>除Flash这个商业产品成为了事实标准外，W3C当时还面临着另外的尴尬，那就是私有扩展协议的制造者IE。IE当时在桌面浏览器占有垄断地位，并且扩展了大量的IE 私有语法，开发者完全不知道这些语言是谁定义的。基于上面的事实，当时的情况是整个web世界，都被微软和Adobe这两家公司捆绑了。于是以苹果和谷歌为代表的很多IT巨头开始行动起来，既然大家都是W3C的主席单位，好吧，那我们就重新开始做HTML5吧。</p><p>HTML5其实就是这么诞生的，所以<span style="color:red">2007年，其实也是IE和Flash由盛转衰的转折点</span>。HTML5的发展大体经历了<span style="color:red">Web增强</span>和<span style="color:red">移动互联网</span>两个阶段，而现今我们看到的是属于HTML5的春天。需要注意的是虽然HTML5意义深远，但目前来说并非所有浏览器都对HTML5提供100%的支持，我们可以通过<a href="http://html5test.com/" target="_blank" rel="external">HTML5TEST</a>网站来查看各浏览器对HTML5特性的支持情况。</p><h3 id="3-0-浏览器内核（渲染引擎）"><a href="#3-0-浏览器内核（渲染引擎）" class="headerlink" title="3.0 浏览器内核（渲染引擎）"></a>3.0 浏览器内核（渲染引擎）</h3><p><strong>浏览器内核简单介绍</strong></p><p>浏览器内核作为浏览器中最重要的模块，其核心作用是将页面转换为可视化的结果。浏览器内核一般分成<code>渲染引擎(layout engineer 或者 Rendering Engine)</code>和<code>JS 引擎</code>两部分，只是通常我们总是把渲染引擎称之为内核，习惯把JS引擎区分开来单独说明。</p><p><strong><code>渲染</code></strong>指的是根据描述或定义构建模型，通过模型生成可视化图像的过程。</p><p><strong><code>渲染引擎</code></strong>指的是浏览器中能够将HTML/CSS文本及其相关的资源文件转换为图像结果的模块。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html6.png?raw=true"></p><p>目前，主流浏览器的渲染引擎主要有Trident（IE内核）、Gecko (Firefox内核)、Webkit (Safari内核）、Blink（Chrome内核）等，其中Blink其实是从WebKit的分支Fork出来的，下表列出了部分浏览器和内核的对应关系。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html5.png?raw=true"></p><p>关于浏览器内核演进和发展的历史比较复杂，这里给出主流内核的发布时间节点和家谱关系图。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html7.png?raw=true"></p><p>浏览器和内核相关的更多信息，请参考<a href="https://liulanmi.com/" target="_blank" rel="external">浏览迷官网</a>或者<a href="http://www.infoq.com/cn/news/2013/02/webkit-history-and-now" target="_blank" rel="external">WebKit的前世今生</a>或者<a href="从KHTML到WebKit，再到Blink">从KHTML到WebKit，再到Blink</a>或者<a href="http://web.jobbole.com/84826/" target="_blank" rel="external">主流浏览器内核介绍</a>。</p><p><strong>渲染引擎的工作流程和主要特征</strong></p><p>浏览器内核渲染引擎工作的主要流程如下图所示：</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/html8.png?raw=true"></p><blockquote><p><strong>渲染引擎工作流程说明</strong></p><p>① 解析HTML并构造DOM树（Parsing HTML to Construct the DOM tree）<br>② 构造渲染树（Render Tree construction）<br>③ 布局渲染树（layout of the render tree）<br>④ 绘制渲染树（Painting the render tree）</p></blockquote><p><strong>渲染引擎的特征</strong></p><p>如果按照具体的功能处理来划分，那么渲染引擎主要包括<span style="color:red">HTML解释器、CSS解释器、JavaScript引擎以及布局和绘图</span>等模块，以及这些模块和基础模块(渲染引擎需要依赖的如网络、存储、音频|视频等底层模块)调用相关的部分。下面给出渲染引擎的构成模块已经依赖的底层模块关系图。<br>                                                                                     <img src="https://github.com/flowerField/Source/blob/master/Blog/html10.png?raw=true"></p><p><strong><code>HTML解释器</code></strong> 用于解释HTML的文本，主要用于将HTML文本解释成DOM树，DOM（文档对象模型）是一种用来表示文档的树状结构。</p><p><strong><code>CSS解释器</code></strong>级联样式表的解释器用于为DOM树中的各元素对象(Node)计算出样式信息，为网页的最终布局做好准备工作。</p><p><strong><code>JavaScript引擎</code></strong>JavaScript脚本语言把网页带到了全新的世界，JavaScript引擎能够解释JavaScript代码并通过DOM接口和CSSOM接口来修改网页的内容和样式信息，从而影响渲染结果。</p><p><strong><code>布局和绘图(Layout)</code></strong>在DOM创建后，需要把页面中的元素对象和样式信息结合在一起并计算出大小、位置等布局信息。根据这些信息先构成用于表示页面的内部表示模型（渲染模型），然后调用图形库来绘制所有的节点并最终得到我们看到的网页视图（图片）。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-0-浏览器的发展和特性&quot;&gt;&lt;a href=&quot;#1-0-浏览器的发展和特性&quot; class=&quot;headerlink&quot; title=&quot;1.0 浏览器的发展和特性&quot;&gt;&lt;/a&gt;1.0 浏览器的发展和特性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;浏览器的发展&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [011]-空谷幽兰</title>
    <link href="https://weibo.com/u/3800117445/2018/05/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B011%5D-%E7%A9%BA%E8%B0%B7%E5%B9%BD%E5%85%B0/"/>
    <id>https://weibo.com/u/3800117445/2018/05/25/读书笔记 [011]-空谷幽兰/</id>
    <published>2018-05-25T00:11:18.000Z</published>
    <updated>2018-06-02T02:28:10.157Z</updated>
    
    <content type="html"><![CDATA[<div style="color:#195; font-size:20px">※·※序言 (空谷幽兰)※·※</div><p>比尔·波特1972年去往台湾。<br>天亮前起来诵经，夜晚听钟声，一日三餐素食，一个房间，一张床，一顶蚊帐，没有钞票。如果我的腿太痛，我就读书。</p><p>天地就在身边，死亡近在咫尺。<br>遵循严格的戒律，戒律就是自己对自己的要求。戒律是修行成为可能。如果你对自己不做要求，修行就会一无所获。</p><p>道教徒和佛教徒追求的是不变的东西，这是他们不追名逐利的原因。</p><div style="color:#195; font-size:20px">※·※ 第一章 隐士的天堂 ※·※</div><p>在整个中国的历史上，一直就有人愿意在山里度过他们的一生：吃的很少，穿得很破，睡的是茅屋，在高山上垦荒，说话不多，留下来的文字更少——也许只有几首诗、一两个仙方什么的。他们与时代脱节，却并不与季节脱节；他们弃平原之尘埃而取高山之烟霞；他们历史悠久，而又默默无闻——他们孕育了精神生活之根，是这个世界上最古老的社会中最受尊敬的人。</p><p>中国人一直很崇敬隐士，没有人曾对此做出过解释，也没有人要求解释。隐士就那么存在着：在城墙外，在大山里，雪后飘着几缕孤独的炊烟。从有文字记载的时候起，中国就已经有了隐士。</p><p>只有当我们独处的时候，我们才会更清楚的意识到，我们与万物同在。</p><p>1972年开始了解中国的隐士传统。从美国搬到了台湾。<br>三年后，结束了寺院生活，隐居在竹子湖山村，并翻译一些隐士的著作。<br>1987年冬天，台湾到中国大陆旅游的禁令解除。<br>1989年春天，获得赞助同朋友史蒂芬·约翰逊成行，前往中国大陆寻找隐士。</p><p>两星期后，在香港碰头，然后一起飞往北京。<br>第二天，参观了广济寺，此乃中国佛教协会所在地。我问佛协的副会长周绍良，他是否知道可以到哪里找到几个隐士。他还没来得及回答这个问题，广济寺的方丈净慧法师说，他曾经听说过西安附近的终南山里有隐士。</p><p>两天后，参观完长城，回到北京。<br>通过火车这种交通工具去往北京西北的中国古代佛教中心大同。<br>第二天早晨，到达大同。<br>第二天，第一次冒险进入农村，去游览恒山，没有发现任何有隐士居住的迹象。<br>次日，动身前往五台山，我们想那儿可能有隐士居住。</p><p><span style="color:red">可是事实却并非如此。视野里几乎没有一棵树。我推断：没有森林就没有枯枝，没有枯枝就没有木柴，没有木柴就没有茶，没有茶就没有禅，没有禅就没有隐士。</span></p><p>他们先后向我保证，如今所有的和尚和尼师都生活在寺庙里。据他们所知，五台山或中国其他任何山上，都没有隐士。</p><p>接着花了几天的时间游览西安，之后去参观了最后一个地方：草堂寺。</p><p>领我们参观了寺庙的庭院之后，方丈把我们带到他的方丈室里。我告诉他，我们正在寻找隐士。此时，他的几个弟子也拥进屋里。他看看他们，然后看看我，最后说：“我对隐士的事情一无所知。但是既然你们远道来了，为什么不参拜一下路边的小砖塔呢？”<br>我们从山后的小路下山。<br>我们发现了隐士的天堂。临走前，我问一位和尚这些山的名字。他说：“这里是终南山。这儿是真修行的出家人来的地方。”</p><p>在过去的三十年里，中国国内和国外的观察家们都断言，这场运动是一个巨大的成功，它彻底清除了人民群众的精神鸦片和迷信。大多数观察家已经把佛教视为死去的宗教。</p><p>动身前两个星期，台湾陆委会行政秘书告诉我，共产党早就把大陆上的隐士连同真正的出家人都“消灭”光了。</p><p>他们的微笑，使我们觉得自己遇见了中国最幸福、最有智慧的人。</p><p>我们所考察的山中，有一座叫太姥山，就在福建省东北部。</p><p>太姥山上五十年。修行方式是持名念佛，念阿弥陀佛。</p><div class="tip">(注)主要行动路线。太姥山—(公共汽车)—&gt;福州—(公共汽车)—&gt;厦门—(船)—&gt;香港——&gt;台湾。</div><div style="color:#195; font-size:20px">※·※ 第二章 月亮山 ※·※</div><p>当我头一次听说终南山的时候，我既不知道它们的位置，也不了解他们的重要性。</p><p>名词是不变化的，因此无法区分单复数，所以我仍然不知道，终南山是指一座山，还是指一列山脉。几天之后，我发现，它既指一座山，又指一列山脉。回到台湾以后，我了解到，它所指的远远不仅是山脉。</p><div class="tip">秦岭-终南山-南山-昆仑-中南山脉-萨满。</div><br>隐士传统之所以能够延续，是因为中国人一向尊重过去，而隐士则保持了那个“过去”最重要的因素——它的精神传统。<br><br><div style="color:#195; font-size:20px">※·※ 第三章 举世皆浊 ※·※</div><p>修道意味着孤独的生活或者是从政生涯。<br>屈原是中国历史上第一位伟大的诗人。大约公元前300年左右，他以三闾大夫的身份供职于楚国宫廷。</p><p>屈原没能称为一位隐士，他拒绝了渔父的建议，跳进了汨罗江。</p><p>每年的阴历五月初五，中国人仍然画着龙舟去捞救屈原。人们往水里扔粽子，好让鱼龙乱作一团，以争取时间，使龙舟能够追上屈原。但是，不管人们怎样努力，诗人依旧年年沉水——只苦了中国的江河，变得越来越浑浊了。</p><p>道德和政治之间的矛盾是隐士传统的核心。</p><p>张良和诸葛亮是两位著名的隐士。</p><p>隐居和从政被看做是月亮的黑暗和光明，不可分而又互补。隐士和官员常常是同一个人，只是在他声明中的不同时期，有时候是隐士，有时候是官员罢了。</p><p>当中国的第一位伟大的诗人从宫廷中被放逐出来的时候，他自沉而葬身于鱼腹；中国第二位伟大的诗人陶渊明则还没有等到任期结束，就隐居到了乡下。在中国，隐士们有一种解脱自在的精神，即保持心灵而不是身体远离城市的尘嚣。</p><div style="color:#195; font-size:20px">※·※ 第四章 访道 ※·※</div><p>道德经是道教最早的经典，迄今为止还没有哪一种对道的解释能够超过它。</p><p>中国的警察就像北欧神话中的巨人。不管在哪里，警察检查一次，一般都要花上二十元到一百元人民币。</p><p>祖庵村是重阳宫的所在地，重阳宫是中国过去最著名的道教圣地之一，它建于13世纪，供奉的是道教全真派的创始人王重阳。</p><p>从那以后，王重阳在这里度过了七年的时光。他和吕洞宾、汉钟离三个人一起生活在一个岩洞里，那个岩洞，王重阳称之为“活死人墓”。</p><div style="color:#195; font-size:20px">※·※ 第五章 鹤之声 ※·※</div><p>如道教徒所宣称的，道教的历史形态可能起源于终南山西部的楼观台。</p><p>玉泉院是一座道观，建于11世纪中期，是为了纪念陈抟而修建的。在院基的东面，有华佗墓。</p><p>仙姑观这里是谢道长住的地方，我们找到他的时候，他正在床上支着身体，用一盏热灯烤膝盖，治疗关节炎。他曾经以武功而闻名于世，现在却连走路都有点困难了。</p><p>他的身子骨异常硬朗，心清澈得就像久雨后的天空。</p><p>他们都怎么啦？<br>有些人死了，很多人走了。还有很多人还俗了。<br>道观怎么样呢？<br>道观里挤满了游客。什么都变了，现在旅游局管着道观了。</p><p>我舒展着四肢，躺在树荫底下，看着天上的云，不知道从什么地方飘来，然后又消失在无何有之乡。</p><p><span style="color:red">对危险的清醒认识能够使人全神贯注。</span><br>如果你准备要学道，你不必去找师父，师父会找你的。道是不可以言传的，悟道前你必须修行。悟是自然发生的，对每个人来说都是不同的，主要是清心寡欲。修行要花很长时间，所以你必须保持身体健康。如果你有很多念头和欲望，你就活不到实现目标的时候。</p><p>大部分师父在他们一生中，只把核心的秘密传授给一位弟子，而且大师们都已经隐居到山的更深处去了，拒绝在这个物质时代教化人。他说，道观里的教导是肤浅的。</p><p>仙鹤在道教中是变化、超越、洒脱、纯洁和长寿的象征。用它来代表华山是再完美不过的了。可是很显然，这只鹤已经飞走了。</p><p>半路上，我的腿因为精疲力尽和恐惧而开始发抖，我问向导还有多远。他说，两个小时，然后指指就在白云下的那个崖顶。当他刚才告诉我们苏道长的岩洞不远的时候，我忘了问他到底有多远。</p><div style="color:#195; font-size:20px">※·※ 第六章  登天之道 ※·※</div><p>道教徒寻求的是修成一个长生不死之身，而佛教徒寻求的是摆脱一切身相。</p><p>在中国出现的八大佛教宗派中，有七个宗派是在终南山里或者是其附近开出它们的第一片花瓣的。它们是三论宗、唯识宗、律宗、净土宗、华严宗、密宗和禅宗。</p><p>在古代，蓝田地区以产玉而著名（道教徒们追求长生不死的过程中所使用的一种矿物）现在变成铀了。两种不同的矿物，都能把人送上天堂。</p><p>我问续洞主持天气是不是太冷了，香蕉能结果吗，他说，他种这几棵香蕉树只是为了好玩。我点点头。在台湾，我也在自己的窗外种了一棵，也只是为了好玩——为了听夏雨打在芭蕉叶上的声音。</p><p>在禅宗里，我们不停的问，谁在念佛。<br>在净土宗里，我们只是念佛号，再也没有什么了。所有的法门都适合，法无对错，修行的差别只是根基的问题。法门就像糖，人们喜欢不同种类的糖，但是它只是糖，法是空的。</p><p>为什么这么多人来到终南山修行？<br>终南山一直延伸到印度，最初的和尚们来中国的时候，他们就定居在终南山里。另外，这一带仍然有很多的在家人，愿意供养来修行的人。</p><p>不管鸠摩罗什是在哪里工作的，一千六百年来，他所翻译的经文，无论是在风格上还是在语法上，都再也没有人能够超过他。</p><p>如果不过一种合乎正道的生活，就什么也成就不了。</p><p>实际上，住在净业寺的八九位和尚中，有三位是北大中文系的毕业生。我惊诧于年轻出家人受教育程度之高。</p><p>旅游已经把少林寺变成了一座养老院，任何呆在那里的人，都被认为对名闻利养比对佛法更感兴趣。</p><p>如果你修行，你就会有所得，如果你不修行，你就会一无所获。</p><div style="color:#195; font-size:20px">※·※ 第七章 云中君 ※·※</div><p>西安现在仍然是一个旅行者的城市，与此相协调的，它的城市标志是一只大雁。</p><p>曲水流觞的游戏，起源于曲江池（长安八景之一）。</p><p>王宝钏和薛平贵的故事，寒窑。</p><p>我用望眼镜浏览了一下周围的平原，到处都是坟墓。</p><p>兴教寺和玄奘塔。兴教寺的匾额由康有为1923年题写。</p><p>禅宗的和尚不念经。</p><p>您修哪个法门？念佛还是坐禅？<br>答：我只是随缘度日。</p><p>人们来参观的时候，你教他们佛法吗？<br>答：不一定，每个人都不一样。要教他们，你必须了解对方心里在想什么，而且你得有些能力。如果有人要淹死了，而你不会游泳，那么你跳下去没有任何好处。如果一个人不想被拯救，你就救不了他，他必须愿意被拯救。</p><div style="color:#195; font-size:20px">※·※ 第八章 朱雀山 ※·※</div><p>在中国的古代，每个方向都有自己的神：东方青龙，北方玄武，西方白虎，南方朱雀。最早使用这些字眼的书是《山海经》。</p><div class="tip">作者记录了时任中国国家气功团团长何建新给自己治疗疹子的事情，非常有意思。</div><p>我登了记，付了相当昂贵的医药费——三十元人民币，也就是六美元。</p><p>他让我站着，两腿分开，闭上眼睛，然后开始围着我转圈，哼哼着，用他体内气的运动，发出搅动声和嘶嘶声。这样做了几分钟之后，他让我坐下来，然后开始往我体内扎针灸用的针：在我的拇指和食指之间，脖子后面、胳膊上、膝盖上以及脚裸上然后他让我闭上眼睛呼气，我仿佛是一只被针扎了的轮胎。</p><p>当我坐在那里漏气的时候，他给其他病人治疗，偶尔回来捻弄一下那些针，并喊叫着把他的气泼洒在四周。最后，他给我开了一种草药，两天后疹子消失了。</p><p>杨虎城将军墓.<br>公元712年，杜甫出生在临近的河南省，但是他的祖祖辈辈却住在长安南面的少陵原，后来他的创作高峰期大部分是在这里度过的。实际上，他把自己称为少陵野老，并把他的诗集用少陵来命名。</p><p>将军的生活过的比这个国家最伟大的诗人好。</p><p>法不是片面的，你必须修所有的法。在禅宗里，你没有念头。在净土宗里，你有一个念头。它们都是一样的。他们的目的都是要把你的本来面目指给你看。</p><p>印光和虚云被认为是二十世纪最伟大的大师之一。虚云革新了中国禅宗，与此同时，印光革新了净土宗。听过他讲法的人都说，那些讲法是空前绝后的。</p><p>19世纪末，去顶峰的沿途还有七十二座寺庙。现在只剩下五座了，而且都是重修的。20世纪60年代，当文革席卷中国的时候，所有站着的东西都被红卫兵打到了。</p><p>旅馆是最贱在刘澜涛避暑别墅的遗址上建立起来的。文革前，刘澜涛是中国西北五省的中共书记，也是中国最有权力的任务之一。文革时，他被打成了走资派。我对刘澜涛选择风景的眼光表示欣赏。</p><p>修行要靠个人，真修行的人太少了。我不怎么修行，我晚上打坐，白天干杂活儿，我只是在照管这座庙。</p><div style="color:#195; font-size:20px">※·※ 第九章 走过销魂桥 ※·※</div><p>灞河和灞桥。<br>汉文帝：一位罕见的国君，他只想过得像隐士一样快活，他对于俭朴的热爱几乎是传奇性的，他在宫廷里穿草鞋。<br>梁鸿和韩康。</p><p>坑儒谷：文革期间，红卫兵们很喜欢提示知识分子坑儒谷的存在。<br>刘邦和项羽。<br>鸿门和骊山。<br>骊山最主要也最著名的温泉叫华清池。<br>西安事变——捉蒋亭。<br>唐玄宗和杨贵妃。<br>女娲是伏羲的妹妹和妻子。</p><p>道没有名字，修道就意味着回归于无。<br>当人们努力去寻找道的时候，他们就失去了道。他们混淆了有和无。我们所做的一切只是修德，包括我们的精神、我们的心还有想法。</p><p>陈道长是一个很少见的头脑清晰、心直口快的道士。他说完了想说的话，就要干杂活儿去了，</p><p>菩提达摩的眼皮：一千五百年前，菩提达摩为了防止坐禅时睡着，把眼皮割掉了。他的眼皮落地的地方，长出了第一批茶树。</p><p>在中央展厅里，我突然发现自己站在释迦摩尼佛的舍利前。</p><p>公元7世纪，当玄奘大师从印度回长安的时候，在他所带回的物品中，有五百颗释迦摩尼佛的舍利。</p><p><span style="color:red">当一具普通的肉体被焚烧以后，剩下来的只有碎骨头片和灰烬。当一个修行人的遗体被焚烧以后，人们就会找到一些像玻璃或者是瓷器一样的小石头。释迦摩尼佛的舍利到达中国以后，它们被放进两只小玻璃瓶中。这两只小玻璃瓶又被放进一只小金盒里，然后这只金盒又被放进一只镶着白银和母珠的大盒子里，最后人们才把这只大盒子安放在那座小石塔里。<span></span></span></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※序言 (空谷幽兰)※·※&lt;/div&gt;

&lt;p&gt;比尔·波特1972年去往台湾。&lt;br&gt;天亮前起来诵经，夜晚听钟声，一日三餐素食，一个房间，一张床，一顶蚊帐，没有钞票。如果我的腿太痛，我就读书。&lt;/
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[04]-Grunt构建工具的使用进阶</title>
    <link href="https://weibo.com/u/3800117445/2018/05/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B04%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/05/21/前端工程化系列[04] Grunt构建工具的使用进阶/</id>
    <published>2018-05-21T05:12:13.000Z</published>
    <updated>2018-05-21T08:40:52.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">前端工程化系列[02]-Grunt构建工具的基本使用</a>和<a href="http://wendingding.com/2018/05/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[03]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E8%BF%9B%E9%98%B6/" target="_blank" rel="external">前端工程化系列[03]-Grunt构建工具的运转机制</a>这两篇文章中，我们对Grunt以及Grunt插件的使用已经有了初步的认识，并探讨了Grunt的主要组件以及它的运转机制，这篇文章是Grunt使用的进阶教程，主要输出以下内容：</p><p>❏ &nbsp;<span style="color:#f25">Grunt项目的自定义任务</span><br>❏ &nbsp;<span style="color:#f25">Grunt任务的描述和依赖</span><br>❏ &nbsp;<span style="color:#f25">Grunt多目标任务和选项</span><br>❏ &nbsp;<span style="color:#f25">Grunt项目任务模板配置</span><br>❏ &nbsp;<span style="color:#f25">Grunt自动化构建和监听</span></p></blockquote><h3 id="3-1-Grunt自定义任务"><a href="#3-1-Grunt自定义任务" class="headerlink" title="3.1 Grunt自定义任务"></a>3.1 Grunt自定义任务</h3><p>在使用Grunt的时候，可以先到Grunt官网的插件列表搜索是否有适合自己项目的Grunt插件，如果有那么建议直接使用，如果没有那么开发者可以尝试自定义任务或者是自己创建对应的插件。Grunt的插件其实就是一些封装好的任务(Task)，没有什么稀奇的，Grunt支持自定义任务，而且方式非常简单。</p><p>如果我们需要定义一个任务，向控制台里输出字符串信息，那么在package.json文件、Gruntfile文件已经创建且grunt本地依赖已安装的前提下，如下编辑Gruntfile文件即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1)自定义任务(一)</span></div><div class="line">    <span class="comment">//向控制台输出:hello 文顶顶</span></div><div class="line">    <span class="comment">//第一个参数:任务的名称(Task)</span></div><div class="line">    <span class="comment">//第二个参数:具体的任务内容</span></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"hello 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2)自定义任务(二)</span></div><div class="line">    grunt.registerTask(<span class="string">"football"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>终端输入命令执行任务，可以单个执行，也可以一起执行，下面给出具体执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">wendingding:02-Grunt_Test wendingding$ grunt hello</div><div class="line">Running "hello" task</div><div class="line">hello 文顶顶</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:02-Grunt_Test wendingding$ grunt football</div><div class="line">Running "football" task</div><div class="line">皇家马德里: how are you!</div><div class="line">尤文图斯: how old are you！</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:02-Grunt_Test wendingding$ grunt hello football</div><div class="line">Running "hello" task</div><div class="line">hello 文顶顶</div><div class="line"></div><div class="line">Running "football" task</div><div class="line">皇家马德里: how are you!</div><div class="line">尤文图斯: how old are you！</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>通过上面的代码我们可以看到，<span style="color:red">自定义任务非常简单，只需要调用grunt对象的registerTask方法即可，其中第一个参数是Task的名称，第二个参数是回调函数用来存放具体的任务（比如这里是打印输出）。</span></p><div class="tip">在自定义任务中，我们用到了grunt.log.writeln函数，这是Grunt提供的众多内置方法之一，作用是向控制台输出消息并换行。同类型的方法还有grunt.log.error()、grunt.log.subhead()等方法，大家可以到<a href="https://gruntjs.com/api/grunt.log" target="_blank" rel="external">官网API文档</a>自行查看。</div><p>Grunt项目在具体使用的时候，通常是自定义Task + Grunt插件相结合的形式，我们来看下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1)自定义任务(一) 任务名称 hello</span></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"hello 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2)自定义任务(二) 任务名称 football</span></div><div class="line">    grunt.registerTask(<span class="string">"football"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//(2) 插件的处理</span></div><div class="line">    <span class="comment">//使用步骤:</span></div><div class="line">    <span class="comment">//[1] 先把对应的插件下载和安装到本地的项目中 $ npm install grunt-contrib-concat --save-dev</span></div><div class="line">    <span class="comment">//[2] 对插件(任务)进行配置 grunt.initConfig</span></div><div class="line">    <span class="comment">//[3] 加载对应的插件 loadNpmTasks</span></div><div class="line">    <span class="comment">//[4] 注册任务      grunt.registerTask</span></div><div class="line">    <span class="comment">//[5] 通过grunt命令执行任务</span></div><div class="line">    <span class="comment">//配置插件相关信息</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">        <span class="string">"concat"</span>:&#123;</div><div class="line">            <span class="string">"dist"</span>:&#123;</div><div class="line">                <span class="string">"src"</span>:[<span class="string">"src/demo_one.js"</span>,<span class="string">"src/demo_two.js"</span>,<span class="string">"src/demo_three.js"</span>],</div><div class="line">                <span class="string">"dest"</span>:<span class="string">"dist/index.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务（一）：把hello \ football \ concat 这三个Task注册为default的Task</span></div><div class="line">    <span class="comment">//当执行$ grunt 或者是$ grunt default的时候，会顺序执行者三个任务！</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"hello"</span>,<span class="string">"football"</span>,<span class="string">"concat"</span>]);</div><div class="line">    <span class="comment">//注册任务(二)</span></div><div class="line">    grunt.registerTask(<span class="string">"customTask"</span>,[<span class="string">"hello"</span>,<span class="string">"football"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>对于上面的Gruntfile文件，如果在终端输入<code>$ grunt</code>或者<code>$ grunt default</code> 命令则依次执行hello football和concat三个任务，输入<code>$ grunt customTask</code>则一次执行hello football 自定义任务。</p><h3 id="3-2-任务描述和依赖"><a href="#3-2-任务描述和依赖" class="headerlink" title="3.2 任务描述和依赖"></a>3.2 任务描述和依赖</h3><p><strong>设置任务描述</strong></p><p>随着项目复杂性的增加，Grunt任务也会越来越多，而任务(Task)的可用性、用途以及调用方法可能会变得难以追踪。所幸，我们可以通过给任务设定相应的描述信息来解决这些问题。</p><p>要给任务设置描述信息非常简单，只需要在调用registerTask方法的时候多传递一个参数即可（作为第二个参数传递），我们可以把一个具体的字符串描述信息作为函数的参数传递。</p><p>这里，我们修改上面示例代码中football任务部分的代码，并任务设置描述信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grunt.registerTask(<span class="string">"football"</span>,<span class="string">"17-18赛季 欧冠八分之一决赛抽签场景"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.writeln(<span class="string">"皇家马德里: how are you!"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"尤文图斯: how old are you！"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>此时，在终端中输入<code>$ grunt --help</code>命令就能够看到当前Grunt项目中可用的Task，以及相应的描述信息了，关键信息如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Available tasks</div><div class="line">         hello  Custom task.</div><div class="line">      football  17-18赛季 欧冠八分之一决赛抽签场景</div><div class="line">        concat  Concatenate files. *</div><div class="line">       default  Alias for "hello", "football", "concat" tasks.</div><div class="line">    customTask  Alias for "hello", "football" tasks.</div></pre></td></tr></table></figure><p><strong>任务依赖</strong></p><p>在复杂的Grunt工作流程中，很多任务之间往往存在依赖关系，比如js代码的语法检查和压缩这两个任务，压缩任务需要依赖于语法检查任务，它们在执行的时候存在一定的先后关系，这种情况我们称之为任务依赖。</p><p>我们可以在注册任务的时候，刻意指定这种依赖关系，他们更多的是以一种特定的先后顺序执行。<span style="color:red">如果是自定义任务，也可以通过grunt.task.requires()方法来设定这种任务间的依赖关系。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//注册两个自定义任务</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * 第一个参数:Task的名称</span></div><div class="line"><span class="comment">    * 第二个参数:任务的描述信息</span></div><div class="line"><span class="comment">    * */</span></div><div class="line">    grunt.registerTask(<span class="string">"hi"</span>,<span class="string">"描述信息:这是一个打招呼的任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.ok(<span class="string">"hi 文顶顶"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    grunt.registerTask(<span class="string">"hello"</span>,<span class="string">"任务的描述次信息:这是一个简单问候任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">//设置任务依赖：表明当前的任务在执行的时候需要依赖于另外一个任务</span></div><div class="line">        <span class="comment">//必须先执行hi这个任务,才能执行hello这个任务</span></div><div class="line">        grunt.task.requires(<span class="string">"hi"</span>);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Nice to meet you!"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码中定义了hi和hello两个任务，其中hello这个Task需要依赖于hi的执行，如果直接执行hello，那么会打印任务依赖的提示信息，具体的执行情况如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello</div><div class="line">Running "hello" task</div><div class="line">Warning: Required task "hi" must be run first. Use --force to continue.</div><div class="line"></div><div class="line">Aborted due to warnings.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hi hello</div><div class="line">Running "hi" task</div><div class="line">&gt;&gt; hi 文顶顶</div><div class="line"></div><div class="line">Running "hello" task</div><div class="line">Nice to meet you!</div><div class="line">Done.</div></pre></td></tr></table></figure></p><h3 id="3-3-Grunt多目标任务和Options选项"><a href="#3-3-Grunt多目标任务和Options选项" class="headerlink" title="3.3 Grunt多目标任务和Options选项"></a>3.3 Grunt多目标任务和Options选项</h3><p><strong>理解多目标Task</strong></p><p>Grunt中的多目标任务（multi-task）是相对于基本任务而言的，多目标任务几乎是Grunt中最复杂的概念。它的使用方式非常灵活，其设计的目的是可以在当个项目中支持多个Targets目标[<code>可以认为是多种配置</code>]。当任务在执行的时候，可以一次性执行全部的Target也可以指定某一特定的Target执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//(1) 配置Task，给Task设置多个Target</span></div><div class="line">    grunt.config(<span class="string">"hello"</span>,</div><div class="line">        &#123;</div><div class="line">            <span class="string">"targetA"</span>:&#123;</div><div class="line">                <span class="string">"des"</span>:<span class="string">"Nice to meet you!"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="string">"targetB"</span>:&#123;</div><div class="line">                <span class="string">"des"</span>:<span class="string">"how are you?"</span></div><div class="line">            &#125;,</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="comment">//(2) 自定义任务 任务的名称为hello</span></div><div class="line">    <span class="comment">//第一个参数：Task名称</span></div><div class="line">    <span class="comment">//第二个参数：任务的描述信息</span></div><div class="line">    <span class="comment">//第三个参数：具体要执行的任务</span></div><div class="line">   grunt.registerMultiTask(<span class="string">"hello"</span>,<span class="string">"描述信息:打招呼"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        grunt.log.ok(<span class="string">"hello 文顶顶"</span>);</div><div class="line">        grunt.log.writeln(<span class="string">"this.target:"</span>,<span class="keyword">this</span>.target);</div><div class="line">        grunt.log.writeln(<span class="string">"this.data:"</span>,<span class="keyword">this</span>.data);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>代码说明</strong></p><p>通过观察可以发现，我们通过<code>grunt.registerMultiTask方法</code>创建了支持多任务（Target）操作的自定义任务hello，主要任务就是输出<span style="color:#f22">“hello 文顶顶”</span>消息以及打印当前的target和data值。然后通过<code>grunt.config方法</code>来给hello这个Task设定了两个Target，分别是targetA和targetB。</p><p>在上面的代码中，我们引用了this.target和this.data这两个属性，<span style="color:#f22">回调函数中的this指向的是当前正在运行的目标对象。</span>执行targetA这个选项的时候，打印的this对象如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">nameArgs</span>: <span class="string">'hello:targetA'</span>,</div><div class="line">  name: <span class="string">'hello'</span>,</div><div class="line">  args: [],</div><div class="line">  flags: &#123;&#125;,</div><div class="line">  <span class="keyword">async</span>: [<span class="built_in">Function</span>],</div><div class="line">  errorCount: [Getter],</div><div class="line">  requires: [<span class="built_in">Function</span>: bound ],</div><div class="line">  requiresConfig: [<span class="built_in">Function</span>],</div><div class="line">  options: [<span class="built_in">Function</span>],</div><div class="line">  target: <span class="string">'targetA'</span>,</div><div class="line">  data: &#123; <span class="attr">des</span>: <span class="string">'Nice to meet you!'</span> &#125;,</div><div class="line">  files: [],</div><div class="line">  filesSrc: [Getter] &#125;</div></pre></td></tr></table></figure></p><p>目前为止，我们一直在谈论Task（任务）和Target（目标），大家可能懵逼了，不禁要问<code>它们之间到底是什么关系？</code></p><p>私以为可以简单的类比一下，假设现在有一个任务就是中午吃大餐，而具体吃什么大餐，可以灵活安排多个方案进行选择，比如方案A吃西餐，方案B吃中餐，方案C吃日本料理。等我们真正到了餐馆要开吃的时候，可以选择方案A吃西餐或者是方案B吃中餐，甚至中餐、西餐和日本料理全端上桌也未尝不可。</p><p><span style="color:#f22">Task指的是整个任务，在这个例子中就是要吃大餐，Target指的是任务中的某一种可行方案，也就是方案A、方案B和方案C，吃大餐这个Task中我们配置了三个Target。定义任务的目的是为了执行，在执行Task的时候，我们可以选择执行某个或某几个指定的Target(目标)，这样的处理方式无疑更强大而且操作起来更加的灵活。</span></p><p><strong>多目标任务的执行</strong></p><p>运行多目标Task的时候，有多种方式选择。</p><p>① 让Task按照指定的target运行。<code>$ grunt TaskName:targetName</code></p><p>② 让Task把所有的target都运行一次。<code>$ grunt TaskName</code></p><p>下面列出示例代码的具体执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello</div><div class="line">Running "hello:targetA" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetA</div><div class="line">this.data: &#123; des: 'Nice to meet you!' &#125;</div><div class="line"></div><div class="line">Running "hello:targetB" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetB</div><div class="line">this.data: &#123; des: 'how are you?' &#125;</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello:targetA</div><div class="line">Running "hello:targetA" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetA</div><div class="line">this.data: &#123; des: 'Nice to meet you!' &#125;</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:05-Grunt项目任务的描述和依赖 wendingding$ grunt hello:targetB</div><div class="line">Running "hello:targetB" (hello) task</div><div class="line">&gt;&gt; hello 文顶顶</div><div class="line">this.target: targetB</div><div class="line">this.data: &#123; des: 'how are you?' &#125;</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><div class="tip">如果在Gruntfile文件中，调用了<code>grunt.registerTask方法</code>来注册自定义任务，那么可以通过<code>TaskName:targetName</code>的来方式直接指定任务的Target</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注册任务 [给hello起一个别名]</span></div><div class="line"> grunt.registerTask(<span class="string">"helloTargetA"</span>,[<span class="string">"hello:targetA"</span>]);</div></pre></td></tr></table></figure><p>在终端中，输入<code>$ grunt helloTargetA</code>命令将会执行hello这个Task中的targetA选项。</p><p><strong>多目标任务的Options选项</strong></p><p>在对多目标的任务进行配置的时候，任何存储在options选项下面的数据都会被特殊的处理。</p><p>下面列出一份Gruntfile文件中的核心代码，并以多种方式执行，通过这份代码能够帮助我们理解多目标任务的Options选项配置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//(1) 配置Task相关信息</span></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * 第一个参数:Task的名称</span></div><div class="line"><span class="comment">    * 第二个参数:任务的描述信息</span></div><div class="line"><span class="comment">    * */</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">       <span class="string">"hi"</span>: &#123;</div><div class="line">           <span class="comment">/*对整个任务中所有target的配置项 全局配置*/</span></div><div class="line">           options:&#123;</div><div class="line">               <span class="string">"outPut"</span>:<span class="string">"array"</span></div><div class="line">           &#125;,</div><div class="line">           targetA:&#123;</div><div class="line">               arrM:[<span class="string">"targetA_1"</span>,<span class="string">"targetA_2"</span>,<span class="string">"targetA_3"</span>]</div><div class="line">           &#125;,</div><div class="line">           targetB:&#123;</div><div class="line">               options:&#123;</div><div class="line">                   <span class="string">"outPut"</span>:<span class="string">"json"</span></div><div class="line">               &#125;,</div><div class="line">               arrM:[<span class="string">"targetB_1"</span>,<span class="string">"targetB_2"</span>,<span class="string">"targetB_3"</span>]</div><div class="line">           &#125;,</div><div class="line">           targetC:&#123;</div><div class="line">               arrM:[<span class="string">"targetC_1"</span>,<span class="string">"targetC_2"</span>,<span class="string">"targetC_3"</span>]</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2) 自定义任务 Task名称为hi</span></div><div class="line">    <span class="comment">//第一个参数：Task名称</span></div><div class="line">    <span class="comment">//第二个参数：任务的描述信息</span></div><div class="line">    <span class="comment">//第三个参数：具体要执行的任务</span></div><div class="line">    grunt.registerMultiTask(<span class="string">"hi"</span>,<span class="string">"描述次信息:这是一个打招呼的任务"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"任务当前执行的target: "</span>+<span class="keyword">this</span>.target);</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"任务当前执行的target对应的数据: \n"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> objT = <span class="keyword">this</span>.options();</div><div class="line">        <span class="keyword">if</span> (objT.outPut === <span class="string">"array"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"输出数组:\n"</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.data.arrM);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (objT.outPut === <span class="string">"json"</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"输出JSON数据:\n"</span>);</div><div class="line">            <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.data.arrM));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(1) 相关的概念 Task(任务-hi) | target(目标)</span></div><div class="line">    <span class="comment">//(2) 任务的配置:任务中可以配置一个或者是多个目标  调用config</span></div><div class="line">    <span class="comment">//(3) 复合任务的执行(多任务-多target)</span></div><div class="line">    <span class="comment">//   001 grunt TaskName 把当前Task下面所有的目标操作都执行一遍</span></div><div class="line">    <span class="comment">//   002 grunt TaskName:targetName 执行当前Task下面的某一个指定的目标</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"hi"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">wendingding:06-Grunt项目多任务和options wendingding$ grunt</div><div class="line">Running "hi:targetA" (hi) task</div><div class="line">任务当前执行的target: targetA</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出数组:</div><div class="line">[ 'targetA_1', 'targetA_2', 'targetA_3' ]</div><div class="line"></div><div class="line">Running "hi:targetB" (hi) task</div><div class="line">任务当前执行的target: targetB</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出JSON数据:</div><div class="line">["targetB_1","targetB_2","targetB_3"]</div><div class="line"></div><div class="line">Running "hi:targetC" (hi) task</div><div class="line">任务当前执行的target: targetC</div><div class="line">任务当前执行的target对应的数据:</div><div class="line"></div><div class="line">输出数组:</div><div class="line">[ 'targetC_1', 'targetC_2', 'targetC_3' ]</div><div class="line"></div><div class="line">Done</div></pre></td></tr></table></figure></p><p><strong>代码说明</strong></p><p>上面的代码中定义了一个多目标任务，Task的名称为<code>hi</code>，该Task有三个target目标选项，分别是<code>targetA、targetB和targetC</code>。在任务配置相关代码中，全局的options配置项中outPut属性对应的值为array，表示具体的目标任务在执行的时候以数组的形式输出。</p><p>我们看到在targetB目标中重写了options选项中的outPut属性为json，当终端执行<code>$ grunt</code>命令的时候，会依次执行所有三个target目标选项，而targetA和targetC以数组格式来输出内容，targetB则以json格式来输出内容。</p><p><span style="color:#f25">Grunt多目标任务以及选项使得我们可以针对不同的应用环境，以不同的方式来运行同一个Task。可以利用这一点，我们完全能够定义Task为不同的构建环境创建不同的输出目标。</span></p><div class="tip">说明 ✧ <code>this.options()方法</code>用于获取当前正在执行的目标Task的options配置选项</div><h3 id="3-4-Grunt项目任务配置模板"><a href="#3-4-Grunt项目任务配置模板" class="headerlink" title="3.4 Grunt项目任务配置模板"></a>3.4 Grunt项目任务配置模板</h3><p><strong>Grunt项目中配置模板的简单使用</strong></p><p>在Grunt项目中，我们可以使用<code>&lt;% %&gt;</code>分隔符的方式来指定模板，当Task读取自己配置信息的时候模板的具体内容会自动扩展，且支持以递归的方式展开。</p><p>在通过<code>&lt;%= ... %&gt;</code>在向模板绑定数据的时候，我们可以直接传递配置对象中的属性或调用grunt提供的方法，<span style="color:red">模板中属性的上下文就是当前的配置对象</span>。</p><p>下面，我们通过Gruntfile文件中的一段核心代码来展现配置模板的使用情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">//(1) 创建并设置grunt的配置对象</span></div><div class="line">    <span class="comment">//配置对象：该对象将作为参数传递给grunt.config.init方法</span></div><div class="line">    <span class="keyword">var</span> configObj = &#123;</div><div class="line">        concat: &#123;</div><div class="line">            target: &#123;</div><div class="line">              <span class="comment">//src:["src/demo1.js","src/demo2.js"]</span></div><div class="line">                src: [<span class="string">'&lt;%= srcPath %&gt;demo1.js'</span>, <span class="string">'&lt;%= srcPath %&gt;demo2.js'</span>],</div><div class="line">              <span class="comment">//dest:["dist/2018_05_21_index.js"]</span></div><div class="line">                dest: <span class="string">'&lt;%= targetPath %&gt;'</span>,</div><div class="line">            &#125;,</div><div class="line">        &#125;,</div><div class="line">        srcPath:<span class="string">"src/"</span>,</div><div class="line">        destPath:<span class="string">"dist/"</span>,</div><div class="line">        targetPath:<span class="string">"&lt;%= destPath %&gt;&lt;%= grunt.template.today('yyyy_mm_dd_') %&gt;index.js"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//(2) 调用init方法对任务(Task)进行配置</span></div><div class="line">    <span class="comment">// grunt.config.init 方法 === grunt.initConfig方法</span></div><div class="line">    grunt.config.init(configObj);</div><div class="line"></div><div class="line">    <span class="comment">//(3) 加载concat插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//(4) 注册Task</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上面这段代码对concat插件代码合并Task进行了配置，使用到了模板技术。该任务把src目录下的demo1和demo2两个js文件合并到dist目录下并命名为2018_05_21_index.js文件。</p><p><strong>Grunt项目中导入外部的数据</strong></p><p>在向模板绑定数据的时候，常见的做法还会导入外部的数据，并把导入的数据设置为配置对象的指定属性值。比如在开发中常常需要用到当前Grunt项目的元信息，包括名称、版本等，这些数据常通过调用<code>grunt.file.readJSON方法</code>加载package.json文件的方式获取。下面给出代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//设置(demoTask和concat)Task的配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        <span class="comment">//从package.json文件中读取项目的元(基本)信息</span></div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//demoTask的配置信息</span></div><div class="line">        demoTask :&#123;</div><div class="line">           banner:<span class="string">"&lt;%=pkg.name%&gt; -- &lt;%=pkg.version%&gt;"</span></div><div class="line">       &#125;,</div><div class="line">        <span class="comment">//concat的配置信息</span></div><div class="line">        concat:&#123;</div><div class="line">           options:&#123;</div><div class="line">               stripBanners:<span class="literal">true</span>,</div><div class="line">               banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt; 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">           &#125;,</div><div class="line">           target:&#123;</div><div class="line">               src:[<span class="string">"src/demo1.js"</span>,<span class="string">"src/demo2.js"</span>],</div><div class="line">               dest:<span class="string">'dist/index.js'</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//自定义Task 任务的名称为demoTask</span></div><div class="line">    grunt.registerMultiTask(<span class="string">"demoTask"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"执行demo任务"</span>);</div><div class="line">        <span class="comment">//表示调用config方法来读取demoTask里面的banner属性并输出</span></div><div class="line">        <span class="built_in">console</span>.log(grunt.config(<span class="string">"demoTask.banner"</span>));</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//从node_modules目录中加载concat插件</span></div><div class="line">    <span class="comment">//注意：需要先把插件下载到本地  npm install grunt-contrib-concat --save-dev</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"demoTask"</span>,<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>如果在终端输入<code>$ grunt</code>命令执行，那么demoTask任务将会输出<code>grunt_demo -- 1.0.0</code>打印消息，而concat任务则把两个js文件合并到dist目录下面的index.js文件并添加注释信息。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">wendingding$ grunt</div><div class="line">Running "demoTask:banner" (demoTask) task</div><div class="line">执行demo任务</div><div class="line">grunt_demo -- 1.0.0</div><div class="line"></div><div class="line">Running "concat:target" (concat) task</div><div class="line"></div><div class="line">Done.</div><div class="line">wendingding:07-Grunt项目模板配置 wendingding$ cat dist/index.js</div><div class="line">/*项目名称：grunt_demo 项目版本：1.0.0 项目的作者：文顶顶 更新时间：2018-05-21*/</div><div class="line">console.log("demo1");</div><div class="line">console.log("demo2");</div></pre></td></tr></table></figure></p><div class="tip"><br><strong>说明</strong> &nbsp;grunt.file.readJSON方法用于加载JSON数据，grunt.file.readYAML方法用于加载<a href="http://yaml.org/" target="_blank" rel="external">YAML</a>数据。</div><h3 id="3-5-Grunt自动化构建和监听"><a href="#3-5-Grunt自动化构建和监听" class="headerlink" title="3.5 Grunt自动化构建和监听"></a>3.5 Grunt自动化构建和监听</h3><p>到这里，基本上就可以说已经熟练掌握Grunt了。上文我们在进行代码演示的时候，不论是自定义任务还是Grunt插件使用的讲解都是片段性的，支离破碎的，Grunt作为一款自动化构建工具，<code>自动化</code>这三个字到现在还没有体现出来。</p><p>顾名思义，<span style="color:#f25">自动化构建的意思就是能够监听项目中指定的文件，当这些文件发生改变后自动的来执行某些特定的任务。</span> 否则的话，每次修改文件后，都需要我们在终端里面输入对应的命令来重新执行，这顶多能算<code>半自动化</code>是远远不够的。</p><p>下面给出一份更全面些的Gruntfile文件，该文件中使用了几款常用的Grunt插件(uglify、cssmin、concat等)来搭建自动化构建项目的工作流。<a href="https://github.com/flowerField/ex.git" target="_blank" rel="external">点击获取演示代码</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line">    <span class="comment">// 项目配置信息</span></div><div class="line">    grunt.config.init(&#123;</div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//代码合并</span></div><div class="line">        concat:&#123;</div><div class="line">            options:&#123;</div><div class="line">                stripBanners:<span class="literal">true</span>,</div><div class="line">             banner:<span class="string">'/*项目名称：&lt;%=pkg.name%&gt; 项目版本：&lt;%=pkg.version%&gt; 项目的作者：&lt;%=pkg.author%&gt;'</span></div><div class="line">             +<span class="string">' 更新时间：&lt;%=grunt.template.today("yyyy-mm-dd")%&gt;*/\n'</span></div><div class="line">            &#125;,</div><div class="line">            target:&#123;</div><div class="line">                src:[<span class="string">"src/demo1.js"</span>,<span class="string">"src/demo2.js"</span>],</div><div class="line">                dest:<span class="string">'dist/index.js'</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js代码压缩</span></div><div class="line">        uglify:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"dist/index.js"</span>,</div><div class="line">                dest:<span class="string">"dist/index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//css代码压缩</span></div><div class="line">        cssmin:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:<span class="string">"src/index.css"</span>,</div><div class="line">                dest:<span class="string">"dist/index.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//js语法检查</span></div><div class="line">        jshint:&#123;</div><div class="line">            target:[<span class="string">'Gruntfile.js'</span>,<span class="string">"dist/index.js"</span>],</div><div class="line">            options:&#123;</div><div class="line">                jshintrc:<span class="string">".jshintrc"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="comment">//监听 自动构建</span></div><div class="line">        watch:&#123;</div><div class="line">            target:&#123;</div><div class="line">                files:[<span class="string">"src/*.js"</span>,<span class="string">"src/*.css"</span>],</div><div class="line">                <span class="comment">//只要指定路径的文件(js和css)发生了变化，就自动执行tasks中列出的任务</span></div><div class="line">                tasks:[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//通过命令行安装插件（省略...）</span></div><div class="line">    <span class="comment">//从node_modules路径加载插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-jshint"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-watch"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//注册任务：在执行$ grunt命令的时候依次执行代码的合并|检查|压缩等任务并开启监听</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>,<span class="string">"watch"</span>])</div><div class="line">&#125;;</div></pre></td></tr></table></figure><blockquote><p><strong>当在终端输入<code>$ grunt</code>命令的时候，grunt会执行以下任务</strong></p><p>① &nbsp;合并src/demo1.js和src/demo2.js文件并命名为index.js保存到dist目录<br>② &nbsp;按照既定的规则对Gruntfile.js和index.js文件来进行语法检查<br>③ &nbsp;压缩index.js文件并命名为index.min.js保存在dist目录<br>④ &nbsp;压缩src/index.css文件并保存到dist/index.min.css<br>⑤ &nbsp;<span style="color:#f25">开启监听，如果src目录下面的js文件或css文件被更改则重新构建</span></p></blockquote><p>关于监听插件<code>grunt-contrib-watch</code>的更多用法建议查看<a href="https://www.npmjs.com/package/grunt-contrib-watch" target="_blank" rel="external">使用文档</a></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[03]-Grunt构建工具的运转机制</title>
    <link href="https://weibo.com/u/3800117445/2018/05/20/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B03%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E8%BF%90%E8%BD%AC%E6%9C%BA%E5%88%B6/"/>
    <id>https://weibo.com/u/3800117445/2018/05/20/前端工程化系列[03] Grunt构建工具的运转机制/</id>
    <published>2018-05-20T02:06:13.000Z</published>
    <updated>2018-05-20T23:47:20.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">前端工程化系列[02]-Grunt构建工具的基本使用</a>这篇文章中，已经对Grunt做了简单的介绍，此外，我们还知道了该如何来安装Grunt环境，以及使用一些常见的插件了，这篇文章主要介绍Grunt的核心组件和运转机制。</p></blockquote><p>Grunt是一套前端自动化构建工具，可以帮助我们简化开发中需要反复处理的任务，甚至可以实现自动构建等功能。</p><p>Grunt拥有数量庞大的插件，这些插件能够帮助我们处理开发中遇到的绝大多数构建任务，比如代码的预编译、压缩、代码检查、单元测试等。但为什么在终端输入Grunt相关命令，就能够执行对应的任务，Grunt到底是怎么运转的？这些知识对于深入研究Grunt非常重要,下面我们从Grunt运转的组件和运转机制两方面来展开讨论。</p><h3 id="2-1-Grunt的核心组件"><a href="#2-1-Grunt的核心组件" class="headerlink" title="2.1  Grunt的核心组件"></a>2.1  Grunt的核心组件</h3><p><strong><span style="color:#f25">node和npm</span></strong></p><p>Grunt项目基于Node.js，Grunt和相关的插件都通过 npm 安装并管理。</p><p><strong><span style="color:#f25">Grunt-cli</span></strong></p><p> <span style="color:#195">Grunt命令行用于调用与Gruntfile文件在同一目录中的 Grunt模块</span>，通过<code>-g</code>参数把Grunt命令行安装到全局环境中，这样的话在所有文件目录中都可以调用grunt相关的命令。</p><p>在命令行中运行Grunt 相关命令时(比如 <code>$grunt default</code>)，内部会根据node提供的require系统查找来当前目录中安装的 Grunt，如果找到那么加载，并把加载的grunt作为参数传递到Gruntfile文件中，然后执行指定的任务。</p><p><strong><span style="color:#f25">Task</span></strong></p><p>Task就是任务的意思，grunt支持自定义任务，也支持使用现成的插件任务。比如向控制台输出一句问候这可以被认为是一个Task，对所有的js文件进行压缩这也是一个Task，通常任务(Task)都是可配置的。</p><p><strong><span style="color:#f25">Grunt本地依赖</span></strong></p><p>安装了grunt命令行不等于就安装了grunt，这只是让我们拥有了在命令行中使用grunt相关命令的能力，对于每个需要使用grunt的工程，仍然需要为其配置grunt本地依赖。</p><p><strong><span style="color:#f25">Grunt插件(Plugins)</span></strong></p><p><span style="color:#195">Grunt插件是一系列能够用于不同项目的可配置任务的集合。</span>Grunt插件通常以npm包的形式发布。<a href="https://gruntjs.com/plugins" target="_blank" rel="external">Grunt官网的插件列表</a>列出了所有可用的Grunt插件，截止当前的插件数量为6,393个，其中带有contrib前缀的插件由Grunt官方开发和维护。</p><p><strong><span style="color:#f25">package.json文件</span></strong></p><p><span style="color:#195">package.json文件用于被npm存储项目的元数据，以便将此项目发布为npm模块。</span>我们可以在此文件中列出项目依赖的Grunt和Grunt插件，保存在devDependencies（开发依赖）配置字段内，我们可以通过<code>$ npm install</code>命令来加载该文件中的所有依赖项。</p><p><strong><span style="color:#f25">Gruntfile.js文件</span></strong></p><p>Gruntfile文件是Grunt项目中最核心的文件，该文件同package.json文件一起存放在项目的根目录中，主要用来配置或定义任务（task）并加载Grunt插件。标准的grunt项目中必须拥有package.json和Gruntfile这两个文件。</p><p><strong><span style="color:#f25">node_modules文件夹</span></strong></p><p>node_modules文件目录存放着从远程仓库下载的grunt以及所有相关的grunt插件。</p><h3 id="2-2-Grunt的运转机制"><a href="#2-2-Grunt的运转机制" class="headerlink" title="2.2 Grunt的运转机制"></a>2.2 Grunt的运转机制</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt_02.png?raw=true"></p><p>上面给出了Grunt项目中各主要组件的关系图示，是根据个人的理解绘制的，所以可能并非完全准确，但基本上已经能够说清楚Grunt的运转机制了。</p><p>我们在使用Grunt作为项目构建工具的时候，所做的事情大概可以分成三块：准备、配置、执行。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 准备阶段&nbsp; &nbsp;</strong></span></p><p>准备阶段主要进行以下操作</p><blockquote><p>❏ &nbsp;node环境的安装、npm的安装(在安装node的时候默认安装)</p><p>❏ &nbsp;grunt-cli命令行的安装(通过<code>$ npm install -g grunt-cli</code>命令)</p><p>❏ &nbsp;创建package.json文件(手动创建或通过<code>$ npm init</code>命令交互式创建)</p><p>❏ &nbsp;配置grunt本地依赖(通过<code>$ npm install grunt --save-dev</code>下载grunt到项目)</p><p>❏ &nbsp;安装需要的grunt插件(通过<code>$ npm install grunt-contrib-xx --save-dev</code>命令把需要的插件下载到node_modules目录)</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 配置阶段&nbsp; &nbsp;</strong></span></p><p>配置阶段主要就是<span style="color:#f25">创建和编辑Gruntfile文件，在该文件中接收grunt参数并配置Task，注册Task。</span>Task简单说就是任务的意思，我们可以自定义任务，也可以直接使用现成的、一些其他优秀开发者定义好并打包为node模块发布的任务（其实就是grunt插件）。</p><p>一般来说，我们总是通过grunt为我们提供的<code>grunt.initConfig</code>方法来对Task(插件)进行配置，如果是该Task是Grunt插件那么还需要先从node_modules目录中加载。</p><p>如果对多个Task的执行有指定的顺序或者依赖关系，那么我们可以通过<code>grunt.registerTask</code>方法来<code>注册Task</code>。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 执行阶段&nbsp; &nbsp;</strong></span></p><p>在执行阶段，通过在命令行中输入<code>$ grunt task名称</code>的方式来执行指定的任务。</p><p>执行Task的时候，可以单个执行，例如：</p><p><code>$ grunt taskName1</code><br><code>$ grunt taskName2</code></p><p>也可以用单条命令执行多个Task，每个Task都将按照参数的传入顺序依次执行，例如：</p><p><code>$ grunt taskName1 taskName2</code></p><p>在使用构建工具的时候，这些Task具体怎么执行，执行的顺序等并非是固定不变的，需要结合特定的需求来特殊处理。如果总是有一组Task需要按顺序执行，一般可以使用grunt.registerTask方法来给这组Task设置个别名，这一组的Task以数组的形式传递。</p><p>例如：要依次执行js文件的合并、语法检查、代码压缩、css代码压缩等任务，则配置好相关Task后可以像下面这样来设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt.registerTask(<span class="string">"customTask"</span>,[<span class="string">"concat"</span>,<span class="string">"jshint"</span>,<span class="string">"uglify"</span>,<span class="string">"cssmin"</span>]);</div></pre></td></tr></table></figure><p>要执行这组任务的时候，直接执行<code>$ grunt customTask</code>命令即可。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97[02]%20Grunt%E6%9
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[02]-Grunt构建工具的基本使用</title>
    <link href="https://weibo.com/u/3800117445/2018/05/18/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B02%5D%20Grunt%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/05/18/前端工程化系列[02] Grunt构建工具的使用/</id>
    <published>2018-05-18T12:36:13.000Z</published>
    <updated>2018-05-20T23:47:20.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍前端开发中常用的构建工具Grunt，具体包括Grunt的基本情况、安装、使用和常见插件的安装、配置和使用等内容。</p></blockquote><h3 id="1-1-Grunt简单介绍"><a href="#1-1-Grunt简单介绍" class="headerlink" title="1.1 Grunt简单介绍"></a>1.1 Grunt简单介绍</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt.png?raw=true" height="300px"></p><p><span style="color:#f25">Grunt是一套前端自动化构建工具。</span>对于需要反复重复的任务（如压缩、编译、单元测试等），自动化构建工具可以减轻并简化我们的工作。我们只需要在 Gruntfile 文件中正确配置好要处理的任务，任务运行器就会自动帮我们完成大部分工作。</p><p><strong>Grunt的优点</strong></p><blockquote><p>❏  Grunt拥有庞大的生态系统，并且一直在增长。<br>❏  Grunt支持我们自己创作插件并发布。</p></blockquote><p>由于Grunt拥有数量庞大的插件，所以几乎任何的任务都可以利用Grunt来自动完成，你也可以根据自己项目的特点来创作合适的插件发布。</p><p><strong><span style="color:#f25">Grunt的工作方式</span></strong></p><p>Grunt为开发者提供了一个工具包，用于创建命令行程序来执行项目构建过程中的重复性任务，比如压缩js代码、编译Sass样式等。Grunt不仅仅能创建简单任务以解决特定工程遇到的特定需求，还能将任务打包为可复用的插件。这些插件可以被发布、分享，使用以及被其他人进行改进。</p><p>Grunt的运转依赖于四个核心的组件：分别是<span style="color:#f25">Gruntfile、Tasks 、Plugins以及任务配置。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① Gruntfile &nbsp; &nbsp;</strong></span></p><p>Gruntfile指的是在项目根目录下面名为Gruntfile.js的Node模块。该文件使得我们可以加载Grunt插件，创建自定义任务，并根据项目需求对它们进行配置。</p><p>Grunt每次运行时的首要任务都是接受该模块发出的指令。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② Tasks &nbsp; &nbsp;</strong></span></p><p>Tasks作为Grunt的基本构建模块，它实际上是由Grunt的registerTask（）方法注册的具名函数。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ Plugins &nbsp; &nbsp;</strong></span></p><p>Plugins是一系列能够用于不同项目的可配置任务的集合。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;④ 任务配置 &nbsp; &nbsp;</strong></span></p><p>Grunt强调配置优先，任务和插件的功能都可以通过配置文件进行定制，以适应不同工程的需求。这种代码和配置相分离的特性，使开发者能够创造出高复用的插件。</p><p><strong>相关参考</strong></p><p><strong>现在最新版本&nbsp;&nbsp;&nbsp;&nbsp;</strong>   <span style="color:#f25">v1.0.2</span><br><strong>其它构建工具&nbsp;&nbsp;&nbsp;&nbsp;</strong> <span style="color:#f25"> gulp、webpack、fis3等</span></p><p><a href="http://www.gruntjs.com" target="_blank" rel="external">Grunt官网</a><br><a href="http://www.gruntjs.net/" target="_blank" rel="external">Grunt官网(中文)</a><br><a href="http://www.gruntjs.net/plugins" target="_blank" rel="external">Grunt相关的插件列表</a></p><h3 id="1-2-Grunt的安装"><a href="#1-2-Grunt的安装" class="headerlink" title="1.2 Grunt的安装"></a>1.2 Grunt的安装</h3><p>Grunt和相关的插件都通过 npm 安装并管理。</p><p>Grunt基于Node.js，安装之前要先安装Node.js。</p><blockquote><p><strong>Node.js的安装</strong></p><p>① 打开<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>找到Download选项，选择对应的版本下载。<br>② 下载之后，根据对应的提示进行安装即可。<br>③ 安装完成之后，可以通过<code>$ node --version</code>和<code>$ npm --version</code>命令查看是否安装成功。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ node --version</div><div class="line">v8.9.3</div><div class="line">wendingding:~ wendingding$ npm --version</div><div class="line">5.5.1</div><div class="line">wendingding:~ wendingding$</div></pre></td></tr></table></figure><p><strong>安装注意点</strong></p><p>❗ ️Grunt依赖于nodejs的v0.8.0及以上版本；<br>❗ ️奇数版本号的 Node.js 被认为是不稳定的开发版；<br>❗️  需确保当前环境中所安装的 npm 已经是最新版本（<code>$ npm update -g npm</code>）</p><p><strong><span style="color:#f25">安装Grunt命令行</span></strong></p><p><strong>注意</strong> 在使用Grunt之前，需要先安装Grunt命令行到全局环境中。</p><p>安装命令：<code>$ npm install -g grunt-cli</code></p><p>安装完之后，可以通过<code>$ grunt</code>命令来验证Grunt命令行是否安装完成并生效，命令行中的<code>-g</code>表示全局安装。</p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ npm install -g grunt-cli</div><div class="line">/usr/local/bin/grunt -&gt; /usr/local/lib/node_modules/grunt-cli/bin/grunt</div><div class="line">+ grunt-cli@1.2.0</div><div class="line">added 16 packages in 9.289s</div><div class="line">wendingding:~ wendingding$ grunt</div><div class="line">grunt-cli: The grunt command line interface (v1.2.0)</div><div class="line"></div><div class="line">Fatal error: Unable to find local grunt.</div><div class="line"></div><div class="line">If you're seeing this message, grunt hasn't been installed locally to</div><div class="line">your project. For more information about installing and configuring grunt,</div><div class="line">please see the Getting Started guide:</div><div class="line"></div><div class="line">http://gruntjs.com/getting-started</div></pre></td></tr></table></figure></p><p><strong>Grunt命令行的作用</strong></p><p><code>Grunt命令行用于调用与Gruntfile在同一目录中 Grunt</code>。每次运行Grunt 时，都会根据node提供的require()系统查找本地安装的 Grunt（<code>因此我们可以在项目的任意子目录中运行grunt</code>） ，如果找到一份本地安装的 Grunt，命令行就将其加载，并传递Gruntfile中的配置信息，然后执行指定的任务。</p><h3 id="1-3-Grunt的安装和使用"><a href="#1-3-Grunt的安装和使用" class="headerlink" title="1.3 Grunt的安装和使用"></a>1.3 Grunt的安装和使用</h3><h4 id="1-3-1-Grunt使用的基本步骤"><a href="#1-3-1-Grunt使用的基本步骤" class="headerlink" title="1.3.1 Grunt使用的基本步骤"></a>1.3.1 Grunt使用的基本步骤</h4><blockquote><p><strong><span style="color:#f25">Grunt使用的基本步骤</span></strong></p><p>① &nbsp;生成package.json和Gruntfile.js文件<br>② &nbsp;命令行安装项目中需要用到的插件<br>③ &nbsp;编辑Gruntfile文件定义Task并进行配置<br>④ &nbsp;命令行以grunt task的方式执行任务</p></blockquote><h4 id="1-3-2-Grunt的安装"><a href="#1-3-2-Grunt的安装" class="headerlink" title="1.3.2 Grunt的安装"></a>1.3.2 Grunt的安装</h4><p>接下来，我们通过一个完整的Grunt案例来介绍Grunt的常规使用方法。首先创建的对应的项目文件目录，这里命名为Grunt_demo文件夹，然后创建<code>package.json文件</code>和<code>Gruntfile.js文件</code>并进行相关配置,安装相应的插件并执行Task。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 创建package.json文件&nbsp; &nbsp;</strong></span></p><p>创建package.json文件有两种方式，一种是直接创建然后以json格式的字段来进行配置，第二种是通过执行npm install来创建，推荐通过命令行的方式来创建。</p><p><strong> ✧ 直接创建package.json文件 ✧ </strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wendingding:~ wendingding$ mkdir Grunt_Demo</div><div class="line">wendingding:~ wendingding$ cd Grunt_Demo/</div><div class="line">wendingding:Grunt_Demo wendingding$ PWD</div><div class="line">/Users/文顶顶/Grunt_Demo</div><div class="line">wendingding:Grunt_Demo wendingding$ touch package.json</div><div class="line">wendingding:Grunt_Demo wendingding$ open package.json</div></pre></td></tr></table></figure><p>命令行说明</p><p><code>$ mkdir Grunt_Demo</code> 表示创建文件夹<br><code>$ cd Grunt_Demo/</code>    表示进入文件目录<br><code>$ PWD</code>              表示查看当前路径<br><code>$ touch package.json</code> 表示创建package.json文件<br><code>$ open package.json</code> 表示使用记事本打开文件并编辑</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ open package.json</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">"name":"Grunt_Demo",</div><div class="line">"version":"1.0.0",</div><div class="line">"dependencies":&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>$ cat package.json</code> 表示查看文件内容</p><p>创建好package.json文件后，可以根据需要添加内容字段到文件中。该json文件中最基本字段主要有<span style="color:#195">name、version和dependencies</span>，其中name和version对应的是Grunt项目的名称和版本，而dependencies字段中则列出该项目的依赖。</p><p><span style="color:#f25">package.json文件用于被npm存储项目的元数据，以便将此项目发布为npm模块。我们可以在此文件中列出项目依赖的Grunt和Grunt插件，保存在devDependencies（开发依赖）配置段内。</span></p><p><strong> ✧ 初始化命令创建package.json文件 ✧ </strong></p><p>除手动创建外，我们还能够通过命令行来进行初始化操作，会以交互的方式来生成一个包含基本配置信息的package.json文件。</p><p>初始化命令：<code>$ npm init</code></p><p>下面列出具体的命令行执行情况</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm init</div><div class="line">This utility will walk you through creating a package.json file.</div><div class="line">It only covers the most common items, and tries to guess sensible defaults.</div><div class="line"></div><div class="line">See `npm help json` for definitive documentation on these fields</div><div class="line">and exactly what they do.</div><div class="line"></div><div class="line">Use `npm install <span class="tag">&lt;<span class="name">pkg</span>&gt;</span>` afterwards to install a package and</div><div class="line">save it as a dependency in the package.json file.</div><div class="line"></div><div class="line">Press ^C at any time to quit.</div><div class="line">package name: (grunt_demo)</div><div class="line">version: (1.0.0)</div><div class="line">description:</div><div class="line">entry point: (index.js)</div><div class="line">test command:</div><div class="line">git repository:</div><div class="line">keywords:</div><div class="line">author:</div><div class="line">license: (ISC)</div><div class="line">About to write to /Users/文顶顶/Grunt_Demo/package.json:</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC"</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Is this ok? (yes) yes</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC"</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在执行<code>npm init</code>命令创建基本package.json文件的时候，可以设置名称、版本、依赖等选项，如果不设置直接回车表示以默认(建议)的方式来进行配置。</p><pre class="tip"><strong>package.json文件注意点</strong><br>❐ package.json应当放置于项目的根目录中，并同项目源代码一起管理。<br>❐ 如果在根目录中运行npm install命令，那么将依据package.json列出的依赖项来自动安装适当版本的依赖。</pre><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 创建Gruntfile文件&nbsp; &nbsp;</strong></span></p><p>Gruntfile文件是Grunt项目中最核心的文件，可以被命名为 Gruntfile.js 或者是Gruntfile.coffee，该文件同package.json文件一起存放在项目的根目录中，主要<code>用来配置或定义任务（task）并加载Grunt插件</code>。</p><p>标准的grunt项目中必须拥有package.json和Gruntfile这两个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ touch Gruntfile.js</div><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 2</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">└── package.json</div><div class="line"></div><div class="line">0 directories, 2 files</div></pre></td></tr></table></figure><p><code>$ tree -L 2</code> 表示以树状图的方式列出当前目录下面的二级文件结构，具体使用可以参考<a href="http://wendingding.com/2018/04/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20Mac%E7%B3%BB%E7%BB%9F%E4%B8%ADTree%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">网络编程系列 Mac系统中Tree的使用</a></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 安装Grunt &nbsp; &nbsp;</strong></span></p><p>在创建Grunt项目的过程中，我们可以通过<code>$ npm install &lt;module&gt; --save-dev</code>模式的命令来安装Grunt和Grunt插件。该命令在安装<module>的同时，会自动将其添加到package.json文件的devDependencies 配置段中。</module></p><p>接下来我们演示安装Grunt最新版本到项目目录中，并将其添加到devDependencies内。</p><p>命令行：<code>$ npm install grunt --save-dev</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm install grunt --save-dev</div><div class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</div><div class="line">npm WARN grunt_demo@1.0.0 No description</div><div class="line">npm WARN grunt_demo@1.0.0 No repository field.</div><div class="line"></div><div class="line">+ grunt@1.0.2</div><div class="line">added 94 packages in 33.833s</div></pre></td></tr></table></figure><p>命令行执行完毕之后，会发现package.json的配置段中信息发生了变更，在devDependencies配置项中增加了grunt字段和对应的版本信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;grunt_demo&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;&quot;,</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;grunt&quot;: &quot;^1.0.2&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>项目的根目录中增加了node_modules文件中，该目录列出了必要的依赖文件，下面给出文件结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 2</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── node_modules</div><div class="line">│   ├── abbrev</div><div class="line">│   ├── ansi-regex</div><div class="line">│   ├── ansi-styles</div><div class="line">│   ├── argparse</div><div class="line">│   ├── array-find-index</div><div class="line">│   ├── async</div><div class="line">│   ├── balanced-match</div><div class="line">│   ├── brace-expansion</div><div class="line">│   ├── builtin-modules</div><div class="line">│   ├── camelcase</div><div class="line">│   ├── camelcase-keys</div><div class="line">│   ├── chalk</div><div class="line">│   ├── coffeescript</div><div class="line">│   ├── colors</div><div class="line">│   ├── concat-map</div><div class="line">│   ├── currently-unhandled</div><div class="line">│   ├── dateformat</div><div class="line">│   ├── decamelize</div><div class="line">│   ├── error-ex</div><div class="line">│   ├── escape-string-regexp</div><div class="line">│   ├── esprima</div><div class="line">│   ├── eventemitter2</div><div class="line">│   ├── exit</div><div class="line">│   ├── find-up</div><div class="line">│   ├── findup-sync</div><div class="line">│   ├── fs.realpath</div><div class="line">│   ├── get-stdin</div><div class="line">│   ├── getobject</div><div class="line">│   ├── glob</div><div class="line">│   ├── graceful-fs</div><div class="line">│   ├── grunt</div><div class="line">│   ├── grunt-known-options</div><div class="line">│   ├── grunt-legacy-log</div><div class="line">│   ├── grunt-legacy-log-utils</div><div class="line">│   ├── grunt-legacy-util</div><div class="line">│   ├── has-ansi</div><div class="line">│   ├── hooker</div><div class="line">│   ├── hosted-git-info</div><div class="line">│   ├── iconv-lite</div><div class="line">│   ├── indent-string</div><div class="line">│   ├── inflight</div><div class="line">│   ├── inherits</div><div class="line">│   ├── is-arrayish</div><div class="line">│   ├── is-builtin-module</div><div class="line">│   ├── is-finite</div><div class="line">│   ├── is-utf8</div><div class="line">│   ├── isexe</div><div class="line">│   ├── js-yaml</div><div class="line">│   ├── load-json-file</div><div class="line">│   ├── lodash</div><div class="line">│   ├── loud-rejection</div><div class="line">│   ├── map-obj</div><div class="line">│   ├── meow</div><div class="line">│   ├── minimatch</div><div class="line">│   ├── minimist</div><div class="line">│   ├── nopt</div><div class="line">│   ├── normalize-package-data</div><div class="line">│   ├── number-is-nan</div><div class="line">│   ├── object-assign</div><div class="line">│   ├── once</div><div class="line">│   ├── parse-json</div><div class="line">│   ├── path-exists</div><div class="line">│   ├── path-is-absolute</div><div class="line">│   ├── path-type</div><div class="line">│   ├── pify</div><div class="line">│   ├── pinkie</div><div class="line">│   ├── pinkie-promise</div><div class="line">│   ├── read-pkg</div><div class="line">│   ├── read-pkg-up</div><div class="line">│   ├── redent</div><div class="line">│   ├── repeating</div><div class="line">│   ├── resolve</div><div class="line">│   ├── rimraf</div><div class="line">│   ├── safer-buffer</div><div class="line">│   ├── semver</div><div class="line">│   ├── signal-exit</div><div class="line">│   ├── spdx-correct</div><div class="line">│   ├── spdx-exceptions</div><div class="line">│   ├── spdx-expression-parse</div><div class="line">│   ├── spdx-license-ids</div><div class="line">│   ├── sprintf-js</div><div class="line">│   ├── strip-ansi</div><div class="line">│   ├── strip-bom</div><div class="line">│   ├── strip-indent</div><div class="line">│   ├── supports-color</div><div class="line">│   ├── trim-newlines</div><div class="line">│   ├── underscore.string</div><div class="line">│   ├── validate-npm-package-license</div><div class="line">│   ├── which</div><div class="line">│   └── wrappy</div><div class="line">├── package-lock.json</div><div class="line">└── package.json</div><div class="line"></div><div class="line">91 directories, 3 files</div></pre></td></tr></table></figure><p>至此，Grunt项目的基本配置以及Grunt的安装已经完成，在开发中使用Grunt主要是用Grunt相关的一些插件来实现特定的功能。Grunt的生态中提供了非常丰富的插件，我们可以直接在官方搜索查看，接下来给大家介绍几个在前端项目构建中常用到的插件。</p><h4 id="1-3-3-Grunt插件的安装和使用"><a href="#1-3-3-Grunt插件的安装和使用" class="headerlink" title="1.3.3 Grunt插件的安装和使用"></a>1.3.3 Grunt插件的安装和使用</h4><p><strong> ✧ <span style="color:#195">文件合并插件concat的安装和使用 </span>✧ </strong></p><p>concat插件的地址：<a href="https://github.com/gruntjs/grunt-contrib-concat" target="_blank" rel="external">https://github.com/gruntjs/grunt-contrib-concat</a></p><p>concat插件安装命令：<code>$ npm install grunt-contrib-concat --save-dev</code></p><p><code>--save-dev</code>参数表示插件安装完成后，记录相关信息到package.json文件中的devDependencies配置项。</p><p>下面列出具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ npm install grunt-contrib-concat --save-dev</div><div class="line">npm WARN grunt_demo@1.0.0 No description</div><div class="line">npm WARN grunt_demo@1.0.0 No repository field.</div><div class="line"></div><div class="line">+ grunt-contrib-concat@1.0.1</div><div class="line">added 2 packages in 3.165s</div><div class="line">wendingding:Grunt_Demo wendingding$ cat package.json</div><div class="line">&#123;</div><div class="line">  "name": "grunt_demo",</div><div class="line">  "version": "1.0.0",</div><div class="line">  "description": "",</div><div class="line">  "main": "index.js",</div><div class="line">  "scripts": &#123;</div><div class="line">    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</div><div class="line">  &#125;,</div><div class="line">  "author": "",</div><div class="line">  "license": "ISC",</div><div class="line">  "devDependencies": &#123;</div><div class="line">    "grunt": "^1.0.2",</div><div class="line">    "grunt-contrib-concat": "^1.0.1"</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>插件安装完成后，在项目的node_modules文件目录会新增加grunt-contrib-concat模块。接下来我们通过编辑Gruntfile文件来定义和配置Task。</p><p>在项目的根目录中创建src文件夹，在该文件夹下面创建两个示例的js文件，分别为demo_one.js和demo_two.js</p><p>demo_one.js文件的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明demoOne函数并执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"demoOne.js文件中的内容"</span>);</div><div class="line">&#125;</div><div class="line">demoOne();</div></pre></td></tr></table></figure></p><p>demo_two.js文件的内容<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明demoTwo函数并执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demoTwo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"demoTwo.js文件中的内容"</span>);</div><div class="line">&#125;</div><div class="line">demoTwo();</div></pre></td></tr></table></figure></p><p><strong><span style="color:#f25">编辑Gruntfile文件定义和配置Task</span></strong></p><p>接下来我们需要编辑Gruntfile文件，在该文件中告诉grunt具体的任务(Task)是什么，以及这些任务(Task)应该如何执行，下面给出示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数,规定所有的代码都需要写在该函数内部</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//项目配置信息</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">        <span class="comment">//表示从package文件中加载json数据,并保存到pkg属性中</span></div><div class="line">        pkg:grunt.file.readJSON(<span class="string">"package.json"</span>),</div><div class="line">        <span class="comment">//concat任务的配置信息</span></div><div class="line">        <span class="string">"concat"</span>:&#123;</div><div class="line">            dist: &#123;</div><div class="line">                <span class="comment">//把src目录下面的demo_one和demo_two文件合并成demo.js文件保存到dist目录</span></div><div class="line">                src: [<span class="string">'src/demo_one.js'</span>, <span class="string">'src/demo_two.js'</span>],</div><div class="line">                dest: <span class="string">'dist/demo.js'</span>,</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">//加载包含concat任务的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-concat"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//设置默认执行的任务列表</span></div><div class="line">    grunt.registerTask(<span class="string">"default"</span>,[<span class="string">"concat"</span>]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><strong>代码说明</strong></p><p>上面的示例代码主要由三部分组成：<code>配置任务相关代码</code> + <code>加载插件相关代码</code> + <code>注册任务相关代码</code>,所有的代码都需要写在module.exports这个包装函数内部，grunt作为包装函数的参数传递。</p><p> 这里代码中的pkg部分并非必要，loadNpmTasks方法用于从node_modules中加载对应的插件，registerTask方法表示把concat这个任务加入到默认的任务队列中(该行代码并非必需)，如果不写该行代码则可以直接以<code>$ grunt concat</code>的方式执行合并任务。当然也可以通过registerTask方法来给Task注册个别名，然后通过<code>$ grunt 别名</code>指令来执行该Task。</p><p>当前的目录结构如下(注：省略node_modules目录细节)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ tree -L 1</div><div class="line">.</div><div class="line">├── Gruntfile.js</div><div class="line">├── node_modules</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">    ├── demo_one.js</div><div class="line">    └── demo_two.js</div></pre></td></tr></table></figure></p><p>不同插件的使用方式可能也不尽相同，插件的具体用法请参考对应的文档说明。通过编辑Gruntfile文件指定任务的配置项、加载插件并注册任务后，就可以通过命令行来执行Task了。</p><p><strong><span style="color:#f25">执行Task</span></strong></p><p>执行Task的命令行：<code>$ grunt</code> 或者是<code>$ grunt default</code> 或者是<code>$ grunt concat</code><br>命令行输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Demo wendingding$ grunt default</div><div class="line">Running &quot;concat:dist&quot; (concat) task</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>Task执行结束后，src目录下面的demo_one.js和demo_two.js两个文件会被合并成demo.js文件并保存到dist目录下，如果指定的目录不存在那么将会直接创建。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/grunt_01.png?raw=true" height="200px"></p><p><strong> ✧ <span style="color:#195">压缩插件uglify和cssmin的安装和使用 </span>✧ </strong></p><p>创建新的文件目录Grunt_Test来演示javaScript的压缩插件uglify以及CSS的压缩插件cssmin的使用，创建好文件目录之后，同样通过<code>$ npm init</code>初始化命令来生成基础的package.json文件。</p><p>先安装grunt到本地的项目中，具体命令如下：</p><p><code>$ npm install grunt --save-dev</code></p><p>然后下载需要用到的对应插件到本地的项目中，具体命令如下 ：</p><p><code>$ npm install grunt-contrib-uglify --save-dev</code>   表示安装uglify插件</p><p><code>$ npm install grunt-contrib-cssmin --save-dev</code>   表示cssmin插件</p><p>上面的命令行执行完毕后，grunt就会把两个压缩插件下载到node_modules文件目录下，可以通过在该目录下查找grunt-contrib-uglify和grunt-contrib-cssmi文件进行验证。</p><p><code>--save--dev</code>参数会把下载记录更新到package.json文件中的devDependencies字段。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"devDependencies": &#123;</div><div class="line">"grunt": "^1.0.2",</div><div class="line">    "grunt-contrib-cssmin": "^2.2.1",</div><div class="line">    "grunt-contrib-uglify": "^3.3.0"</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>为了演示压缩插件的具体使用，下面我们在项目根目录下创建index.js文件，并新建style文件夹，并在该目录下创建index.css文件，具体的目录结构如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── node_modules</div><div class="line">│   ├── ...(省略)</div><div class="line">│   ├── grunt-contrib-cssmin</div><div class="line">│   ├── grunt-contrib-uglify</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">└── src</div><div class="line">├── index.js</div><div class="line">└── style</div><div class="line">└── index.css</div></pre></td></tr></table></figure></p><p>index.js文件内容为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by wendingding on 18/5/19.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">"文顶顶"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"______"</span> + c);</div><div class="line">&#125;)(<span class="built_in">window</span>);</div></pre></td></tr></table></figure></p><p>index.css文件内容为<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span>&#123;</div><div class="line">    <span class="attribute">background</span>: red;</div><div class="line">&#125;</div><div class="line">*&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来我们创建并编辑Gruntfile文件，通过特定的代码定义和配置Task。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//包装函数</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> app = &#123;</div><div class="line">        src:<span class="string">"src/"</span>,</div><div class="line">        dist:<span class="string">"dist/"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//(1) 项目配置信息</span></div><div class="line">    <span class="comment">//说明：initConfig方法等价于grunt.config.init()方法;</span></div><div class="line">    grunt.initConfig(&#123;</div><div class="line">    <span class="comment">//定义js文件压缩Task: 表示把src目录下面的index.js文件压缩到dist目录中的index.min.js</span></div><div class="line">        <span class="string">"uglify"</span>:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:app.src + <span class="string">"index.js"</span>,</div><div class="line">                dest:app.dist + <span class="string">"index.min.js"</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    <span class="comment">//定义css文件压缩Task: 表示把src/style目录中的index.css文件压缩到dist目录中的index.min.css</span></div><div class="line">        <span class="string">"cssmin"</span>:&#123;</div><div class="line">            target:&#123;</div><div class="line">                src:app.src + <span class="string">"style/index.css"</span>,</div><div class="line">                dest:app.dist + <span class="string">"index.min.css"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//(2) 加载对应的插件</span></div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-uglify"</span>);</div><div class="line">    grunt.loadNpmTasks(<span class="string">"grunt-contrib-cssmin"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//(3) 注册任务</span></div><div class="line">    <span class="comment">//002 注册任务的第一种方式</span></div><div class="line">    <span class="comment">//① 这种方式可以不写任何注册任务相关的代码</span></div><div class="line">    <span class="comment">//② 我们可以通过$ grunt uglify和$ grunt cssmin命令来分别执行这两个Task</span></div><div class="line">    <span class="comment">//③ 支持以$ grunt uglify cssmin的方式来依次执行多个Task</span></div><div class="line"></div><div class="line">    <span class="comment">//002 注册任务的第二种方式</span></div><div class="line">    <span class="comment">//① 这种方式相当于给每个任务都起一个Task名称，通过$ grunt task名称的方式执行</span></div><div class="line">    <span class="comment">//② 执行命令 $ grunt uglifyTask 表示执行js文件的压缩操作</span></div><div class="line">    <span class="comment">//③ 执行命令 $ grunt cssminTask 表示执行css文件的压缩操作</span></div><div class="line">    <span class="comment">//④ 执行命令 $ grunt cssminTask uglifyTask 表示先执行css文件的压缩，再执行js文件的压缩</span></div><div class="line">    <span class="comment">//grunt.registerTask("uglifyTask","uglify");</span></div><div class="line">    <span class="comment">//grunt.registerTask("cssminTask","cssmin");</span></div><div class="line"></div><div class="line">    <span class="comment">//003 注册任务的第三种方式</span></div><div class="line">    <span class="comment">// ① 这种方式把多个任务添加到default任务队列中，执行$ grunt default的时候，所有的Task依次执行</span></div><div class="line">    <span class="comment">// ② 执行命令为 $ grunt default 或者是$ grunt  因为default可以被省略</span></div><div class="line">    <span class="comment">// grunt.registerTask("default",["uglify","cssmin"]);</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>根据任务注册的不同方式来执行Task，下面分别给出三种方式的执行命令</p><p>方式（1）先执行<code>$ grunt cssmin</code>再执行 <code>$ grunt uglify</code>，或者通过<code>$ grunt cssmin uglify</code>命令来依次执行多个任务。</p><p>方式（2）先执行<code>$ grunt cssminTask</code>再执行 <code>$ grunt uglifyTask</code>，或者通过<code>$ grunt cssminTask uglifyTask</code>命令来依次执行多个任务。</p><p>方式（3）通过<code>$ grunt</code>或者是<code>$ grunt default</code>命令来依次执行多个任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">wendingding:Grunt_Test wendingding$ grunt default</div><div class="line">Running &quot;uglify:target&quot; (uglify) task</div><div class="line">&gt;&gt; 1 file created 174 B → 93 B</div><div class="line"></div><div class="line">Running &quot;cssmin:target&quot; (cssmin) task</div><div class="line">&gt;&gt; 1 file created. 89 B → 57 B</div><div class="line"></div><div class="line">Done.</div></pre></td></tr></table></figure></p><p>当两个任务执行完毕后，项目中会创建dist目录，该目录中新增两个文件分别对应压缩版的js文件和压缩版的css文件，新的目录结构如下。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── node_modules</div><div class="line">│   ├── ...(省略)</div><div class="line">│   ├── grunt-contrib-cssmin</div><div class="line">│   ├── grunt-contrib-uglify</div><div class="line">├── package-lock.json</div><div class="line">├── package.json</div><div class="line">├── dist</div><div class="line">│   ├── index.min.js</div><div class="line">│   └── index.min.css</div><div class="line">└── src</div><div class="line">├── index.js</div><div class="line">└── style</div><div class="line">└── index.css</div></pre></td></tr></table></figure></p><p>上文列出了代码合并插件concat和压缩插件uglify|uglify的安装和基本使用过程，grunt生态系统拥有数量庞大的高质量插件群体，无法一一介绍，可以到<a href="http://www.gruntjs.net/plugins" target="_blank" rel="external">Grunt相关的插件列表页面-中文</a>或<a href="https://gruntjs.com/plugins" target="_blank" rel="external">Grunt相关的插件列表页面-官网</a>自行查看。</p><blockquote><p><strong><span style="color:#f25">Grunt插件使用总结</span></strong></p><p>❏ 创建package.json文件(简单配置)和Gruntfile文件(<code>$ npm init</code>)<br>❏ 通过命令行把Grunt下载和安装到本地项目中(<code>$ npm install grunt --save-dev</code>)<br>❏ 通过命令行把Grunt插件下载和安装到本地项目中(<code>$ npm install grunt-contrib-xxx</code>)<br>❏ 在Gruntfile文件中对Grunt插件的Task进行配置（grunt.initConfig）<br>❏ 在Gruntfile文件中通过代码来加载对应的插件（grunt.loadNpmTasks）<br>❏ 在Gruntfile文件中通过代码来注册任务（grunt.registerTask）<br>❏ 在命令行中通过grunt + 任务名的方式来执行Task或加入到default队列以grunt命令执行。</p></blockquote><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍前端开发中常用的构建工具Grunt，具体包括Grunt的基本情况、安装、使用和常见插件的安装、配置和使用等内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-Grunt简单介绍&quot;&gt;&lt;a href=&quot;#1-1-Grunt简
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [010]-孩子王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B010%5D-%E5%AD%A9%E5%AD%90%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/17/读书笔记 [010]-孩子王/</id>
    <published>2018-05-17T14:11:18.000Z</published>
    <updated>2018-05-18T02:20:40.365Z</updated>
    
    <content type="html"><![CDATA[<div style="color:#195; font-size:20px">※·※（一）※·※</div><p>一九七六年，我在生产队已经干了七年。</p><p>我想了许久，心里有些紧张，想不通为什么要我去教书，又觉得有些得意，毕竟有人看得起，只是不知是谁。</p><p>我钻进去，黑黑的先是什么也看不清，慢慢就分辨出一块五柳平方米的间隔来。</p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>上午收拾停当，下午便开始教书了。老陈叫我去，教给我一个很脏的课本和一盒粉笔，还有红、蓝墨水，一直蘸水钢笔，一个备课本。</p><p>山野里很难有这种景象，这样多的蓬头垢面的娃子如分吃什么般聚坐在一起。</p><p><span style="color:#f25">“哈！做官没有印，读书不发书。”</span></p><p>书是没有的。咱们地方小，订了书，到县里去领，常常就没有了，说是印不出来，不够分。别的年级来了几本，学生们伙着用，大部分还是要抄的。这里和大城市不一样呢。</p><p>牛是极犟的东西，而且有气度，任打任骂，慢慢眨着眼吃它想吃的东西。</p><p>学生比牛好管多了。</p><p>书都没有，老起什么立？</p><p>教室前的场子没了学生，显出空旷。阳光落在地面，有些晃眼。</p><p>王福穿一件极短的上衣，胳膊露出半截。裤子也极短，揪皱着，一双脚极大。他用手拈起一支粉笔，手极大。</p><p>我收拾着一应教具，觉得这两节课尚有收获，结结实实地教了几个字，有如一天用锄翻了几分山地，记工员来量了，认认真真地记在账上。</p><p>我心里呀了一声，这王七桶我是认识的。王七桶绰号王稀屎。</p><p>车开到半路遇到泥泞，他总是爬下去。</p><p>我于是知道王福是王七桶的儿子，就说：“你爹我知道，很能干。”</p><p>王福说：“算上今天的一共三千四百五十一个字。” 我吃了一惊，说：“这么精确？” 王福说：“不信你数。”</p><p>不识字，大约是文盲，读不懂，大约是文化盲。</p><p><span style="color:#f25">老黑说：“中央台说了上句，我能对出下句，那都是套路，我摸得很熟，不消听。”我笑起来，说：“大约全国人民都很熟。我那个班上的学生，写作文，社论上的话来得个熟，不用教。你出个庆祝国庆的作文题，他能把去年的十一社论抄来，你还觉得一点儿不过时。”</span></p><p><span style="color:red">支书说：“家有隔夜粮，不当孩子王。学生们可闹？”</span></p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>我忽然觉得，愈是简单的事，也许真的愈不容易。</p><p>我家没有表，我起来了，我穿起衣服，我洗脸，我去伙房打饭，我吃了饭，洗了碗，我拿了书包，我没有表，我走了多久，山有雾，我到学校，我坐下，上课。</p><p>王福很高兴，眼白闪起来，抹一抹嘴。</p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p>课文于是不再教，终日只是认字，选各种事情来写。</p><p>记录一件事，永远在事后，这个道理是扳不动的。</p><p>我输了。<span style="color:#f25">我不要，我要——我要把字典抄下来。每天抄，五万字，一天抄一百，五百天。我们抄书，抄了八年呢。</span></p><div style="color:#195; font-size:20px">※·※（五）※·※</div><p>自此，每日放了学，王福便在屋中抄字典。我每每点一支烟在旁边望着他抄。有时怀疑起来，是不是我害了学生？书究竟可以这样教吗？学也究竟可以这样学吗？初时将教书看得严重，现在又将学习搞得如此呆板，我于教书，到底要负怎么样的责任？</p><div style="color:#195; font-size:20px">※·※（六）※·※</div><p><strong>我的父亲</strong></p><p><span style="color:#f25">我的父亲是世界中力气最大的人。他在队里扛麻袋，别人都比不过他。我的父亲又是世界上吃饭最多的人。家里的饭，都是母亲让他吃饱。这很对，因为父亲要做工，每月拿钱来养活一家人。但是父亲说：“我没有王福力气大，因为王福在识字。” 父亲是一个不能讲话的人，但我懂他的意思，队上有人欺负他，我明白。所以我要好好学文化，替他说话。父亲很辛苦，今天他病了，后来慢慢爬起来，还要去干活，不愿失去一天的钱。我要上学，现在还替不了他。早上出的白太阳，父亲在山上走，走进白太阳里去。我想，父亲有力气啦。</span></p><p>“课在上，但是课文没有教。”吴干事又说：“为什么？” 我想一想，终于说：“没有用”。</p><p>第二天极早的时候，我回来收拾了行李，将竹笆留在床上，趁了大雾，扛着行李沿山路去了三队。太阳依旧是白白的一圈。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※（一）※·※&lt;/div&gt;

&lt;p&gt;一九七六年，我在生产队已经干了七年。&lt;/p&gt;
&lt;p&gt;我想了许久，心里有些紧张，想不通为什么要我去教书，又觉得有些得意，毕竟有人看得起，只是不知是谁。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [009]-树王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B009%5D-%E6%A0%91%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/17/读书笔记 [009]-树王/</id>
    <published>2018-05-17T02:11:18.000Z</published>
    <updated>2018-05-18T02:20:40.369Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>按：《树王》承袭前作，立意似乎更甚，更富有想象力，更生动，对自然和人物的刻画入木三分。</p></blockquote><div style="color:#195; font-size:20px">※·※（一）※·※</div><p>知青中，李立是好读书的人。</p><p>吃完了饭，李立提议来个营火晚会。</p><p>生产队就在大山缝脚下，从站的地方望上去，森林的林子似乎要压下来，月光下只觉得如同鬼魅。</p><p>“接受贫下中农再教育，建设祖国，保卫祖国，改变一穷二白。”</p><p><span style="color:#F25">“把没用的树砍掉，种上有用的树。”</span></p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>山上原来极难走。</p><p>我忽然觉得这山像人脑的沟回，只不知其中思想着什么。又想，一个国家若都是山，那实际的面积比只有平原要多很多。</p><p>李立反插了腰，深深地吸一口气，说：“伟大。改造中国，伟大。”大家都同意着。</p><p>我生平从未见过这样大的树。</p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>第三天，大家便开始上山干活。活计自然是砍树。千百年没人动过这原始森林，于是整个森林长成一团。树都相互躲让着，又都互相争夺着，从上到下，无有闲处。</p><p>李立原并不十分强壮，却有一股狠劲，是别人比不得的。</p><p>队上发刀的头一天，我便用了三个钟头将刀磨得锋快。<span style="color:#f25">人有利器，易起杀心。</span>上到山上，逢物便砍，自觉英雄无比。只是一到砍树，刃常常损缺。</p><p>他想了想，看看了手，伸给我一只，说：“苦的很，你摸摸，苦的很，大比武，苦的很。”我摸一摸肖疙瘩的手。这手极硬，若在黑暗中触到，认为是手的可能性很小。而且这手的指头短而粗。肖疙瘩将手背翻过来，指甲极小，背上的肉也如一层石壳。</p><p><strong>磨刀 学习如何正确磨刀 送磨刀石</strong></p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p><strong>砍倒了山顶的巨树</strong></p><p><span style="color:#F25">树明明倒了，却没有巨大的声响。</span></p><p>我忽然觉得风冷，回过神来，才觉出一身凉汗，见大家也都有些缩头缩脑，开始有话，只是低低的地说。</p><p>天更暗了，月亮不再黄，青白地照过来，一山的断树奇奇怪怪。</p><div style="color:#195; font-size:20px">※·※（五）※·※</div><p><strong>给六爪买糖</strong></p><p>月光仍旧很亮，我不由站在场上，四下望望。目力所及的山上，树都已经翻倒，如同尸体，再没有初来时的神秘。</p><div style="color:#195; font-size:20px">※·※（六）※·※</div><p><span style="color:#F25">山上的树木终于都被砍倒。每日早晨的太阳便觉得格外刺眼。</span></p><p>原来肖疙瘩本是贵州的一个山民，年轻时从家乡入伍。部队上见他顽勇，又吃得苦，善攀登，便叫他干侦察。62年部队练兵大比武，肖疙瘩成绩好，于是被提为一个侦察班长。</p><p>渐渐不能明白<span style="color:#f25">为什么要将好端端的森林断倒烧掉，用有用的树换 有用的树，半斤八两的账算不清，自然有些怀疑怨言</span>。</p><p>“李立也是抽风，说是要砍对面山上那颗树王，破除迷信。”</p><p>李立不以为然，站起来说：<span style="color:#f25">“重要的问题是教育农民。旧的东西，是要具体去破的。树王砍不砍，说到底，没什么。可是树王一倒，一种观念就被破除了，迷信还在其次，重要的是，人在如何建设的问题上将会思想为之一新，得到净化。”</span></p><p>李立叫了支书，支书并不拿刀，叫了队长，队长也不拿刀，大家一齐上山。</p><div style="color:#195; font-size:20px">※·※（七）※·※</div><p>一张白纸，好画最新最美的图画。</p><p>学生们造反，皇帝都拉下马了，人家砍了头说是有个碗大的疤。你砍了头，可有碗大的疤？就是有，你那个疤值几个钱？糊涂！</p><p>原来护着树根的这个矮小汉子，才是树王！</p><p>支书说：“砍吧！总归是要砍，学生们有道理，不破不立，砍。”</p><div style="color:#195; font-size:20px">※·※（八）※·※</div><p><strong>砍树 砍倒 树王</strong></p><p>大树整整砍了四天，肖疙瘩也整整在旁边守了四天，一句话不说，定定地看刀在树上起落。</p><p>我坐了一会儿，见肖疙瘩如无魂的一个人，只有悄悄回来。</p><div style="color:#195; font-size:20px">※·※（九）※·※</div><p>防火带终于锄好，队长宣布要烧山了。</p><p><span style="border:1px solid #000">&nbsp;&nbsp; 这一章的描写精彩至极 &nbsp;&nbsp;</span></p><p>大伙霎时封了山顶，两边的火撞在一起，腾起几百丈高，须仰视才见。那火的顶端，舔着通红的天底。我这才明白，我从未真正见过火，也未见过毁灭，更不知新生。</p><p>山上是彻底地沸腾了。数万棵大树在火焰中离开大地，升向天空。</p><div style="color:#195; font-size:20px">※·※（十）※·※</div><p>这之后，肖疙瘩便一病不起。</p><p>我每日去看他，日见其枯缩。原来十分强悍而沉默的一个汉子，现在沉默依旧，强悍却渐渐消失。</p><p>大火烧失了大家的精神，大家又似乎聚德要有个结果，才得寄托。</p><p>“”我的女人与娃儿不识字，我不行了，要写一封书信给他，说我最后还是对不起他，请他原谅我先走了——”</p><p>葬的地方肖疙瘩也说过，就在离那棵巨树一丈远的地方。大家抬了棺材上山，在树桩根边挖了坑，埋了。那棵巨树仍仰翻在那里，端口刀痕累累，枝叶已经枯掉，却不脱落，仍有鸟儿飞来立在横倒的树身上栖息。</p><p>当天便有大雨。</p><p>一座山秃秃的，尚有未烧完的大树残枝，黑黑的立着，如果宇宙有箭飞来，深深射入山的裸体，只留黑羽箭尾在外面。</p><p><span style="color:#F25">肖疙瘩的骨殖仍埋在原来的葬处。这地方渐渐就长出一片草，生白花。有懂得的人说：这草是药，极是医得刀伤。大家在山上干活时，常常歇下来望，便能看到那棵巨大的树桩，有如人跌破后留下的疤；也能看到那片白花，有如肢体被砍伤，露出白白的骨。</span></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;按：《树王》承袭前作，立意似乎更甚，更富有想象力，更生动，对自然和人物的刻画入木三分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&quot;color:#195; font-size:20px&quot;&gt;※·※（一）※·※&lt;/div&gt;

&lt;p&gt;知青
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [008]-棋王</title>
    <link href="https://weibo.com/u/3800117445/2018/05/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B008%5D-%E6%A3%8B%E7%8E%8B/"/>
    <id>https://weibo.com/u/3800117445/2018/05/16/读书笔记 [008]-棋王/</id>
    <published>2018-05-16T12:57:18.000Z</published>
    <updated>2018-05-18T02:20:40.370Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：棋王应该是阿城最好的一部小说，阿城也由《棋王》《树王》《孩子王》盛名。</div><p><a href="https://book.douban.com/subject/26382501/" target="_blank" rel="external">《棋王》</a>作者<a href="https://book.douban.com/author/122104/" target="_blank" rel="external">阿城</a>，原名钟阿城，1949年生人。阿城被认为是伤痕文学的代表人物，我不太懂伤痕文学，只是读他的文字，恰如身临其境，故事娓娓道来，文字运用的妙极，只因我个人素养和学识有限，很难准备表达，但这不影响我对这位作家的尊重和喜欢，恰如王小波。</p><p>阿城的《棋王》和王小波的《黄金时代》给我一种恍恍惚惚浑然一体的感觉，这本书以特定历史为背景描写了一位“棋王”。据说有读者读完《黄金时代》后，竟跑去问询李银河女士，“是否认识陈清扬？和陈清扬还有联系吗？” 哈哈，或许这也正是写作的魅力之一。如果你读过这部小说，或许你也会如此？这两本书虽然风格不同，但都描述知青岁月，味道浓正。</p><p>每个人阅读的方式不同，我读第一遍的时候喜欢捧着书慢读，第二遍的时候有详有略，并且喜欢勾勾画画，读完之后我可能会把阅读过程中的点滴记录整理成文，于是就有了这样的一些读书笔记。</p><div style="color:#195; font-size:20px">※·※（一）※·※</div><p>我的几个朋友，都已经被我送走插队，现在轮到我了，竟没有人来送。父母生前颇有些污点，运动一开始就被打翻死去。</p><p><strong> 我的视角：特殊时期背景，父母双亡，下乡插队。</strong></p><p>我知道棋呆子就是王一生，可不知道王一生就是他。</p><p>王一生简直大名鼎鼎。</p><p>一路下去，慢慢发现我和王一生之间，既开始有互相的信任和基于经验的同情，又有各自的疑问。</p><p><strong>接下来的很大一部分篇幅，我和王一生讨论了吃的问题，经历过那段时期的人也许更能体会。</strong></p><p>人吃饭，不但是一肚子的需要，更是一种精神需要。</p><p><span style="color:#f25">何以解忧，唯有象棋。何以解不痛快，唯有象棋。</span></p><p>他对吃是虔诚的，而且很精细。有时你会可怜那些饭被他吃得一个渣儿都不剩，真有点儿惨无人道。我在火车上一直看着他下棋，发现他同样是精细的，但就有气度的多。</p><div class="tip">按：这段话是王一山给我讲如何学棋的经过,后面有一段阴阳相交的论述非常精彩</div><p>老头让我先说。我们俩就在垃圾站下盲棋，我是连输五盘。</p><p><span style="color:#f25">为棋不为生，为棋是养性</span>，生会坏性，所以生不可以太盛。</p><div style="color:#195; font-size:20px">※·※（二）※·※</div><p>这个农场在大山林里，活计就是砍树，烧山，挖坑，再栽树。不栽树的时候，就种点儿粮食。</p><p>山上总要放火，野兽们都惊走了，很难打到。</p><p>即使打到，野物们走惯了，没膘，熬不得油。尺把长的老鼠也捉来吃，因为老鼠是吃粮的，大家说鼠肉就是人肉，也算吃人吧。</p><p>你在车上给我讲的两个故事，我琢磨了，后来挺喜欢的。你不错，读了不少书。可是归根到底，解决什么呢？是呀，一个人拼命想活着，最后都神经了，后来好了，活下来了，可接着怎么活呢？</p><p>人要知足，顿顿饱就是福。</p><p><strong>王一生家庭的情况</strong></p><p>你家里到底是怎么个情况呢？</p><p>他叹了一口气，望着屋顶，很久才说：“穷。困难啊！我们家三口人儿，母亲死了，只有父亲，妹妹和我。我父亲嘛，挣得少。”</p><p><strong>母亲 家世 无字棋</strong></p><p><span style="color:red">妈不能看你念完初中，跟你爹说了，怎么困难也要念完。高中，妈打听了，那是为上大学，咱们家用不着上大学，你爹也不行了，你妹妹还小，等你初中念完了就挣钱，家里就靠你了。妈要走了，一辈子也没给你留下什么，只捡人家的牙刷把，给你磨了一幅棋。</span></p><p>不一刻，蛇肉吃完，只剩下两副蛇骨在碗里。</p><p>大家就说这燕窝一定非常好吃。脚卵又微微一笑，说：“我吃过的，很腥。”大家就感叹了，说费那么多钱，吃一口腥，太划不来。</p><p>天黑下来，早升在半空的月亮渐渐亮了。我点起油灯，立刻四壁都是人影子。</p><p>不久，脚卵抬起头，看着王一生说；<span style="color:#f25">“天下是你的”</span>。抽出一支烟给王一生，又说：<span style="color:#195">“你的棋是跟谁学的？” 王一生也看着脚卵，说：“跟天下人。”</span>脚卵说：“蛮好，蛮好，你的棋蛮好。”</p><p><strong>文教书记 调动</strong></p><p>这次运动会，他来信告诉我，让我争取参加农场的棋类队到地区的比赛，赢了，调动自然好说。</p><p>王一生叹一口气，说：“倪斌是个好人。”</p><div style="color:#195; font-size:20px">※·※（三）※·※</div><p>这以后，大家没事儿，常提起王一生，津津有味的回忆王一生光膀子大战脚卵。我说了王一生如何如何不容易，脚卵说：“我父亲说过的，寒门出高士”。</p><p>王一生很着急的样子，说：“这半年我总是请事假出来下棋，等我知道报名赶回去，分场说我表现不好，不准我出来参加比赛，连名都没报上。”</p><div class="tip">按 书记暗示倪斌以家里古玩换取工作调动，顺带解决王一生参赛的问题。</div><p>王一生在黑暗里说：“我不赛了，没意思。倪斌是好心，可我不想赛了。”</p><div style="color:#195; font-size:20px">※·※（四）※·※</div><p>人是越来越多，后来的人拼命的往前挤，挤不进去，就抓住人打听，以为是杀人的告示。</p><p>再也没有人动一下，似乎是要把命放在棋里搏。</p><p>我心里忽然有一种很古来的东西涌上来，喉咙紧紧的往上走。</p><p>这种阵势，我从来也没有见过，你想想看，九个人与他一个人下，九局连环！车轮大战！我要写信给我的父亲，把这次的棋谱都寄给他。</p><p>王一生的姿势没有变，仍旧是双手扶膝，眼平视着，像是望着极远极远的远处，又像是盯着极近极近的近处，瘦瘦的肩挑着宽大的衣服，土没有拍干净，东一块儿，西一块儿。</p><p>王一生孤身一人坐在大屋子中央，瞪眼看着我们，双手支在膝上，铁铸一个细树桩，似无所见，似无所闻。高高的一盏电灯，暗暗地照在他脸上，眼睛深陷进去，黑黑的似俯视大千世界，茫茫宇宙。</p><p>山民和地区的人层层围了，争睹棋王风采，又都点头儿叹息。</p><p>我笑起来，想：<span style="color:#195">不做俗人，哪儿会知道这般乐趣？家破人亡，平了头每日荷锄，却自有真人生在里面，见识到了，即是幸，即是福。衣食是本，自有人类，就是每日在忙这个。可囿在其中，终于还不太像人。</span></p><div style="color:#195; font-size:20px">※·※（后记）※·※</div><p>棋王这部小说字里行间，可见年代的质感，可见尘土飞扬的写意，可见匮乏的物质下丰饶的灵魂。</p><p>王一生和九个人象棋大战，最后和冠军言和，老人说王一生的棋是道家的棋。</p><p>看到这一段的时候并不是特别理解，后来找到阿城的原话解读。</p><p>其实，老者这样说只是要给自己台阶下，不失去了面子。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：棋王应该是阿城最好的一部小说，阿城也由《棋王》《树王》《孩子王》盛名。&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26382501/&quot; target=&quot;_blank&quot; rel=&quot;ex
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [007]-你我皆凡人</title>
    <link href="https://weibo.com/u/3800117445/2018/05/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B007%5D-%E4%BD%A0%E6%88%91%E7%9A%86%E5%87%A1%E4%BA%BA/"/>
    <id>https://weibo.com/u/3800117445/2018/05/16/读书笔记 [007]-你我皆凡人/</id>
    <published>2018-05-16T04:38:18.000Z</published>
    <updated>2018-05-18T02:20:40.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://book.douban.com/subject/26383472/" target="_blank" rel="external">你我皆凡人</a>这本书其实是六神磊磊公众号里若干文章的合集，虽然并没有任何实质性的意义但是却很有意思，适合无聊的时候消遣。</p></blockquote><p>王重阳和林朝英的真正问题，在于不会谈恋爱。<br>他们就这样不咸不淡的互相顶着帖，挥霍着年华岁月，还以为这就算是在谈恋爱。</p><p>你也很体面，我也很体面，但是我们的爱情，只收获了一个永远寂静的朋友圈。</p><div class="tip">读到雪山飞狐的时候，是真爱程灵素，远远超过袁紫衣，电视剧也同样。</div><p>程灵素：<code>她对敌人狠，对朋友义，对爱人忠，气度磊落，坦荡豁达。</code></p><p>女士们都在习惯性的仰攻，二流人物的女徒弟，总是想方设法撬一流人物的男徒弟。</p><p>江湖上还有一个规律：越是往基层走，男士就越容易被剩下，而女士反而越不愁嫁。在哪些江湖二三流的门派中，姑娘很抢手，根本不用担心被剩下。最容易被剩下的，反而是程英。</p><div class="tip">程英出场不久，对杨过暗生情愫，在宣纸上写”既见君子 云胡不喜”给我的印象太深刻了。</div><p>程英和郭襄都有点过于理想，最后前者只得到了一句“兄妹之情，皓如日月”，后者只得到一句“咱们就此别过”。</p><p>康敏从来就不清楚自己真正要什么，不断的开辟新战场，把自己在旧战场的缴获轻易的就拼光了。</p><p>“戚芳困境”：女人的一次背叛，不能用另一次背叛来救赎。</p><p>阿紫变成不良少女，主要是因为成长环境太差。几乎完全相同的环境，程灵素却长成了和阿紫完全相反的人：善良、仁爱、宽容、绝不滥杀无辜、心灵十分健全，为什么？唯一的解释就是程灵素有一个师傅——毒手药王。药王对于程灵素的影响不在于教诲，而在于另外两个方面：一是自身超强的学术水平，二是以身作则的宽厚人格。</p><p>在金庸的小说里，记叙了一个让人不忍卒读的故事：一位叫做欧阳锋的执着的古籍善本收藏家最后发了疯。</p><p>在江湖上，有一个名字最狂野、最张狂的教派，叫做日月神教。但讽刺的是，这个组织的头目东方不败先生完全没有这种功能。</p><p><span style="color:#195">金兵有狼牙棒，俺们有天灵盖。</span></p><p>那个江湖上已经没有了伟大的武功，只剩下一些伟大的公公。</p><p><span style="color:#f55">成王败寇是一种残忍的公平。</span></p><p><span style="color:#f55">侠之大者，为国为民。</span>当这八个大字的旗帜高高飘扬在襄阳城上时，郭靖已经是整个江湖的道义领袖和精神导师。</p><p>杨过原本是郭靖-黄蓉家族的成员，而且是郭靖极为看重的嫡系。郭靖送他去全真教拜师，本来是想让他开一家分公司，没想到杨过反而被另一家大企业古墓派猎获，另立门户，后来和郭家一度要决裂。</p><p>第三次华山论剑，它名义上的主题是祭奠洪七公，而它实质上的主题是郭靖-黄蓉联盟一统江湖的加冕礼。</p><p>数十年过去，华山论剑终于从五湖四海的英雄争霸，变成了一家人其乐融融的内部聚会，那所谓东南西北的名号，也从天下豪杰誓死争夺的地盘和版图，变成了郭靖-黄蓉联盟内部商量着分的蛋糕。</p><p>如果郭靖-黄蓉加载有纹章，那么一定是这样的：<span style="color:#195">上空飞舞着双雕，背景是巍峨的华山，衬底的是雄伟的襄阳城。</span></p><p>余沧海在攻入群玉院的时候撞见了华山派大弟子令狐冲。余掌门向他发出了振聋发聩的正义质问：嫖妓宿娼，是甚么行径？但他实在不好意思质问别人“杀人全家，是什么行径”，因为他杀过林震南全家，也不好意思质问别人“抢人钱财，是什么行径”，因为他侵吞人家福威镖局的财产，也不好意思质问别人“夺人武功，是什么行径”，因为他抢过人家的辟邪剑谱。</p><p>侠客行和连城诀是相反的两部书。<br>在一个复杂的世界里，做聪明人无疑是好事，但是在一个太过复杂的世界里，做一个笨人或许也是不坏的选择。</p><p>小圈子里的大人物，一大显著特点是对批评的容忍度往往比较低。但是他们在关起门来面对自己村里的人的时候，会显得无比自信。</p><p>他们越不擅长什么，就越教人家什么。</p><p><span style="color:#195">尊重你自己的行业，尊重你的禀赋特长。</span></p><p>教主常常是最不忠实的员工，这种事发生在各行各业，就好像编写星座知识的人往往最不信星座一样。</p><p>对于粉丝而言，有两样东西最敏感，道德感和自尊心。</p><p>他们的崇拜是一种高利贷。他们对你的喜爱，很容易转化为愤怒，他们付出了尊敬后，会聚精会神、小心翼翼地等待着回报。如果这种预期的回报没有出现，他们就会用十倍的怨毒让你补偿。</p><p>往往开会的人越多，会议越不重要。</p><p>各大门派说，纸是有限的，而钱是无限的，以无限的钱买有限的纸，能不涨价嘛？然而不要忘记了，侠客也是有限的。人们总是下意识的觉得，纸张有限，侠客很多。<code>有一些过剩，是门派性的过剩，有一些短期，是江湖性的短缺。</code></p><p>历史的答案总是隐藏在云雾之中，凡人最难看清楚的，就是当下的时代在历史中所处的位置。</p><p class="tip"><br><strong>后记</strong> ➣<br>其实一本书读完就读完了，这本小书应该是去年早些时候买的，初看挺有意思的，再看觉得那一层意思更浓了，我觉得所有文章中<code>读懂华山论剑</code>写的最好，而<code>《射雕英雄传》：一个关于收藏的故事</code>最有意思。今天整理桌子又看到了这本书，遂记录其间只言片语，这本书以后应该不会再拿起了，因为很多东西意思意思就行了。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26383472/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;你我皆凡人&lt;/a&gt;这本书其实是六神磊磊公众号里若干文章的合集，虽然并没有任何实质性
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化系列[01]-Bower包管理工具的使用</title>
    <link href="https://weibo.com/u/3800117445/2018/05/14/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97%5B01%5D%20%20Bower%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://weibo.com/u/3800117445/2018/05/14/前端工程化系列[01]  Bower的安装和使用/</id>
    <published>2018-05-14T11:45:13.000Z</published>
    <updated>2018-05-21T03:56:58.373Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍前端开发中常用的包管理工具Bower，具体包括Bower的基本情况、安装、使用和常见命令等内容，最后还介绍了依赖树管理的常见方式以及Bower采用的策略并进行了比较。</p></blockquote><h3 id="1-1-关于Bower"><a href="#1-1-关于Bower" class="headerlink" title="1.1 关于Bower"></a>1.1 关于Bower</h3><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower.png?raw=true" height="200px"></p><p>Bower是一款优秀的包管理器，它由Twitter公司开发，支持以命令行的方式来对包进行搜索、下载、更新和卸载。</p><p><strong>模块或组件</strong>指独立完整的模块，可以是应用的一部分或者是扩展，依赖可以是jQuery或backbone这样的库，也可以像Bootstrap这样的UI框架或者是UI组件。</p><p><strong>包</strong>英文（package）模块或组件的另一种叫法。</p><p><strong>依赖</strong>一个模块为了满足独立完整原则所必须的其他模块，依赖提供了这个模块所需要的功能，如果没有这个功能，那么这个组件就无法工作。例如我们认为jQuery-ui这个组件依赖于jQuery。</p><p><strong>Bower的优点</strong></p><blockquote><p>❑  专为前端开发设计，几乎所有的主流前端库都可以使用该工具。<br>❑  约束松散，使用简单。<br>❑  依赖树扁平更适合Web应用开发。</p></blockquote><p>官网参考：<a href="https://bower.io/" target="_blank" rel="external">https://bower.io/</a></p><h3 id="1-2-Bower的安装"><a href="#1-2-Bower的安装" class="headerlink" title="1.2 Bower的安装"></a>1.2 Bower的安装</h3><p>在安装bower之前，必须确认你已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>。</p><p><strong>安装Bower</strong></p><p>使用npm来安装Bower，-g表示全局安装</p><p><code>$ npm install -g bower</code></p><p><strong>查看Bower版本</strong></p><p>Bower安装完成后就能在命令行中直接使用bower命令了，可以通过下面的命令行来查看当前的版本。</p><p><code>$ bower -v</code> 或者是<code>$ bower -version</code></p><p><strong>查看帮助信息</strong></p><p>使用help命令来查看帮助信息。</p><p><code>$ bower -help</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line"></div><div class="line">    bower <span class="tag">&lt;<span class="name">command</span>&gt;</span> [<span class="tag">&lt;<span class="name">args</span>&gt;</span>] [<span class="tag">&lt;<span class="name">options</span>&gt;</span>]</div><div class="line">Commands:</div><div class="line"></div><div class="line">    cache            Manage bower cache(管理缓存信息)</div><div class="line">    help             Display help information about Bower（显示关于Bower的帮助信息）</div><div class="line">    home             Opens a package homepage into your favorite browser</div><div class="line">    info             Info of a particular package(显示特定包的详细信息)</div><div class="line">    init             Interactively create a bower.json file（交互式创建bower.json文件）</div><div class="line">    install          Install a package locally（安装包到本地）</div><div class="line">    link             Symlink a package folder(在本地bower库建立一个项目链接）</div><div class="line">    list             List local packages - and possible updates（列出本地包以及可能的更新）</div><div class="line">    login            Authenticate with GitHub and store credentials（Github身份认证）</div><div class="line">    lookup           Look up a single package URL by name（根据包名查询包的URL）</div><div class="line">    prune            Removes local extraneous packages（删除项目没有用到的包）</div><div class="line">    register         Register a package（注册一个包）</div><div class="line">    search           Search for packages by name（通过名称来搜索包）</div><div class="line">    update           Update a local package（更新项目的包）</div><div class="line">    uninstall        Remove a local package（移除项目的包）</div><div class="line">    unregister       Remove a package from the registry（注销包）</div><div class="line">    version          Bump a package version（列出版本信息）</div><div class="line">Options:...</div></pre></td></tr></table></figure><h3 id="1-3-Bower的使用"><a href="#1-3-Bower的使用" class="headerlink" title="1.3 Bower的使用"></a>1.3 Bower的使用</h3><p><strong>初始化操作</strong></p><p>在桌面创建新的文件夹，用来演示Bower的使用。先使用命令行进入到文件夹路径，然后使用下面的命令来对Bower进行初始化操作。</p><p><code>$ bower init</code></p><p>根据提示来交互式的设置基本项，初始化操作完成之后，会在文件夹的根目录中创建一个bower.json文件，里面包含一些基本信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"bowerDemo"</span>,</div><div class="line">  <span class="string">"authors"</span>: [</div><div class="line">    <span class="string">"wendingding"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"description"</span>: <span class="string">"Nothing"</span>,</div><div class="line">  <span class="string">"main"</span>: <span class="string">""</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"MIT"</span>,</div><div class="line">  <span class="string">"homepage"</span>: <span class="string">"wendingding.com"</span>,</div><div class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="string">"ignore"</span>: [</div><div class="line">    <span class="string">"**/.*"</span>,</div><div class="line">    <span class="string">"node_modules"</span>,</div><div class="line">    <span class="string">"bower_components"</span>,</div><div class="line">    <span class="string">"test"</span>,</div><div class="line">    <span class="string">"tests"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>安装指定的包</strong></p><p>尝试执行下面的命令行，来把jQuery框架安装到当前项目中。</p><p><code>$ bower install --save jquery</code></p><p>命令行中的save参数会把包记录保存到bower.json文件中，install命令会把jQuery框架下载到bower_components目录中，该目录文件是保存所有组件和依赖的地方。当执行install命令的时候，Bower会从仓库中获取到jQuery组件的信息然后和bower.json文件中的信息进行比较，如果jQuery没有安装，那么就会默认安装最新版本，如果已经安装了，则bower会自动停止并提示。</p><p>具体的执行情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bogon:Demo wendingding$ bower install --save jquery</div><div class="line">bower invalid-meta  <span class="keyword">for</span>:<span class="regexp">/Users/</span>文顶顶/Desktop/Demo/bower.json</div><div class="line">bower invalid-meta  The <span class="string">"name"</span> is recommended to be lowercase, can contain digits, dots</div><div class="line">bower cached        https:<span class="comment">//github.com/jquery/jquery-dist.git#3.3.1</span></div><div class="line">bower validate      <span class="number">3.3</span><span class="number">.1</span> against https:<span class="comment">//github.com/jquery/jquery-dist.git#*</span></div><div class="line">bower install       jquery#3.3.1</div><div class="line"></div><div class="line">jquery#3.3.1 bower_components/jquery</div></pre></td></tr></table></figure></p><p>命令执行完毕后，Bower会在根目录下生成bower_components文件夹，并把下载好的包（jQuery框架）放在这个文件夹里面。此时目录结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── bower.json</div><div class="line">└── bower_components</div><div class="line">    └── jquery</div><div class="line">        ├── AUTHORS.txt</div><div class="line">        ├── LICENSE.txt</div><div class="line">        ├── README.md</div><div class="line">        ├── bower.json</div><div class="line">        ├── dist</div><div class="line">        ├── external</div><div class="line">        └── src</div></pre></td></tr></table></figure></p><p>查看bower.json文件会发现，此时更新了包和对应的版本信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"jquery"</span>: <span class="string">"^3.3.1"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><blockquote><p><strong><span style="color:#f55">Bower在执行安装操作的时候，主要做了如下操作：</span></strong></p><p>① &nbsp;检查项目目录中的bower.json文件，以确定包是否已经安装了。<br>② &nbsp;如果指定的包没有安装，那么Bower就会检查Bower仓库中是否存在名称对应的包<br>③ &nbsp;如果Bower仓库中存在指定的包，那么就下载最新版本到本地<br>④ &nbsp;把下载好的包的文件添加到项目目录中，并且更新bower.json文件(包名和版本)</p></blockquote><h3 id="1-4-Bower的常见命令"><a href="#1-4-Bower的常见命令" class="headerlink" title="1.4 Bower的常见命令"></a>1.4 Bower的常见命令</h3><p><strong>安装指定包</strong></p><p><code>$ bower install                               # 通过 bower.json 文件安装</code><br><code>$ bower install jquery                      # 通过在github上注册的包名安装</code><br><code>$ bower install desandro/masonry            # GitHub短链接</code><br><code>$ bower install http://example.com/x.js     # URL路径</code><br><code>$ bower install git://github.com/user/package.git   #Github上的 .git</code></p><p>想要下载安装的包可以是GitHub上的短链接、.git 、一个URL路径等。</p><p><strong>搜索指定的包</strong></p><p><code>$ bower search jquery</code></p><p>如果我们在使用框架或者是框架插件的时候，记不住或者是不确定包的名字，则可以尝试先通过关键字搜索，bower会列出包含关键字的所有可用包。</p><p><strong>安装包的指定版本</strong></p><p><code>$ bower install --save jquery#1.8.0</code></p><p>Bower通过#号来确定需要下载的版本，如果没有指定版本，则Bower自动帮我们下载最新的。所以，如果需要下载特定版本的包，可以在安装命令中使用#号来声明。</p><p>如果要安装指定的版本，也可以先在bower.json文件中对dependencies选项进行配置，然后执行<code>$ bower install</code>或者是<code>$ bower update</code>命令。</p><p><strong>查看已安装的包</strong></p><p> <code>$ bower list</code><br> <code>$ bower list --paths</code></p><p>具体的执行情况如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wendingding$ bower list</div><div class="line">bower check-<span class="keyword">new</span>     Checking <span class="keyword">for</span> <span class="keyword">new</span> versions <span class="keyword">of</span> the project dependencies...</div><div class="line">demo /Users/文顶顶/Desktop/Test</div><div class="line">├── jquery#3.3.1</div><div class="line">└─┬ jquery-ui#1.12.1</div><div class="line">  └── jquery#3.3.1</div><div class="line">wendingding$ bower list --paths</div><div class="line">  jquery: bower_components/jquery/dist/jquery.js</div><div class="line">  jquery-ui<span class="string">': bower_components/jquery-ui/jquery-ui.js</span></div></pre></td></tr></table></figure><p><code>list命令</code>可以查看项目中当前下载过的包，并提供最新版本号。<br><code>paths命令</code>可以查看当前下载过的所有包在项目中的对应路径，在其它工具中需要声明/配置前端依赖包地址的时候该命令可能会比较有用。</p><p><strong>卸载指定的包</strong></p><p><code>$ bower uninstall jquery</code></p><p>卸载本地项目中已经安装的jQuery框架。</p><p><strong>更新指定的包</strong></p><p><code>$ bower update jquery</code></p><p>更新包的过程和安装包的过程差不多，区别在于更新的时候会使用新文件替换旧文件，上面的命令强制安装最新版本的jQuery框架。</p><p><strong>查看指定包的详细信息</strong></p><p><code>$ bower info jquery</code></p><p>通过info指令可以查看指定包的详情，还指令会列出对应的git仓库地址，以及所有可用的版本。</p><h3 id="1-5-Bower安装有依赖的包"><a href="#1-5-Bower安装有依赖的包" class="headerlink" title="1.5 Bower安装有依赖的包"></a>1.5 Bower安装有依赖的包</h3><p>通常当我们使用Bower命令(<code>bower install --save xxx</code>)来安装指定包的时候，Bower会查找包对应的git仓库地址然后下载到本地并在bower.json文件中记录版本等信息。但有的包在使用的时候可能存在依赖关系，比如ember这个包需要依赖于jQuery框架。</p><blockquote><p><strong>使用Bower安装有依赖包的两种方式</strong><br>❑  先安装该包的依赖项（这里为jQuery），再安装指定的包（这里为ember）<br>❑  直接安装（这里为ember）</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;方式 ① &nbsp; &nbsp;</strong></span></p><p>先安装依赖,再安装指定包</p><p><code>$ bower install --save jquery</code><br><code>$ bower install --save ember</code><br><code>$ bower list</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">├─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">│ └── jquery#3.3.1</div><div class="line">└── jquery#3.3.1</div></pre></td></tr></table></figure><p><span style="border:1px solid#000"><strong>&nbsp; &nbsp;方式 ② &nbsp; &nbsp;</strong></span></p><p>直接安装指定包,会自动安装依赖(推荐)</p><p><code>$ bower install --save ember</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bower invalid-meta  for:/Users/文顶顶i/Desktop/Test/bower.json</div><div class="line">bower cached        https://github.com/components/ember.git#2.18.2</div><div class="line">bower validate      2.18.2 against https://github.com/components/ember.git#*</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#&gt;=1.7.0<span class="tag">&lt;<span class="name">4.0.0</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">ember</span>#<span class="attr">2.18.2</span> <span class="attr">bower_components</span>/<span class="attr">ember</span></span></div><div class="line"><span class="tag">└── <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">jquery</span>#<span class="attr">3.3.1</span> <span class="attr">bower_components</span>/<span class="attr">jquery</span>`</span></div></pre></td></tr></table></figure><p>列出项目中已经安装的所有包和依赖关系</p><p><code>$ bower list</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">......</div><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">└─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">  └── jquery#3.3.1</div></pre></td></tr></table></figure></p><p>该命令行在安装ember包的时候，发现需要依赖于jQuery框架，就会自动下载对应版本的jQuery框架并安装到本地项目中。</p><h3 id="1-6-依赖树管理"><a href="#1-6-依赖树管理" class="headerlink" title="1.6 依赖树管理"></a>1.6 依赖树管理</h3><p>组件(包)并非总是相互独立的，有些组件(包)在使用的时候需要依赖于另外一些组件(包)，就像上文提到的ember需要依赖于jQuery，jQuery-ui需要依赖于jQuery一样，我们尝试使用下面的图示来描述这种关系。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree1.png?raw=true"></p><p>上面的图示揭示了包（组件）与包（组件）之间的依赖关系，非常简单容易理解。在实际中，每个组件可能都有多个依赖，而这些依赖自己可能还有别的依赖，或者多个不同组件都依赖于某个指定的组件，因此在处理的时候可能会非常复杂。为了理清楚这复杂的关系，依赖管理工具会把所有的依赖构成一颗<code>Dependency Tree</code>（依赖树）。</p><blockquote><p><strong>依赖树主要有三种</strong><br>❑   嵌套依赖树<br>❑   扁平依赖树<br>❑   混合依赖树</p></blockquote><p>注意：在构造依赖树的时候，组件（包）必须要有唯一的标识，该标识由组件的名称和版本号构成，也就是说jQuery1.7.3和jQuery3.3.1是两个不同的组件。</p><p><strong>嵌套依赖树</strong></p><p><code>基本理念</code>：每个组件各自都有自己的依赖，而不会共用一个依赖。<br><code>主要问题</code>：项目中会产生同一组件的多个副本，且可能有多个版本的组件共存比较混乱。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree2.png?raw=true"></p><p><strong>扁平依赖树</strong></p><p><code>基本理念</code>：保证每个组件在项目只有一个版本，没有任何其它的副本。<br><code>主要问题</code>：容易产生冲突，如果两个组件需要同一个依赖的不同版本，就会导致出错，必须要用户自己来解决冲突，决定具体使用哪个依赖并解决潜在的不一致性。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree3.png?raw=true"></p><p><strong>混合依赖树</strong></p><p><code>基本理念</code>：使用最高效的办法来管理一个组件的不同版本。<br><code>主要特点</code>：混合依赖树是扁平依赖树和嵌套依赖树的折中方案，如果一个组件的依赖已经安装了，而且版本也兼容，那么就不必再次下载安装，只要指向已安装的那个组件即可，如果版本不兼容的话，则下载安装并版本兼容的组件。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/bower_tree4.png?raw=true"></p><h3 id="1-7-Bower依赖树管理和冲突处理"><a href="#1-7-Bower依赖树管理和冲突处理" class="headerlink" title="1.7 Bower依赖树管理和冲突处理"></a>1.7 Bower依赖树管理和冲突处理</h3><p>Bower作为专为前端开发者设计的依赖管理工具，是完全基于扁平依赖树的。上文介绍了扁平依赖树在处理的时候要求<strong>保证每个组件在项目只有一个版本，没有任何其它的副本</strong>，优缺参半。那既然如此，Bower为什么不使用更高效的混合依赖树？</p><blockquote><p><strong>Bower采用扁平依赖树管理的原因</strong></p><p><span style="color:#f25">（1）代码体积对于前端开发非常重要，而扁平树管理可以实现组件最(少)小化。</span><br><span style="color:#f25">（2）所有组件默认都在浏览器的全局作用域中运行，不同版本的同名组件会产生冲突。</span></p></blockquote><p>因为Bower采用了扁平依赖树的方式来处理，所以在使用的时候容易产生冲突，这种依赖管理方式要求开发者注重组件的版本兼容和依赖关系。接下来，我们简单演示Bower使用过程中会出现冲突的情况。</p><p><strong>冲突的产生和处理</strong></p><p>① 安装jQuery框架的1.2.3版本</p><p><code>$ bower install --save jquery#1.2.3</code></p><p>执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain...</div><div class="line">bower not-cached    https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower resolve       https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower download      https://github.com/jquery/jquery-dist/archive/1.2.3.tar.gz</div><div class="line">bower extract       jquery#1.2.3 archive.tar.gz</div><div class="line">bower deprecated    Package jquery is using the deprecated component.json</div><div class="line">bower resolved      https://github.com/jquery/jquery-dist.git#1.2.3</div><div class="line">bower install       jquery#1.2.3</div></pre></td></tr></table></figure></p><p>② 安装ember组件并解决冲突</p><p><code>$ bower install --save ember</code></p><p>具体的执行情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">bogon:Test wendingding$ bower install --save ember</div><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain digits, dots, dashes</div><div class="line">bower cached        https://github.com/components/ember.git#2.18.2</div><div class="line">bower validate      2.18.2 against https://github.com/components/ember.git#*</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#&gt;= 1.7.0 <span class="tag">&lt; <span class="attr">4.0.0</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">Unable</span> <span class="attr">to</span> <span class="attr">find</span> <span class="attr">a</span> <span class="attr">suitable</span> <span class="attr">version</span> <span class="attr">for</span> <span class="attr">jquery</span>, <span class="attr">please</span> <span class="attr">choose</span> <span class="attr">one</span> <span class="attr">by</span> <span class="attr">typing</span> <span class="attr">one</span> <span class="attr">of</span> <span class="attr">the</span> <span class="attr">numbers</span> <span class="attr">below:</span></span></div><div class="line"><span class="tag">    <span class="attr">1</span>) <span class="attr">jquery</span>#<span class="attr">1.2.3</span> <span class="attr">which</span> <span class="attr">resolved</span> <span class="attr">to</span> <span class="attr">1.2.3</span> <span class="attr">and</span> <span class="attr">is</span> <span class="attr">required</span> <span class="attr">by</span> <span class="attr">Test</span></span></div><div class="line"><span class="tag">    <span class="attr">2</span>) <span class="attr">jquery</span>#&gt;</span>= 1.7.0 <span class="tag">&lt; <span class="attr">4.0.0</span> <span class="attr">which</span> <span class="attr">resolved</span> <span class="attr">to</span> <span class="attr">3.3.1</span> <span class="attr">and</span> <span class="attr">is</span> <span class="attr">required</span> <span class="attr">by</span> <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">Prefix</span> <span class="attr">the</span> <span class="attr">choice</span> <span class="attr">with</span> ! <span class="attr">to</span> <span class="attr">persist</span> <span class="attr">it</span> <span class="attr">to</span> <span class="attr">bower.json</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag">? <span class="attr">Answer</span> <span class="attr">2</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div><div class="line"><span class="tag"><span class="attr">bower</span> <span class="attr">install</span>       <span class="attr">ember</span>#<span class="attr">2.18.2</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">jquery</span>#<span class="attr">3.3.1</span> <span class="attr">bower_components</span>/<span class="attr">jquery</span></span></div><div class="line"><span class="tag"></span></div><div class="line"><span class="tag"><span class="attr">ember</span>#<span class="attr">2.18.2</span> <span class="attr">bower_components</span>/<span class="attr">ember</span></span></div><div class="line"><span class="tag">└── <span class="attr">jquery</span>#<span class="attr">3.3.1</span></span></div></pre></td></tr></table></figure></p><p><code>说明</code>：我们先把jQuery的1.2.3版本安装到了项目中，然后又通过Bower来安装ember，而ember组件需要依赖于jQuery框架，这里有个关键信息就是<code>ember要求依赖的jQuery框架版本范围为1.70 ~ 4.0.0</code>和本地已经安装的jQuery 1.2.3冲突，Bower并不会自己处理这个问题而是抛出一个异常，把选择权交给用户，由用户来选择使用哪种方案。</p><p>通过命令行的打印，我们看到Bower为我们提供了两个可选项，第一个选项是保留本地已经安装的1.2.3版本，第二个选项是保存ember所依赖的版本，这里显示了依赖需要的版本范围jQuery#&gt;=1.70&lt;4.0.0和最终会决定(resolved)的版本(3.3.1)。上面的示例中，冲突产生后我们输入2，选择安装jQuery的3.3.1版本。</p><p>③ 查看项目已安装的组件信息</p><p><code>$ bower list</code></p><p>具体的组件和依赖结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Test /Users/文顶顶/Desktop/Test</div><div class="line">├─┬ ember#2.18.2 (latest is 3.0.0-beta.2)</div><div class="line">│ └── jquery#3.3.1</div><div class="line">└── jquery#3.3.1 incompatible with 1.2.3 (1.2.3 available, latest is 3.3.1)</div></pre></td></tr></table></figure></p><p>冲突处理完后，项目中原本下载安装好的jQuery1.2.3版本被重新下载的3.3.1版本替代。</p><h3 id="1-8-Bower自定义组件目录"><a href="#1-8-Bower自定义组件目录" class="headerlink" title="1.8 Bower自定义组件目录"></a>1.8 Bower自定义组件目录</h3><p>默认情况下，所有的依赖包都被下载保存到bower_components文件路径，如果想要把依赖包下载到自己指定的目录，使用.bowerrc文件配合bower.json就可以实现。</p><p>在项目根目录创建.bowerrc文件，使用json格式来设置文件路径。<br><code>{    &quot;directory&quot;: &quot;指定路径&quot;}</code><br>保存好以后，执行bower install命令，就会把bower.json配置好的相关组件全部下载到指定的路径中。</p><p>命令行参考<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">bogon:Test wendingding$ touch .bowerrc</div><div class="line">bogon:Test wendingding$ vim .bowerrc</div><div class="line">bogon:Test wendingding$ cat .bowerrc</div><div class="line">&#123;</div><div class="line">    "directory": "app/xxx/"</div><div class="line">&#125;</div><div class="line">bogon:Test wendingding$ cat bower.json</div><div class="line">&#123;</div><div class="line">  "name": "Test",</div><div class="line">  "authors": [</div><div class="line">    "flowerField <span class="tag">&lt;<span class="name">18681537032@163.com</span>&gt;</span>"</div><div class="line">  ],</div><div class="line">  "description": "",</div><div class="line">  "main": "",</div><div class="line">  "license": "MIT",</div><div class="line">  "homepage": "",</div><div class="line">  "ignore": [</div><div class="line">    "**/.*",</div><div class="line">    "node_modules",</div><div class="line">    "bower_components",</div><div class="line">    "test",</div><div class="line">    "tests"</div><div class="line">  ],</div><div class="line">  "dependencies": &#123;</div><div class="line">    "jquery": "^3.3.1"</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">bogon:Test wendingding$ bower install</div><div class="line">bower invalid-meta  for:/Users/文顶顶/Desktop/Test/bower.json</div><div class="line">bower invalid-meta  The "name" is recommended to be lowercase, can contain digits...</div><div class="line">bower cached        https://github.com/jquery/jquery-dist.git#3.3.1</div><div class="line">bower validate      3.3.1 against https://github.com/jquery/jquery-dist.git#^3.3.1</div><div class="line">bower install       jquery#3.3.1</div><div class="line"></div><div class="line">jquery#3.3.1 app/xxx/jquery</div><div class="line">bogon:Test wendingding$ tree -L 3</div><div class="line">.</div><div class="line">├── app</div><div class="line">│   └── xxx</div><div class="line">│       └── jquery</div><div class="line">└── bower.json</div></pre></td></tr></table></figure></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍前端开发中常用的包管理工具Bower，具体包括Bower的基本情况、安装、使用和常见命令等内容，最后还介绍了依赖树管理的常见方式以及Bower采用的策略并进行了比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-1-关于Bo
      
    
    </summary>
    
    
      <category term="前端工程化系列" scheme="https://weibo.com/u/3800117445/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [006]-老人与海</title>
    <link href="https://weibo.com/u/3800117445/2018/05/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B006%5D-%E8%80%81%E4%BA%BA%E4%B8%8E%E6%B5%B7/"/>
    <id>https://weibo.com/u/3800117445/2018/05/13/读书笔记 [006]-老人与海/</id>
    <published>2018-05-13T00:08:18.000Z</published>
    <updated>2018-05-18T02:20:40.379Z</updated>
    
    <content type="html"><![CDATA[<div class="tip">按：大概十几年前就看过老人与海这本书，当时看完之后知道这本书讲了一个非常简单的故事：一位老人出海钓鱼，终于钓到一条大鱼后却被鲨鱼们夺走的故事。继而没什么印象了，在今年年初的时候看到<code>作家榜经典文库</code>出了本鲁羊翻译的新版本就顺手买下了，花了半天的时间看完，这已经是很久之前的事情了。此刻坐在书桌前的我，看到角落上这本老人与海，有了写这篇小短文的冲动。</div><p>这本书很多人耳熟能详，很多人(读者或者是现当代知名作家)把它视为为无法逾越的经典，还有一些人则嗤之以鼻，觉得整本书空洞、磨叽、无聊之至。在这里，我不愿意对这样的一本书做出任何评价，因为阅读从来都是个人的事情，而且随着人的阅历和心境的改变多次阅读同一本书的体验也会完全不同。值得一提的是，作家榜这个版本的<a href="https://book.douban.com/subject/26983338/" target="_blank" rel="external">老人与海</a>，除了外面的塑封外我不喜欢外，硬封精装以及插图设计都还是挺亮眼的，其实这就是我买下它的理由。</p><p>无可否认海明威是位伟大的作家，《牧羊少年奇幻之旅》的作者保罗·柯艾略在自序里盛赞海明威是位通晓了宇宙语言的伟大作家并向之致敬。如果使用百度百科或者是维基百科简单的了解过海明威，也许会深以为然。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/lryh.png?raw=true" height="200px"></p><p>这本书讲了个非常简单的故事：老人钓鱼。里面角色很少，主要有：老人、男孩、其他同行、迪马齐、海燕、马林鱼、鲨鱼、以及最后出场的女人。<span style="color:#195">一位朋友读完整本书后都没搞清楚老人钓到的是条什么鱼，其实是条巨大的大马林鱼。</span></p><p>我个人对这本书的感受是：<span style="border:1px solid #000">&nbsp; &nbsp;孤独&nbsp; &nbsp;</span> 和 <span style="border:1px solid #000">&nbsp; &nbsp;挫败&nbsp; &nbsp;</span></p><p>我几乎能对老人的孤独感同身受，独自一人孤舟一片在大海中漂零，他多么希望男孩在自己身边，他甚至同海燕说话还自言自语，啰里啰嗦简直疯了。其实这就是孤独，没有深切经历过的人或许很难体会到这种处境下人何以会自言自语，与海鸟对话。我体验过，所以读完之后并不觉得絮絮叨叨，反而一种巨大的真实扑面而来。因为人孤独至极的时候，真的是会自言自语与万物对话，甚至万念俱灰。</p><p>挫败是什么意思？书里最广为流传的话，不是那句<span style="color:#f25">“人可以被毁灭，但是不能被打败”</span>吗？这很正能量啊，完全可以打印出来或者制作成横幅挂在天安门广场，这完全就是社会主义核心价值观的映射啊。真的是这样吗？老人被打败了吗？还是被毁灭了? 我的阅读感受告诉我的恰恰相反，<span style="color:#195">我觉得老人被打败了，但没有被毁灭。</span> 我觉得这本书揭示了一个最最重要的事实就是：<span style="color:#f25">我们费劲一切努力终于成功了，可成功之后要面对才是真正的挑战。我们往往只关注一个人如何当上CEO 迎娶白富美走上人生巅峰这前半段，殊不知走上巅峰之后映入眼前的满眼都是下坡路….</span> 王子和灰姑娘终于在一起了，过上了幸福的生活。这是童话故事里的结局，王子和灰姑娘还要在一起生活几十年，真的就幸福圆满完美无缺吗？哈哈，生活真的很残酷。</p><p>鲁羊先生在后记中写道：一个作家，无论他用什么语言写作，若能写出一部人类之书，就是莫大的荣耀，这本书是海明威最后的绝唱。其中的意象和语言，精密和结实，壮阔而哀伤。这本书和其他真正的杰作一样，以一喻万，言之不能尽，思之不能竭。所谓真正的杰作，几乎就是这样一种物质，不能被分解，不能被改造，不能被提炼，它必须整体呈现。</p><p>我觉得上面这段话精彩至极。</p><p><span style="color:#195">※※   摘录部分    ※※</span></p><p>他是个老人，孑然一身，驾着小船，在墨西哥湾流中钓鱼，如今已经是连续第八十四天一无所获了。<br>老人睁开眼睛，那一瞬间，他好像从非常遥远的地方回来。</p><p>每一条船都驶向了他们认为有鱼的地方。</p><p>他记不起自己究竟什么时候开始，在独处的时候，大声对自己说话。</p><p>他回头望去，早已看不到陆地。<br>依靠哈瓦那的灯火，他总能顺利回港。</p><p>任何人到了老年，都不应该孤单。</p><p>他开始同情他钓到的这条大鱼，它既美妙又奇怪。</p><p>他大声说：“要是男孩在这儿就好了！”</p><p>“鱼啊”，他说，“我很爱你，也很尊重你。可是今天结束之前，我一定要杀死你。”</p><p>他放眼向海面上望去，发现自己此刻竟如此孤单。</p><p>那条鱼竭尽全力要对付的，只不过是我一个人的决心和智慧。</p><p>他认定，只要自己有足够的决心，就能打败所有人。</p><p>从他来到海上到现在，太阳正第三次升起来，而那鱼就在此时转起了圈子。当鱼转到第三圈，他看见了它。</p><p>我不过是凭着诡计才占了上风，而它对我却毫无恶意。</p><p>鲨鱼的出现并非偶然。</p><p>“它吃了差不多有四十多磅。”老人大声说。它还带走了我的鱼叉，他想。而且我的鱼现在又开始流血，会引来其他的鲨鱼。</p><p>他不想朝那条鱼再多看一眼，因为它已经残缺不全，当那条鱼遭到袭击的时候，就仿佛他自己遭到了袭击。<br><span style="color:#f25"><br>太美好的事情无法长久。<br>不过，人不是为失败而生的。<br>人可以被毁灭，但不能被打败。<br></span><br>世上每一种事物都以某种方式在杀死其他的事物。钓鱼这件事无疑在杀死我，同时让我活下来。</p><p>“它们吃掉了这条鱼的四分之一，而且都是最好的肉”，他大声说，“我真希望这是一场梦，我从来没有钓到过这条鱼。”</p><p>他不愿意去看那条大鱼。他知道，大鱼的一半已经被吃掉了。</p><p>他知道自己终于被打败，没有任何补救的余地了。</p><p>等他驶进小港，露台饭店的灯光全熄灭了，他知道所有的人都已经上床睡觉了。海风一步步加强，此刻刮得更猛了。港湾里却是静悄悄的，他将小船靠到礁岩处有鹅卵石的地方。没有人帮忙，他只能尽力将小船靠上去。然后他走下船来，将她牢牢地拴在一块岩石上。</p><p>他拔出桅杆，把帆卷起，扎好。然后他扛起桅杆，向岸上爬去，现在他才知道自己有多累。他驻足片刻，回头看去，在街灯反射过来的光线下，他看见那条大鱼的尾巴，壮观地树立在小船的船尾后面。他看见那鱼的脊骨像一条裸露的白线，还有黑暗一团的头部和向前伸出的细长的尖嘴，而在头尾之间，那鱼已是空无一物。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;tip&quot;&gt;按：大概十几年前就看过老人与海这本书，当时看完之后知道这本书讲了一个非常简单的故事：一位老人出海钓鱼，终于钓到一条大鱼后却被鲨鱼们夺走的故事。继而没什么印象了，在今年年初的时候看到&lt;code&gt;作家榜经典文库&lt;/code&gt;出了本鲁羊翻译的新版本就顺
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [06]-javaScript和this</title>
    <link href="https://weibo.com/u/3800117445/2018/05/12/javaScript%E7%B3%BB%E5%88%97%20%5B06%5D-javaScript%E5%92%8Cthis/"/>
    <id>https://weibo.com/u/3800117445/2018/05/12/javaScript系列 [06]-javaScript和this/</id>
    <published>2018-05-12T00:20:13.000Z</published>
    <updated>2018-05-18T06:28:20.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在<a href="http://wendingding.com/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20[01]-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/" target="_blank" rel="external">javaScript系列 [01]-javaScript函数基础</a>这篇文章中我已经简单介绍了JavaScript语言在函数使用中this的指向问题，虽然篇幅不长，但其实最重要的部分已经讲清楚了，这篇文章我们来单独谈一谈神秘的this，或者叫<code>怎么也搞不清楚的指天指地指空气的this</code>。</p></blockquote><h3 id="1-1-this简单说明"><a href="#1-1-this简单说明" class="headerlink" title="1.1 this简单说明"></a>1.1 this简单说明</h3><p><strong>this</strong>关键字被认为是JavaScript语言中最复杂的机制之一，跟this相关的知识很多开发者往往总是一知半解，更有甚者很多人完全搞不懂也不愿意去搞懂跟this相关的内容，在必须要用到的时候宁愿选择在代码中总是使用临时打印验证的方式来探知this的指向。这是现实，也许因为他们觉得跟this有关的这一切都混乱不堪，各种文档晦涩难懂，this的指向好似没有固定的套路，总是变来变去难以捉摸。其实，this原本并没有那么复杂，它就是个被自动定义在函数作用域中的变量，总是指向某个特定的“对象”。接下来，我们将尝试用这样一篇文章来讲清楚跟this有关的以下问题：</p><blockquote><p>❐   this 是什么？<br>❐   为什么要使用this?<br>❐   this指向谁？<br>❐   this绑定的几种情况<br>❐   this固定规则外的注意事项</p></blockquote><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;this是什么?&nbsp; &nbsp;</strong></span></p><p>在声明函数的时候，除了声明时定义的形式参数外，每个函数还接受两个附加的参数：<code>this</code>和<code>arguments</code>。其中arguments是一个类似于数组的结构，保存了函数调用时传递的所有实际参数，arguments这个参数让我们有能力编写<code>能够接受任意个数参数的</code>函数。参数this在面向对象编程中非常重要，它总是指向一个“特定的对象”，至于这个特定的对象是谁通常取决于函数的调用模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//默认指向window</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">           res += <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//调用sum函数的时候，this默认指向window</span></div><div class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">//计算输入参数的累加和，结果为10</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><p>现在我们知道和this有关的关键信息是：</p><p><span style="color:#F55">① this是JavaScript中所有函数的隐藏参数之一，因此每个函数中都能访问this。</span><br><span style="color:#F55">② 函数中的this总是指向一个特定对象，该对象具体取决于函数的调用模式。</span></p><div class="tip"><br>说明：在script标签中我们也可以直接访问this，它通常总是指向widow，我们讨论的this主要特指函数内部(函数体)的this。<br></div><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;为什么要使用this?&nbsp; &nbsp;</strong></span></p><p><span style="color:#F55">this提供一种更优雅的方式来隐士的传递一个对象引用，因为拥有this，所以我们可以把API设计得更加的简洁并且易于复用。简单点说，那就是this可以帮助我们省略参数。</span></p><p>我们可以通过以下两个代码片段来加深对this使用的理解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**代码 [ 01 ]**/</span></div><div class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">contentText</span>:<span class="string">"天王盖地虎 小鸡炖蘑菇"</span>&#125;;</div><div class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">"燕赤霞"</span>,<span class="attr">contentText</span>:<span class="string">"天地无极 乾坤借法 急急如令令"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(obj.name+<span class="string">"口诀是："</span> + getContentText(obj));;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj.contentText + <span class="string">"哒哒哒哒~"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">speak(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">speak(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div><div class="line"></div><div class="line">getContentText(personOne);</div><div class="line">getContentText(personTwo);</div></pre></td></tr></table></figure><p><strong>代码说明：</strong>上面的代码声明了两个函数：speak和getContentText，这两个函数都需要访问对象中的属性，上面的代码中每个函数都接收一个obj对象作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**代码 [ 02 ]**/</span></div><div class="line"><span class="keyword">var</span> personOne = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">contentText</span>:<span class="string">"天王盖地虎 小鸡炖蘑菇"</span>&#125;;</div><div class="line"><span class="keyword">var</span> personTwo = &#123;<span class="attr">name</span>:<span class="string">"燕赤霞"</span>,<span class="attr">contentText</span>:<span class="string">"天地无极 乾坤借法 急急如令令"</span>&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"口诀是："</span> + getContentText.call(<span class="keyword">this</span>));;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getContentText</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.contentText + <span class="string">"哒哒哒哒~"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">speak.call(personOne);  <span class="comment">//文顶顶口诀是：天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">speak.call(personTwo);  <span class="comment">//燕赤霞口诀是：天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div><div class="line"></div><div class="line">getContentText.call(personOne);  <span class="comment">//天王盖地虎 小鸡炖蘑菇哒哒哒哒~</span></div><div class="line">getContentText.call(personTwo);  <span class="comment">//天地无极 乾坤借法 急急如令令哒哒哒哒~</span></div></pre></td></tr></table></figure><p><strong>代码说明：</strong>完成相同的功能，还是两个同样的函数，区别在于我们借助this省略掉了函数必须要传递的对象参数，实现更优雅。而且如果你的代码越来越复杂，那么需要显式传递的上下文对象会让代码变得越来越混乱而难以维护，使用this则不会如此。</p><h3 id="1-2-函数和this"><a href="#1-2-函数和this" class="headerlink" title="1.2 函数和this"></a>1.2 函数和this</h3><p>this指向谁绑定给哪个对象并不是在编写代码的时候决定的，而是在运行时进行绑定的，它的上下文取决于函数调用时的各种条件 。<span style="color:F55">this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</span></p><p>当函数被调用时，会创建一个执行上下文。该上下文会包含一些特殊的信息，例如函数在哪里被调用，函数的调用方式，函数的参数等，this其实是该上下文中的一个属性，它指向谁完全取决于函数的调用方式。</p><p>现在我们已经弄明白了this最核心的知识：<span style="color:#F55">this的指向取决于函数的调用方式。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;函数基础&nbsp; &nbsp;</strong></span></p><p>在接着讲解之前，有必要对函数的情况进行简单说明，比如函数的创建、参数的传递、函数的调用以及返回值等等。</p><p><strong>函数的创建</strong><br>在开发中我们有多种方式来创建（声明）函数，可以使用function关键字直接声明一个具名函数或者是匿名函数，也可以使用Function构造函数来创建一个函数实例对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 function关键字声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"命名函数|具名函数"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"匿名函数"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'console.log("函数实例对象的函数体")'</span>);</div></pre></td></tr></table></figure></p><p><strong>函数的参数</strong><br>函数的参数有两种，一种是形式参数，一种是实际参数。</p><p><strong>形式参数</strong><br>在函数声明（创建）的时候，我们可以通过一定的方式来指定函数的参数，相当于在函数体内声明了对应的临时局部变量。</p><p><strong>实际参数</strong><br>在函数调用的时候，会把实际参数的值传递给形式参数，存在一个隐藏的赋值操作，实际参数就是函数调用时()中的参数。</p><p><strong>隐藏参数</strong><br>JavaScript中所有函数中均可以使用this和arguments这两个附加的隐藏参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[1] 函数的声明</span></div><div class="line"><span class="comment">//01 function关键字声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"命名函数|具名函数"</span>,<span class="string">"a的值:"</span> +a , <span class="string">"b的值:"</span>+b);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);      <span class="comment">//此处指向window全局对象</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//此处打印的是["f1的a","f1的b"]结构的数据</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="comment">//a和b为函数的形式参数，相当于在此处写上代码 var a,b;</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"匿名函数"</span>,<span class="string">"a的值:"</span> +a , <span class="string">"b的值:"</span>+b);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 Function构造函数创建函数实例对象</span></div><div class="line"><span class="comment">//a和b为新创建的函数对象的形式参数</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'console.log("函数实例对象的函数体","a的值:" +a , "b的值:"+b)'</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//[2] 函数的调用</span></div><div class="line"></div><div class="line"><span class="comment">//"f1的a"和"f1的b"这两个字符串作为f1函数此处调用传递的实际参数</span></div><div class="line"><span class="comment">//在调用函数的时候，会把"f1的a"这个字符串赋值给形参a,把"f1的b"这个字符串赋值给形参b</span></div><div class="line">f1(<span class="string">"f1的a"</span>,<span class="string">"f1的b"</span>);  <span class="comment">//命名函数|具名函数 a的值:f1的a b的值:f1的b</span></div><div class="line"></div><div class="line">f2(<span class="string">"f2的a"</span>,<span class="string">"f3的b"</span>);  <span class="comment">//匿名函数 a的值:f2的a b的值:f3的b</span></div><div class="line">f3(<span class="string">"f3的a"</span>,<span class="string">"f3的b"</span>);  <span class="comment">//函数实例对象的函数体 a的值:f3的a b的值:f3的b</span></div></pre></td></tr></table></figure><p><strong>函数调用</strong><br>函数名后面跟上调用运算符<code>[()]</code>的代码，我们称为函数调用，当函数被调用的时候，会把实参赋值给形参并自上而下的执行函数体中的代码。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;函数调用和this绑定&nbsp; &nbsp;</strong></span></p><p>因为this的绑定完全取决于函数的调用方式，所以要搞清楚this绑定问题只需要搞清楚函数调用方式即可，函数的调用方式通常来说有以下四种：</p><blockquote><p>❐   <span style="color:#f22">普通函数调用(默认绑定)</span><br>❐   <span style="color:#f22">对象方法调用(隐式绑定)</span><br>❐   <span style="color:#f22">构造函数调用(new绑定)</span><br>❐   <span style="color:#f22">函数上下文调用(显式绑定)</span></p></blockquote><p>函数的调用方式只有上面的四种情况，而要确定其具体的调用方式，需要先确定函数调用的位置。</p><p><strong>函数调用位置</strong><br>函数调用位置也就是函数在代码中被调用的位置<code>[函数名+()的形式]</code>，我们可以通过下面的示例代码来理解函数的调用位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>);</div><div class="line">    <span class="comment">//当前的函数调用栈：f1</span></div><div class="line">    f2();   <span class="comment">//函数f2调用的位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>);</div><div class="line">    <span class="comment">//当前函数调用栈:f1 --&gt; f2</span></div><div class="line">    f3();   <span class="comment">//函数f3调用的位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//当前函数调用栈:f1--&gt;f2--&gt;f3</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"f3"</span>);</div><div class="line">&#125;</div><div class="line">f1();       <span class="comment">//函数f1调用的位置</span></div></pre></td></tr></table></figure></p><h3 id="1-3-this绑定浅析"><a href="#1-3-this绑定浅析" class="headerlink" title="1.3 this绑定浅析"></a>1.3 this绑定浅析</h3><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;① 普通函数调用(默认绑定) &nbsp; &nbsp;</strong></span></p><p><code>普通函数调用</code>就是函数名后面直接更上调用运算符调用，这种情况下函数调用时应用了this的默认绑定，如果是在非严格模式下，该this指向全局对象window，如果是在严格模式下，不能将全局对象用于默认绑定，该this会绑定到undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明全局变量 t</span></div><div class="line"><span class="keyword">var</span> t = <span class="number">123</span>;           <span class="comment">//所有全局变量自动成为全局对象的属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>); <span class="comment">//foo</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">//this ---&gt; 全局对象window</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.t);<span class="comment">//123</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">foo();  <span class="comment">//非严格模式下:以普通函数方式调用</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span>;      <span class="comment">//作用域开启严格模式</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"fn"</span>); <span class="comment">//fn</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//this ---&gt;undefined</span></div><div class="line">    <span class="comment">//Uncaught TypeError: Cannot read property 't' of undefined</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.t);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn();  <span class="comment">//严格模式下:以普通函数方式调用</span></div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/this_01.png?raw=true"></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;② 对象方法调用(隐式绑定) &nbsp; &nbsp;</strong></span></p><p><code>对象方法调用</code>又称为隐式绑定，当函数引用有上下文对象的时候，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。需要注意的是，如果存在引用链，那么只有对象属性引用链中的最后一层在调用位置中起作用，下面我们通过一个代码片段来理解这种调用方式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"wenidngding"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//普通函数调用，函数中的this默认绑定到全局对象，打印wendingding</span></div><div class="line">showName();</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"小猪佩奇"</span>,</div><div class="line">    showName:showName</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj,打印小猪佩奇</span></div><div class="line">obj.showName();</div></pre></td></tr></table></figure></p><p><strong>上下文对象</strong></p><p>上下文对象可以简单理解为函数调用时该函数的拥有者，或者引用当前函数的对象。</p><p><strong>this丢失的问题</strong></p><p>我们在确定this绑定问题的时候不能一根筋的把<code>该函数是否是对象的方法</code>作为判断的准则，而要抓住问题的本质，而且代码中可能存在this隐式绑定丢失的问题。外在的所有形式其实都不重要，最根本的就是看函数调用的时候，用的是什么方式？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//字面量方式创建对象，该对象拥有name属性和showName方法</span></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name:<span class="string">"小猪佩奇"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(001)</span></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj1,打印小猪佩奇</span></div><div class="line">obj1.showName();</div><div class="line"></div><div class="line"><span class="comment">//[1] 把obj.showName方法赋值给其他的对象</span></div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"阿文"</span>&#125;;</div><div class="line">obj2.show = obj1.showName;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(002)</span></div><div class="line"><span class="comment">//对象方法调用，函数中的this绑定到当前的上下文对象obj2,打印阿文</span></div><div class="line">obj2.show();</div><div class="line"></div><div class="line"><span class="comment">//[2] 把obj.showName方法赋值给一个变量</span></div><div class="line"><span class="keyword">var</span> fn = obj1.showName;</div><div class="line"></div><div class="line"><span class="comment">//调用位置(003)</span></div><div class="line"><span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></div><div class="line"><span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></div><div class="line">fn();</div><div class="line"></div><div class="line"><span class="comment">//[3] 把obj.showName方法作为其他函数的参数（回调函数）来使用</span></div><div class="line"><span class="comment">//声明函数，该函数接收一个函数作为参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">callBack</span>) </span>&#123;</div><div class="line">    <span class="comment">//调用位置(004)</span></div><div class="line">    <span class="comment">//普通函数调用，函数中的this指向全局对象，打印空字符串（window.name属性值是空字符串）</span></div><div class="line">    <span class="comment">//注意：函数调用方式发生了改变，this丢失了</span></div><div class="line">    callBack();</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用位置(005) 此处不涉及this</span></div><div class="line">foo(obj1.showName);</div></pre></td></tr></table></figure></p><p><span style="color:#F55"><strong>➤ 思考：能否缩短对DOM操作相关的方法？</strong></span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">"demoID"</span>)); <span class="comment">//正确</span></div><div class="line"></div><div class="line"><span class="comment">//声明getById函数，该函数指向document.getElementById方法</span></div><div class="line"><span class="keyword">var</span> getById = <span class="built_in">document</span>.getElementById;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(getById(<span class="string">"demoID"</span>));<span class="comment">//报错：Uncaught TypeError: Illegal invocation</span></div></pre></td></tr></table></figure></p><p><strong>代码说明</strong> 有的朋友可能尝试过像上面这样来写代码，发现通过这样简单的处理想要缩短DOM操作相关方法的方式是不可取的，为什么会报错？原因在于document.getElementById方法内部的实现依赖于this，而上面的代码<code>偷换了函数的调用方式，函数的调用方式由对象方法调用转变成了普通函数调用，this绑定的对象由document变成了window</code>。</p><p>怎么解决呢，可以尝试使用显式的绑定指定函数内的this，参考代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getById = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//显式的设置document.getElementById函数内部的this绑定到document对象</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.getElementById.apply(<span class="built_in">document</span>,<span class="built_in">arguments</span>)</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(getById(<span class="string">"demoID"</span>));  <span class="comment">//正确</span></div></pre></td></tr></table></figure></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;③ 构造函数调用(new绑定) &nbsp; &nbsp;</strong></span><br><code>构造函数方式调用</code>其实就是在调用函数的时候使用new关键字，这种调用方式主要用于创建指定构造函数对应的实例对象。</p><p><strong>构造函数</strong><br>构造函数就是普通的函数，本身和普通的函数没有任何区别，其实构造函数应该被称为<code>以构造方式调用的函数</code>，这样也许会更准确一些。因为在调用的时候总是以new关键字开头<code>[例如：new Person() ]</code>，所以我们把像Person这样的函数叫做构造函数。虽然构造函数和普通函数无异，但因为它们调用的直接目的完全不同，为了人为的区分它们，开发者总是约定构造函数的首字母大写。</p><p>当函数被以普通方式调用的时候，会完成实参向形参的赋值操作，继而自上而下的执行函数体中的代码，当构造函数被调用的时候，目的在于获得对应的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明一个Person函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Perosn</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">" 年龄："</span> + <span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(001)</span></div><div class="line"><span class="comment">//构造函数方式调用(new绑定) Person函数内部的this指向新创建的实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Perosn(<span class="string">"zs"</span>,<span class="number">18</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(002)</span></div><div class="line"><span class="comment">//对象方法的方式调用(隐式绑定) show方法内部的this指向的是引用的对象，也就是p1</span></div><div class="line"><span class="comment">//打印：姓名：zs 年龄：18</span></div><div class="line">p1.show();</div></pre></td></tr></table></figure><p><strong>构造函数内部细节</strong></p><p>使用new以构造函数的方式来调用Person的时候，内部主要做以下操作</p><blockquote><p>① 创建空的Object类型的实例对象，假设为对象o<br>② 让函数内部的this指向新创建的实例对象o<br>③ 设置实例对象o的原型对象指向构造函数默认关联的原型对象<br>④ 在函数内通过this来添加属性和方法<br>⑤ 在最后默认把新创建的实例对象返回</p></blockquote><p><strong>总结</strong> <span style="color:#f55">如果以构造函数方式调用，函数内部的this绑定给新创建出来的实例对象。</span></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;④ 函数上下文调用(显式绑定) &nbsp; &nbsp;</strong></span><br>在开发中我们可以通过call()或者是apply()方法来显式的给函数绑定指定的this，使用call或者是apply方法这种调用方式我们称为是函数上下文调用。</p><p>JavaScript语言中提供的绝大多数函数以及我们自己创建的所有函数都可以使用call和apply方法，这两个方法的作用几乎完全相同，只有传参的方式有细微的差别。</p><p><strong>call方法和apply方法的使用</strong></p><p>作用：借用对象的方法并显式绑定函数内的this。<br>语法：<code>对象.方法.call(绑定的对象，参数1，参数2...) | 对象.方法.apply(绑定的对象，[参数1，参数2...])</code></p><p>使用代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">    name:<span class="string">"zs"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名 "</span> + <span class="keyword">this</span>.name,a, b);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">name</span>:<span class="string">"ls"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(001)</span></div><div class="line"><span class="comment">//以对象方法的方式调用函数，函数内部的this指向引用对象，也就是obj1</span></div><div class="line"><span class="comment">//打印结果为：姓名 zs 1 2</span></div><div class="line">obj1.showName(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(002)</span></div><div class="line"><span class="comment">//obj2对象并不拥有showName方法，此处报错：obj2.showName is not a function</span></div><div class="line"><span class="comment">//obj2.showName();</span></div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(003)</span></div><div class="line"><span class="comment">//函数上下文的方式(call)调用函数，函数内部的this绑定给第一个参数obj2</span></div><div class="line"><span class="comment">//打印结果为：姓名 ls 哈哈 嘿嘿</span></div><div class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></div><div class="line"><span class="comment">//其它的参数：哈哈和嘿嘿这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></div><div class="line">obj1.showName.call(obj2,<span class="string">"哈哈"</span>,<span class="string">"嘿嘿"</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数调用位置(004)</span></div><div class="line"><span class="comment">//函数上下文的方式(apply)调用函数，函数内部的this绑定给第一个参数obj2</span></div><div class="line"><span class="comment">//打印结果为：姓名 ls 呵呵 嘎嘎</span></div><div class="line"><span class="comment">//第一个参数：obj2指定函数内this的绑定对象</span></div><div class="line"><span class="comment">//其它的参数：呵呵和嘎嘎这两个字符串是传递给showName函数的实参，调用时会赋值给函数的形参：a和b</span></div><div class="line">obj1.showName.apply(obj2,[<span class="string">"呵呵"</span>,<span class="string">"嘎嘎"</span>]);</div></pre></td></tr></table></figure></p><p><strong>总结</strong> <span style="color:#f55">如果以函数上下文的方式来调用，函数内部的this绑定call或者是apply方法的第一个参数，如果该参数不是对象类型那么会自动转换为对应的对象形式。</span></p><h3 id="1-4-this的注意事项"><a href="#1-4-this的注意事项" class="headerlink" title="1.4 this的注意事项"></a>1.4 this的注意事项</h3><p>我们已经介绍了一般情况下this绑定的问题，虽然上面的规则可以适用绝大多数的代码场景，但也并非总是百分百如此，也有例外。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ① &nbsp; &nbsp;</strong></span></p><p>在使用call或者apply方法的时候，<span style="color:#F55">非严格模式下如果我们传递的参数是null或者是undefined，那么这些值在调用的时候其实会被忽略，this默认绑定的其实是全局对象。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**[代码 01]**/</span></div><div class="line"><span class="comment">//声明全局变量用于测试</span></div><div class="line">   <span class="keyword">var</span> name = <span class="string">"测试的name"</span>;</div><div class="line">   <span class="keyword">var</span> obj1 = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"姓名 "</span> + <span class="keyword">this</span>.name,a, b);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="comment">//注意：虽然此处以上下文的方式调用，但是因为传递的第一个参数是null,实际这里应用的是默认绑定规则</span></div><div class="line">   obj1.showName.call(<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>);       <span class="comment">//姓名 测试的name 1 2</span></div><div class="line">   obj1.showName.call(<span class="literal">undefined</span>,<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//姓名 测试的name 1 2</span></div></pre></td></tr></table></figure><p>严格模式下，传递null或者是undefined作为call和apply方法的第一个参数，this的绑定和上下文调用保持一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**[代码 02]**/</span></div><div class="line"><span class="comment">//开启严格模式</span></div><div class="line"><span class="meta">   "use strict"</span>;</div><div class="line"></div><div class="line">   <span class="comment">//声明全局变量用于测试</span></div><div class="line">   <span class="keyword">var</span> obj = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   obj.showName.call(<span class="literal">null</span>);        <span class="comment">//null</span></div><div class="line">   obj.showName.apply(<span class="literal">undefined</span>);  <span class="comment">//undefined</span></div><div class="line"></div><div class="line"><span class="comment">//建议的处理方式</span></div><div class="line">obj.showName.apply(<span class="built_in">Object</span>.create(<span class="literal">null</span>));</div></pre></td></tr></table></figure></p><p><strong>建议</strong> 以前我们在以函数上下文方式来调用函数的时候，如果并不关心函数内部的this绑定，那么一般会传递null值或者undefined值。如果这样的话，在非严格模式下，函数内部的this默认绑定给全局对象并不安全，建议传递空对象[<code>可以使用Object.create(null)方式创建</code>]，这样函数操作会更安全而且代码可读性会更好。</p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ② &nbsp; &nbsp;</strong></span></p><p>ES6中推出了一种特殊的函数类型：箭头函数。箭头函数使用<code>=&gt;操作符</code>来定义，需要注意的是箭头函数内部的this绑定并不适用于既定的四种规则，this的绑定由外层作用域来决定。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"fn"</span>,<span class="keyword">this</span>);</div><div class="line">    <span class="comment">//fn函数中返回一个箭头函数</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"zs"</span>&#125;;</div><div class="line"><span class="comment">//fn以普通函数方式调用，fn中的this指向全局对象</span></div><div class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向window</span></div><div class="line">fn()();</div><div class="line"></div><div class="line"><span class="comment">//fn以函数上下文方式调用，fn中的this指向对象o</span></div><div class="line"><span class="comment">//箭头函数中的this绑定由外部的词法作用域来决定,this指向对象o</span></div><div class="line">fn.call(o)(); <span class="comment">//this指向&#123;name:"zs"&#125;对象</span></div></pre></td></tr></table></figure></p><p><span style="border:1px solid #000"><strong>&nbsp; &nbsp;例外的情况 ③ &nbsp; &nbsp;</strong></span></p><p>需要特别注意的是：在代码中我们可能会创建函数的“间接引用”，这种情况下调用函数会使用默认绑定规则。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objA = &#123;</div><div class="line">       name:<span class="string">"zs"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> objB = &#123;<span class="attr">name</span>:<span class="string">"ls"</span>&#125;;</div><div class="line">   objA.showName();                <span class="comment">//对象方法调用，this指向objA 打印zs</span></div><div class="line"></div><div class="line">   (objB.showName = objA.showName)(); <span class="comment">//打印 空字符串</span></div></pre></td></tr></table></figure></p><p><strong>代码说明</strong> 我们重点看最后一行代码，赋值表达式<code>objB.showName = objA.showName</code>的返回值是目标函数的引用，这种<code>间接引用</code>调用方式符合普通函数调用的规则，this会被绑定给全局对象。最后一行代码，拆开来写的形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = objB.showName = objA.showName;</div><div class="line">   f(); <span class="comment">//打印 空字符串</span></div></pre></td></tr></table></figure></p><h3 id="1-5-this绑定总结"><a href="#1-5-this绑定总结" class="headerlink" title="1.5 this绑定总结"></a>1.5 this绑定总结</h3><p>当函数的调用位置确定后，我们可以顺序应用下面的四条规则来判断this的绑定对象</p><blockquote><p>① 是否由new调用？ 如果是，则绑定到构造函数新创建的实例对象身上。<br>② 是否由call或者apply调用？如果是，则绑定到第一个参数指定的对象身上。<br>③ 是有作为对象的方法调用？如果是，则绑定到这个引用的对象身上。<br>④ 默认普通函数调用，如果是严格模式则绑定到undefined，否则绑定到全局对象。</p></blockquote><p><img src="https://github.com/flowerField/Source/blob/master/Blog/this_02.png?raw=true"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://wendingding.com/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20[01]-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络编程系列 同源策略和跨域请求</title>
    <link href="https://weibo.com/u/3800117445/2018/05/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97%20%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%92%8C%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>https://weibo.com/u/3800117445/2018/05/11/网络编程系列 同源策略和跨域请求/</id>
    <published>2018-05-11T02:05:13.000Z</published>
    <updated>2018-05-18T15:11:19.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-同源策略"><a href="#1-1-同源策略" class="headerlink" title="1.1 同源策略"></a>1.1 同源策略</h3><h4 id="1-1-1-同源策略说明"><a href="#1-1-1-同源策略说明" class="headerlink" title="1.1.1 同源策略说明"></a>1.1.1 同源策略说明</h4><p><strong>同源策略(Same Origin Policy)</strong>是一种约定，它是浏览器最核心也最基本的安全策略。可以说web是构建在同源策略的基础上的，浏览器只是针对同源策略的一种具体实现。</p><p>同源策略是浏览器实施的一种关键机制，主要用于防止不同来源的内容相互干扰产生安全问题。简单说，就是某个站点(源)可以读写从该站点(源)收到的信息，但是不得访问从其它站点(源)收到的信息，浏览器只允许相同来源的内容进行交互。</p><div class="tip">不使用同源策略的安全问题？</div><p>若不使用同源策略，那么当不知情的用户访问恶意网站的时候，该网站上运行的脚本将能够通过一定方式来访问这名用户同时访问的任何其他网站的数据和功能。<code>[用户在浏览器当前打开的其他页面中可能已经处理登录状态，脚本可以直接获取对应的Cookie数据或登录令牌发送对应网络请求。]</code> 这样的话，该恶意网站将可以操作用户的账户转账、阅读邮件列表等信息，存在巨大的安全风险。</p><p><strong>同源策略</strong>的主要特点</p><blockquote><p> ❐  指定域的页面可以向另一个域提出任意数量的请求，但是该页面本身无法处理返回的数据。<br> ❐  指定域的页面可以通过某些标签加载其它域的脚本并执行该脚本。<br> ❐  指定域的页面无法读取或修改其它域的cookie或DOM数据。</p></blockquote><p>目前，同源策略限制以下三种行为</p><blockquote><p> ❐  DOM  的读取操作。<br> ❐  AJAX 请求的发送。<br> ❐  Cookie、LocalStorage 和 IndexDB 的读取操作。</p></blockquote><p><strong>注意  </strong>Ajax在发送跨域请求的时候，其实请求是发出去的，只是服务器返回的响应(response)被浏览器阻塞了，即使是返回码也获取不到。</p><p><span style="color:red">同源策略其实是限制了不同源的读，但是并不限制不同源的写。</span></p><div class="tip">为什么不限制不同源的写操作？</div><p>因为如果连请求都发不出去，相当于在源头上就限制死各网站间无法共享资源了,而且仅仅限制读操作，也就是浏览器拦截跨域网络请求的响应结果一般来说就足够了,限制读但是不限制写这样的处理方式更灵活。</p><h4 id="1-1-2-同源策略和Ajax请求"><a href="#1-1-2-同源策略和Ajax请求" class="headerlink" title="1.1.2 同源策略和Ajax请求"></a>1.1.2 同源策略和Ajax请求</h4><p><div class="tip">如何确定是否同源？</div></p><blockquote><p> ❐  协议相同<br> ❐  域名相同<br> ❐  端口相同<br><code>协议 + 域名 + 端口号</code>完全相同则认为是同源的，否则认为是不同源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">http://www.baidu.com/123.png            target</div><div class="line">http://www.baidu.com/456.png            同源</div><div class="line">http://www.baidu.com:800/login.html     跨域(端口号不同)</div><div class="line">https://www.baidu.com/456.png           跨域(协议不同)</div><div class="line">http://bbs.baidu.com   跨域(子域名不同)</div><div class="line">http://www.taobao.com 跨域(域名不同)</div></pre></td></tr></table></figure></p></blockquote><p>下面给出示例代码发送跨域网络请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当前路径：http://localhost:63342/..demo.html</span></div><div class="line"><span class="comment">//请求路径：http://www.baidu.com</span></div><div class="line">$.ajax(&#123;</div><div class="line">       <span class="string">"url"</span>:<span class="string">"http://www.baidu.com"</span>,</div><div class="line">       <span class="string">"type"</span>:<span class="string">"get"</span>,</div><div class="line">       <span class="string">"success"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res,status,xhr</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(res);</div><div class="line">       &#125;,</div><div class="line">       <span class="string">"error"</span>:<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(res);</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p><p><strong>网络请求结果</strong><br><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_01.png?raw=true" height="200"><br>通过调试发现，该请求确实发送出去甚至收到了服务器返回的响应头信息，但无法获取响应体数据。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_02.png?raw=true"><br>具体报错信息显示：<span style="color:#F44">No ‘Access-Control-Allow-Origin’ header …`</span>意思就是当前域名无法跨域向<a href="http://www.baidu.com" target="_blank" rel="external">www.baidu.com</a>请求数据。</p><h3 id="1-2-跨域请求"><a href="#1-2-跨域请求" class="headerlink" title="1.2 跨域请求"></a>1.2 跨域请求</h3><p>在开发中，有时候我们自己的站点需要向其他站点发送网络请求获取服务或某些特定的资源，这就需要跨域发送网络请求。</p><p>跨域网络请求有多种方式来实现，比较常见的是：<code>跨域资源共享( CORS )和jsonP</code>。</p><h4 id="1-2-1-跨域资源共享-CORS"><a href="#1-2-1-跨域资源共享-CORS" class="headerlink" title="1.2.1 跨域资源共享(CORS)"></a>1.2.1 跨域资源共享(CORS)</h4><p>CORS是一个W3C标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。<br>它允许浏览器向跨域的服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p><p>实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信，实现方式非常简单，只需要在请求的响应头中设置<code>Access-Control-Allow-Origin</code>字段即可。该字段的值可以设置为指定的域，表明允许该指定的域向服务器发送跨域网络请求，也可以设置为*，表示允许任何的域向服务器发送网络请求。</p><p>下面给出php服务器端的响应头设置代码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 允许所有其他域名访问</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: *"</span>);</div><div class="line"></div><div class="line"><span class="comment"># 允许指定域名跨域访问</span></div><div class="line">header(<span class="string">"Access-Control-Allow-Origin: http://www.wendingding.com"</span>);</div></pre></td></tr></table></figure></p><p>实现细节请参考：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">阮一峰：跨域资源共享 CORS 详解</a></p><p><strong>特别注意</strong> <span style="color:red">跨域请求的时候，请求和响应都不包含Cookie数据</span>。</p><h4 id="1-2-2-JSONP"><a href="#1-2-2-JSONP" class="headerlink" title="1.2.2 JSONP"></a>1.2.2 JSONP</h4><p>jsonP是<code>JSON with padding</code>(参数式JSON)的简写，是一种常见的跨域网络请求方案。jsonP和JSON类似，只是把真正要返回给客户端的json数据以特定的方式放在函数调用中作为参数传递。</p><p>jsonP方案利用了script标签可以跨越的特点，通过设置script标签的src属性为特定的请求路径来绕过同源访问策略。</p><p>jsonP由两部分组成：<span style="color:red">回调函数参数、特定的JSON数据</span></p><p><strong>jsonP的基本结构</strong></p><blockquote><p>① 在页面的script标签中声明回调函数，该回调函数接收参数（需要和响应对应）。<br>② 在页面中动态的创建script标签，并为标签的src属性指定跨域的URL路径。<br>③ 跨域的URL路径中应该附带回调函数参数，例如 <code>http://www.xx.com?cb = fn</code><br>④ 服务器端接收到响应后返回特定格式的数据,例如：<code>fn({&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18})</code><br>⑤ 客户端script标签加载跨域路径对应的数据，其实是执行了函数调用，把服务器返回的<code>真正数据</code>作为参数传递给声明的回调函数。</p></blockquote><p>代码示例（使用百度搜索结果）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"oText"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(obj);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> oUl = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>)||<span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span></div><div class="line"><span class="javascript">        oUl.innerHTML = <span class="string">""</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> arrM = obj[<span class="string">"s"</span>];</span></div><div class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arrM.length;i++)</span></div><div class="line"><span class="undefined">        &#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">var</span> oLi = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></div><div class="line"><span class="undefined">            oLi.innerText = arrM[i];</span></div><div class="line"><span class="undefined">            oUl.appendChild(oLi);</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(oUl);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> oText = <span class="built_in">document</span>.querySelector(<span class="string">"#oText"</span>);</span></div><div class="line"><span class="javascript">    <span class="built_in">console</span>.log(oText);</span></div><div class="line"><span class="javascript">    oText.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> temp = <span class="built_in">document</span>.querySelector(<span class="string">"#jsonP"</span>);</span></div><div class="line"><span class="javascript">        <span class="keyword">if</span>(temp) <span class="built_in">document</span>.body.removeChild(temp);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> text = oText.value;</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span></div><div class="line"><span class="javascript">        <span class="keyword">var</span> url = <span class="string">"https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd="</span>+text+<span class="string">"&amp;cb=fn"</span>;</span></div><div class="line"><span class="javascript">        oScript.setAttribute(<span class="string">"src"</span>,url);</span></div><div class="line"><span class="javascript">        oScript.setAttribute(<span class="string">"id"</span>,<span class="string">"jsonP"</span>);</span></div><div class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(oScript);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/ty_03.png?raw=true"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1-同源策略&quot;&gt;&lt;a href=&quot;#1-1-同源策略&quot; class=&quot;headerlink&quot; title=&quot;1.1 同源策略&quot;&gt;&lt;/a&gt;1.1 同源策略&lt;/h3&gt;&lt;h4 id=&quot;1-1-1-同源策略说明&quot;&gt;&lt;a href=&quot;#1-1-1-同源策略说明&quot; cla
      
    
    </summary>
    
    
      <category term="网络编程系列" scheme="https://weibo.com/u/3800117445/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记 [005]-牧羊少年奇幻之旅</title>
    <link href="https://weibo.com/u/3800117445/2018/05/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%5B005%5D-%E7%89%A7%E7%BE%8A%E5%B0%91%E5%B9%B4%E5%A5%87%E5%B9%BB%E4%B9%8B%E6%97%85/"/>
    <id>https://weibo.com/u/3800117445/2018/05/08/读书笔记 [005]-牧羊少年奇幻之旅/</id>
    <published>2018-05-08T00:08:18.000Z</published>
    <updated>2018-05-18T02:20:40.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>无疑，这是一本非常牛B的📚，至少在我的阅读经验里如此。此时，我将写下一篇冗长的阅读笔记，记录我对它的感觉以及探索。在这篇文章里，我将以<code>基本故事</code>、<code>奇幻之旅</code>、<code>后记</code>的结构来进行组织，另外，致敬保罗·柯艾略。</p></blockquote><h4 id="第一部分-基本故事"><a href="#第一部分-基本故事" class="headerlink" title="第一部分 基本故事"></a>第一部分 基本故事</h4><p><strong>书籍信息</strong></p><p>作品：<a href="https://book.douban.com/subject/3608208/" target="_blank" rel="external">牧羊少年奇幻之旅</a><br>作者：[保罗·柯艾略]<br>翻译：<a href="https://book.douban.com/subject_search?search_text=%E4%B8%81%E6%96%87%E6%9E%97" target="_blank" rel="external">丁文林</a><br>定价：RMB 35：00<br>出版社：北京十月文艺出版社</p><p>全书结构：<code>自序 - 引子 - 上部 - 下部 -尾声</code><br>特别说明：<code>献给J. 一位通晓并利用元精秘密的炼金术士。</code><br>全书人物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">圣地亚哥（牧羊人）</div><div class="line">纺织店老板和他的女儿</div><div class="line">爆米花少年</div><div class="line">撒冷之王</div><div class="line">吉普赛老妇人</div><div class="line">水晶店老板</div><div class="line">英国人</div><div class="line">港口遇到的骗子少年</div><div class="line">法蒂玛（沙漠中的女人）</div><div class="line">200多岁的炼金术士</div><div class="line">部落军队首领</div><div class="line">金字塔前的俩流氓</div><div class="line">赶驼人</div><div class="line">商队领队...等</div></pre></td></tr></table></figure></p><p>全书地名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">西班牙地区（安达卢西亚）（塔里法镇）</div><div class="line">非洲（丹吉尔港口）（沙漠）（绿洲）（埃及金字塔）</div></pre></td></tr></table></figure></p><p><strong>重要标记 ✤</strong> 破庙  羊群 宝石 书籍 宝剑 绿洲 水井 水晶店 鹰 眼镜蛇 财宝 金子 无花果树 炉子 骆驼 马…</p><p><span style="color:#74B884">（自序部分）</span></p><p>开篇第一句：《牧羊少年奇幻之旅》是一部具有象征意义的作品。保罗花了些笔墨说明自己炼金术士的身份，并直接写明该部作品转述了自己所学到的一切，顺带向其他理解了宇宙语言的作家们致敬。在最后的篇幅中，有一个很有意思的故事，是关于圣母怀抱小耶稣降临人间并造访一座修道院的，最后圣母把手伸向了一位很不起眼的神甫，让他抱了抱小耶稣。</p><p><span style="color:#74B884">（引子部分）</span></p><p>引子部分讲述了炼金术士读到的一个关于水仙花的故事。湖泊和山林女神有一段关于水仙少年的对话，精彩至极。这部分的故事，其实我没有完全弄清楚。</p><p><span style="color:#74B884">（正文部分）</span></p><p>正文部分讲解了牧羊人因为一个重复的梦，进而一步一步踏上未知的旅程，追寻财宝的奇幻之旅。牧羊人圣地亚哥总是赶着羊群在一座长着棵巨大无花果树的破庙中过夜，起初他因为总是重复同一个梦而困惑，原计划到四天路程远的小镇去撸羊毛卖顺便见见心仪的女孩，在中途的时候他请求一个吉普赛老妇人给自己解梦并付出了未来财富1/10的代价，继而又遇见了撒冷之王…踏上了寻找财富的奇幻之旅。</p><p>圣地亚哥的旅途主要分几个阶段：<br><img src="https://github.com/flowerField/Source/blob/master/Blog/muyangren.png?raw=true"></p><h4 id="第二部分-奇幻之旅（摘要）"><a href="#第二部分-奇幻之旅（摘要）" class="headerlink" title="第二部分 奇幻之旅（摘要）"></a>第二部分 奇幻之旅（摘要）</h4><div style="color:green; font-size:18px">※※   自序  ※※</div><p>《牧羊少年奇幻之旅》是一部具有象征意义的作品。</p><p>我结识了许多自诩为炼金术士的人，他们拥有自己的实验室，并许诺教给我炼金术的秘诀，条件是向他们支付大笔的金钱。现在我才明白，他们打算教给我的东西，他们自己却一窍不通。</p><p>我所有的努力都付诸东流。<br><span style="color:red; ">上帝有时很严厉，却也无限慷慨。</span><br>很显然，元精并非总装在一只小瓶子里，以泡在液体中的卵状物形式出现，毫无疑问，我们大家都能够探摸到世界灵魂。</p><div style="color:green; font-size:18px">※※   牧羊·云游四方   ※※</div><p><span style="border:1px solid #000"><code>牧羊人 羊群 教堂 无花果树 书 梦 商人的女儿</code></span></p><p>这个男孩名叫<span style="border:1px solid #666">圣地亚哥</span>。夜幕降临时，圣地亚哥赶着羊群来到一座废弃的老教堂前。很久以前，教堂的屋顶就塌掉了。原来圣器室的位置长出了一棵高大的无花果树。</p><p>读书能消磨更多的时间，夜间当枕头用也更舒服。</p><p>“我以前以为牧羊人不会读书。”一个<span style="border:1px solid #666">少女</span>的声音在他的身旁响起。<br>“既然会读书识字，为什么还要当牧羊人呢？”<br>男孩随便岔开了话题，没有回答。他确信这个问题女孩永远无法理解。</p><p>天刚破晓，圣地亚哥便赶着羊群朝日出的方向走去。这些羊永远不需要拿什么主意。他想，也许这就是它们一直跟在我身边的原因。<span style="color:red; ">羊群唯一需要的就是食物和水。只要他知道安达卢西亚最好的草场，羊群就将永远跟随他。即使日复一日在日出日落之间苦熬，即使在其短暂的一生中从未读过一本书，也不懂人的语言，听不懂人们讲述的新鲜事，只要有水和食物，它们就心满意足。作为回报，他们慷慨地献出羊毛，心甘情愿的陪伴着牧羊人，时不时还奉献出自己的肉。</span><br> 如果我变成魔鬼，决定把它们一只接一只杀死，它们也只在整个羊群几乎被杀光的时候才会有所察觉，男孩想。因为它们相信我，而忘记了它们自己的本能。这只是因为我能引领它们找到食物。</p><p>男孩对自己的这些念头感到惊讶。</p><p>父母希望他称为神甫，称为一个普通农家的骄傲，而他们一生只为吃喝忙碌，就像圣地亚哥的羊群。他学过拉丁文、西班牙文和神学。<span style="color:#195; ">但是，从孩提时代起，他就梦想着了解世界，这远比了解上帝以及人类的罪孽来得重要。</span></p><p>“拿去买一群羊，云游四方吧。总有一天，你会懂得，我们的家园才最有价值，我们这儿的女人才最漂亮。” <span style="border:1px solid #666">父亲</span>祝福了他。从父亲的目光中，男孩看出，父亲也想云游四方。</p><p><span style="border:1px solid #195;color:red">All ※ ※</span>他有一群羊，一件外衣和一本书，用这本书可以换来另外一本书。不过最重要的是，他每天都在实现自己人生的最大梦想：云游四方。</p><p>圣地亚哥望着冉冉升起的太阳想，不知道神学院的人是如何寻找上帝的。</p><p><span style="color:red; ">羊群不会察觉它们每天都在走新路，不会发现草场在变化，四季有区别。因为它们一门心思想着喝水吃草。</span></p><p>也许我们大家全都如此。圣地亚哥想，我就是这样，自从认识那个商人的女儿，我就再也没有想过别的女人。</p><p>恰恰是实现梦想的可能性，才使生活变得有趣。</p><p><span style="border:1px solid #000"><code>塔里法的老妇人 解梦</code></span></p><p>他突然想起一位住在塔里法的老妇人，她会解梦。</p><div style="color:green; font-size:18px">※※   解梦  ※※</div><p>“突然间，他抓住了我的手，带着我去了埃及金字塔。那个小孩当时对我说，假如你来到这里，将会找到一处隐秘的宝藏。”就在他要把藏宝的具体地点告诉我的时候，我却醒了。两次的梦都是如此。</p><p>“目前，我不收你任何费用。” <span style="border:1px solid #666">老妇人</span>开口道，“但是，如果你找到了那些财宝，我想要其中的十分之一。”男孩笑了，他很开心。仅仅由于那个梦涉及财宝，他眼下就不必破费了！老妇人大概是个吉普赛人。吉普赛人都很愚蠢。</p><p>“你得先发誓。发誓把财宝的十分之一给我作为交换，我就给你解梦。”<br>简单的事情往往最异乎寻常，只有智者才能看透。</p><p><span style="color:red; "><br>“那么，我怎样才能到埃及呢？”<br>“我只管解梦，不会把梦变成现实。”<br>“如果我到不了埃及呢？”<br>“那我就拿不到酬金了。这是常事”<br></span></p><p>圣地亚哥失望的走了，他决定永远不再相信梦。<br>他用手上的书换了一本更厚的书。</p><p>对于该怎样生活，所有人都有固定的观念。但是他们对于自己该怎样生活却一头雾水，就像那个给人解梦，却不会把梦变成现实的老妇人。</p><p>他开始阅读那本从塔里法神甫手上换来的书。这是一本很厚的书，开卷第一页讲的是一场葬礼，人物的名字十分复杂。</p><div style="color:green; font-size:18px">※※   撒冷之王  ※※</div><p><span style="color:red; ">这本书和几乎所有的书一样，讲的是同一个道理，人们无法选择自己的命运。它要使大家相信这个世上最大的谎言。</span></p><p><span style="border:1px solid #000"><code>撒冷之王 广场 掘矿工人 爆米花少年 羊群的十分之一 天命 神秘力量</code></span></p><p>“什么是世界上最大的谎言？” 男孩吃惊的问道。<br>“在人生的某个时候，我们失去了对自己生活的掌控，命运主宰了我们的人生。这就是世界上最大的谎言。”</p><p>“你把十分之一的羊送给我，我就告诉你怎样找到宝藏。” <span style="border:1px solid #666">老人</span>说道。<br>男孩又想起了那个梦。突然之间，一切都明朗起来。</p><p><span style="color:red; ">“天命就是你一直期望去做的事情。”人一旦步入青年时期，就知道什么是自己的天命了。在人生的这个阶段，一切都那么明朗，没有做不到的事情。人们敢于梦想，期待完成他们一生中喜欢做的一切事情。但是，随着时光的流逝，一股神秘力量开始企图证明，根本不可能实现天命。”</span></p><p>“那是表面看来有害无益的力量，但实际上它却在教你如何完成自己的天命，培养你的精神和毅力。因为在这个星球上，存在一个伟大的真理：不论你是谁，不论你做什么，当你渴望得到某种东西时，最终一定能够得到，因为这愿望来自于宇宙的灵魂。那就是你在世间的使命。”</p><p>完成自己的天命是人类无可推辞的义务。万物皆为一物。当你想要某种东西时，整个世界会合力助你实现愿望。</p><p>“你为什么要牧羊？”<br>“因为我喜欢四处游荡。”</p><p><span style="border:1px solid #000">爆米花少年</span>从来就不明白，人们总是有条件去实现自己的梦想。<br>总而言之，人们更重视对于卖爆米花的人和牧羊人的看法，甚至超过了对天命的重视。</p><p><span style="color:#195; "><br>“您为什么跟我讲这些事情？”<br>“因为你意欲履行自己的天命，并差一点就放弃了。”<br>“您总是在这种时刻出现吗？”<br>“一向如此，但是，不见得总以这种方式出现。有时候，可能是一条好出路，一个好主意，或者在关键时刻让事情变得更容易。”<br></span></p><p><span style="color:red; ">“如果东西还没到手，你就先许诺于人，那你就不会积极去争取了。”</span><br>生活中的一切都要付出代价。</p><p>圣地亚哥明白了，那老妇人说的是真话。<br>他考虑着是否应该把那位老人刚才说的话告诉小贩，有的时候最好让事情保持原样，想到这儿，男孩便没有开口。<span style="text-decoration: underline">（生活中我们是否好为人师）</span></p><p>地中海东风刮越刮越猛。面对羊群和宝藏，我现在进退两难，男孩想。<br>在已经习以为常的东西和意欲得到的东西之间，他必须做出抉择。还有那个商人的女儿。不过，她不像羊群那么重要，因为她并不依赖他。</p><p>实际上，每天一成不变，是因为人们已经失去了对美好事物的敏锐感觉。然而，只要有明媚的阳光，人们的生活中就会出现美好的事物。</p><p>第一次玩纸牌，多半会赢。这就是新手的运气。<br>“这是为什么？”<br>“因为生活希望你去实现自己的天命。”</p><p>“财宝在什么地方？”<br>“在埃及，金字塔附近。”</p><p>这两块宝石名叫乌凌和图明，代表着是和否。<br>智慧大师说，“如果你不了解一个人的家，就不能信任他。”</p><p>“这正是我要给你的唯一忠告。”智慧大师说，<span style="color:red; ">‘幸福的秘密就在于，既要看到世上的奇珍异宝，又要永远不忘记勺里的那两滴油。’</span>”</p><p>牧羊少年没说话，他听懂了老人讲述的故事。</p><p>在小城塔里法的制高点有一座旧城堡，那是当年摩尔人修建的。麦基洗德看了一眼正驶离港口的那条小船，神不该有欲望，因为神没有天命，但是他却由衷地祈愿牧羊少年得偿所愿。</p><div style="color:green; font-size:18px">※※   踏足非洲  ※※</div><p><span style="border:1px solid #000"><code>港口 小偷 酒吧老板 水晶商人 宝剑</code></span></p><p>非洲真是个奇怪的地方，男孩想。他坐在一家酒吧里，这家酒吧与他在这个城市狭窄的街巷中见到的其他酒吧没什么两样。</p><p><span style="color:red; ">东西未到手，不应轻易许下诺言。</span></p><p>“他想要你的钱。”<span style="border:1px solid #000">少年</span>说，“丹吉尔跟非洲其他的地方不同，这里是个港口，而港口总是有贼。”</p><p>在纷繁杂乱的商品中间，他突然看到一把剑，那是他见过的最漂亮的剑。包银的剑鞘，黑色的剑柄，柄上嵌有宝石。男孩暗暗发誓，从埃及回来的时候，一定要买下这把宝剑。<br><span style="color:#195"><br>太阳快要落山了。男孩望着太阳，望了许久，直到它隐落到广场周围那些白色的房屋后面。男孩想起早晨太阳升起的时候，他还在另一块大陆，还是个牧羊人，拥有六十只羊，而且要依约去见一个女孩。早晨，他走早田野上，那时，将会发生什么事情他全都知道。<br></span><br><span style="color:#195">然而，太阳落山的此时此刻，他却置身于异国他乡，身为异乡客，来到一个陌生的国度。在这里，他甚至听不懂人家说话。他已经不再是牧羊人，已经一无所有，甚至连回程的钱都没有，何谈实现心愿？<br></span><br><span style="color:#195">一切都发生在太阳东升和西落之间，男孩想。他为自己的处境感到难过。在生活中，事情有时会在一瞬间发生变化，人们根本来不及去适应这种变化。</span><br><span style="color:#195"><br>他一向羞于流泪，甚至从未在他的羊群面向哭过。但此时，集市已散，广场上空空荡荡，他独自一人身在异地，远离家乡。<br></span><br><span style="color:#195">男孩哭了。上帝如此不公平，竟以这种方式回报相信梦想的人。从前跟羊群在一起的时候，我很快乐，而且总是把快乐传达给周围的人。大家看到我出现，都会热情款待。但是现在，我既伤心又郁闷。我改怎么办呢？我会更加痛苦不堪，不再相信任何人，因为有人背叛了我。<br></span></p><p>他想到可以卖掉宝石，买一张回程的船票。</p><p><span style="color:red">凡是港口，总免不了充斥着盗贼。</span></p><p>现在，他明白了<span style="border:1px solid #000">酒吧老板</span>发脾气的原因，那老板试图告诉他不要轻信那个少年。我和别人没什么两样，<span style="color:red">总是以理想的眼光看待世界，以为事情会按照理想的方式发展，而不会用现实的眼光看到世界，看不到事情的真相。</span></p><p>有些事情是不应该问的，不能逃避自己的天命。</p><p>他想起了那把宝剑，看他一眼所付出的代价可谓高昂，但他比毕竟见到了他过去从未见识过的稀罕物。他突然觉得，被骗之后，他可以像个倒霉的受害者一样看待世界，也可以像个寻宝的冒险家那样观察世界。</p><p>在筋疲力尽，进入梦乡之前，男孩想：<span style="color:red">我是个寻宝的冒险家</span>。</p><p><span style="color:red">他身无分文，却对生活充满信心。</span></p><p>水晶店的老板眼瞅着天放亮了。每天早晨，他都会一如既往地感到心烦意乱。他的店铺在一座山丘的顶部，几乎三十年了，一直在这个地方，很少有人光顾。现在做任何改变都为时已晚，他这辈子唯一的本事就是做水晶生意。</p><p>三十年来，他一直靠卖水晶维持生计，现在改弦易辙为时太晚了。</p><p>他拿出外套，开始擦拭那些器皿。</p><p>水晶商人笑了。“哪怕你一整年都给我擦水晶，哪怕你从每一件卖出去的商品中都能挣到可观的佣金，仍然必须借一笔钱才能去埃及。从丹吉尔到金字塔，要穿过几千公里的沙漠呢。”</p><blockquote><p>◼（按：真正的认识清楚现实和理想间的差距）</p></blockquote><p>一时间，周围一片寂静，似乎整个城市都静止不动了。</p><p>“先生，我将给您打工。”他说。</p><p>又沉默了一阵之后，他说道：“我需要钱，好去买些羊。”</p><blockquote><p>◉ 梦想似乎遥不可及，或许重新回到以前的生活是最好的选择。</p></blockquote><div style="color:green; font-size:18px">※※   水晶店的生活  ※※</div><p><span style="border:1px solid #000"><code>麦加 学习 钱</code></span></p><p>直觉告诉他，男孩很快就会回去放羊。</p><p>“我不喜欢变化。” 水晶商人说。</p><p><span style="color:red">当好运降临时，我们必须抓住机会，顺应趋势，竭尽全力推动好运向前发展</span>。</p><p>我害怕实现我的梦想，实现之后，我就没有活下去的动力了。</p><p>你的梦想是羊群和金字塔。你与我不同，因为你希望实现你的梦想，而我只是想要保有去麦加的梦想。并非所有人都以一样的方式来对待梦想。</p><p>有一段时间，他曾经以为羊群能够教会他一切，但是，羊群不会教他阿拉伯语。</p><p>世界上一定还有其他一些东西是羊群教不了的，因为他们只是一味的寻找食物和水源。</p><p>我认为并不是羊群在教，而是我在学，他又想。</p><p><span style="text-decoration: underline">（按：水晶店这段经历其实是为寻宝之旅做准备工作，比如重新认识梦想以及学习阿拉伯语）</span></p><p>圣地亚哥在日出前醒来，从他踏上非洲大陆算起，已经过去了是一个月零九天。</p><p>他把手伸衣服的一个口袋里，然后端详了一会儿从兜里掏出来的东西。<br>那是厚厚的一沓钱，足够用来买上一百二十只羊，一张回家的船票和一张贸易许可证。有了许可证，他就能往来于西班牙和摩洛哥做生意。<br>他耐心地等到店主醒来，开门营业。</p><p>“我为你感到骄傲。”他说，“你为我的水晶店带来了生机。但是你知道，我不会去麦加，就像你知道自己不会回去买羊一样。”</p><p>“当你想要某种东西时，整个世界都会合力助你实现愿望。”老迈的撒冷之王这样说过。</p><p>但是，撒冷之王却没说过有人会骗取钱财，没说过大沙漠浩瀚无垠，没说过会有知道自己的梦想却不愿意去实现的人。</p><p>此处距离安达卢西亚平原仅仅两个小时的船程，但是在他与金字塔之间却横亘着一大片沙漠。但此种境况也让男孩意识到：他距离自己的宝藏近了两个小时的路程。尽管他几乎用了整整一年，才走完这两个小时的路。</p><p>如果找不到那些财宝，我随时可以返回家园，。但是生活突然给了我足够的金钱，而且又有足够的时间，为什么不去寻宝呢？</p><p>他没费什么力气就找到了那家客栈，他想知道金字塔是否真的非常遥远。</p><div style="color:green; font-size:18px">※※   穿越沙漠  ※※</div><br><span style="border:1px solid #000"><code>英国人 沙漠 商队 书 翡翠板 元精 炼金术</code></span><br><br>他显示对世界语产生了兴趣，然后是宗教，最后是炼金术。<br><br>一旦做出决定，实际上便坠入了一股巨大的洪流之中，这洪流会把人带到一个你做决定时从来没想到的地方去。<br><br>“法尤姆就在埃及。” 货站老板说。<br><br>男孩和英国人也已买好了骆驼，他们有些费力地爬到骆驼背上。<br><br><span style="color:red">一个人越接近梦想，天命就越成为他生存下去的真正理由</span>。<br><br>我从羊群身上学到了东西，从水晶身上学到了东西，他心想。我也能沙漠身上学到东西。我觉得沙漠更沧桑，更智慧。<br><br>商队永远只朝着一个方向前进。克服所有障碍，循着那颗指示绿洲方位的星斗前进。<br><br>男孩也有一本书，但是他发现，观察商队和倾听风声比读书有意思多了。因此，当他对骆驼更加熟悉并且迷上这种动物之后，便把书扔掉了。书是不必要的负担，尽管男孩曾养成一种近乎迷信的观点：以书为友，开卷有益。<br><br>我们担心失去的，只是那些我们现在拥有的东西。<br><br>男孩读到有关炼金术最重要的文字，只有寥寥几行，据说写在一块普通的翡翠板上。<br><span style="color:#195"><br>“那还要这么多书干吗？”<br>“为了理解那几行文字。”<span style="border:1px solid #000">英国人</span>说。<br></span><br><br>炼金术士把这种东西称为元精，它由液体和固体构成。元精的液体部分叫做长生不老液，除了能防止炼金术士衰老，还能医治百病，固体部分则叫点金石。<br><br>男孩越来越坚信，在日常生活中就能把炼金术学到手。<br><span style="color:#195"><br>“他们为什么把事情搞的这么难懂？”<br>“为的是只让那些有责任心的人读懂它们。”<br></span><br>只有那些坚持不懈的人，只有那些不断钻研的人，才能够获取元精。<br><br>每个人都有自己的学习方式，他在心中反复对自己说。他的方式不属于我，我的方式也不属于他。但是我们俩都在追寻各自的天命，为此，我尊重他。<br><br>商队开始日夜兼程。戴风帽的报信人频繁的出现。<br><br><br><div style="color:green; font-size:18px">※※   绿洲和战争  ※※</div><br><span style="border:1px solid #000"><code>绿洲 法蒂玛 战争 预兆 鹰 顾问</code></span><br><br>人们由于迷恋图画和文字，忘记了宇宙的语言。<br><br>他们将在绿洲驻扎下来，直到部落间的战争结束。<br><br><span style="color:red">离自己的梦想越近，事情就变得越困难</span>。撒冷之王口中所谓“新手的运气”不再起作用。男孩明白，现在需要的是毅力和勇气。<br><br>不要失去耐心，男孩想，就像<span style="border:1px solid #000">赶驼人</span>说的，该吃饭时吃饭，该睡觉时睡觉。<br><br>此时，时间仿佛在刹那间停止，世界之魂蓦然出现在圣地亚哥面前。当男孩看见少女那双黑色的眼睛，看见她似笑非笑的面容，似启非启的双唇，他明白了世界上最重要和最智慧的表达方式，也就是人类能理解的语言。这就是所谓的爱情。<br><span style="color:#195"><br>“你叫什么名字？” 他问。<br>“我叫法蒂玛。”<span style="border:1px solid #000">少女</span>俩眼看着地面回答。<br></span><br>他已经爱上了她，并且明白了凭着他对少女的爱，就能找到世上所有的宝藏。<br><br>他只是对我说：去试试看吧。<br>男孩沉默不语。英国人长途跋涉来到此地，听到的却是毫无意义的东西。男孩想起自己送给撒冷之王六只羊，也得到一样的结果。<br><br>沙丘会随风改变形状，但沙漠永远都在。我们的爱情也是如此。<br><br>正是由于害怕失败，我至今都没有尝试获取元精。现在，我已经开始做十年前就可以开始做的事情了。到那时我很高兴，因为毕竟没等上二十年才做这件事。<br><br>实际上，并不是事物本身在揭示什么，而是观察事物的人发现了探究世界之魂的方法。<br><br>我卜算未来的方式，是通过当前的预兆。秘密就在当前。如果关注现在，你就能改善它。如果改善了现在，那么将来也会变得更好。<br><br>卫兵把圣地亚哥叫进帐篷。眼前的景象令圣地亚哥惊叹不已。他简直想不到，在沙漠中还会有这样的帐篷。<br><br><span style="border:1px solid #000">神秘骑士</span>抽出栓在马鞍上的一把巨大弯刀，刀刃在月光下闪着寒光。<br><br>对于寻求宇宙语言的人，勇气是最重要的素质。<br><br><span style="color:red">“你必须永不松懈，哪怕已经走了很远的路。” </span>骑士继续说，“你必须热爱沙漠，但是绝不要完全相信沙漠。因为沙漠对所有人都是一个考验：考验你迈出的每一步，杀死心猿意马的人。”<br><br>男孩见到的，正是炼金术士。<br><br>部落的最高头领说，他为那些死去的士兵感到痛心，但是传统绝不能随意改变。<br><br>圣地亚哥成为了绿洲的顾问。<br><br><div style="color:green; font-size:18px">※※   炼金术士  ※※</div><p>月上中天之时，炼金术士翩然而至 ，肩头搭着两只死去的鹰。</p><p>“我已经找到宝藏了。我有一头骆驼，有再水晶店打工挣到的钱，还有在这里得到的五十枚金币。在我的家乡，我可以算富翁了。”<br>“不过，这其中没有一样来自金字塔。” 炼金术士说。</p><p>你必须找到你的宝藏，否则你在途中发现的一切便全都失去了意义。</p><p>明天卖掉你的骆驼，去买一匹马。</p><p>只有发现生命的人，才能找到宝藏。</p><p>你将永远不明白，爱情从来不会阻止一个男人去追寻天命。如果会阻止，一定因为那不是真正的爱情。</p><p>这天晚上，他们看着圆圈中的毒蛇时，那位肩头停着猎鹰的神秘骑士谈到了爱情、财宝、沙漠的女人和他的天命。<br>“我跟你走。”男孩说完，内心立刻平静下来。</p><p>倾听你的心声，心了解所有的事物。</p><p>为一个梦想而失去已经到手的一切，有点担心也是情有可原。</p><p><span style="color:red">害怕遭受痛苦比遭受痛苦本身还要糟糕</span>。</p><p>追寻梦想的每一刻，都与上帝和永恒同在。</p><p><span style="color:red">夜色之浓，莫过于黎明前的黑暗</span>。</p><div style="color:green; font-size:18px">※※  用心和世界对话  ※※</div><p>“您为什么要那样说呢？”<br>“为了向你证实一个简单的真理。” 炼金术士回答，“当巨大的财富就在我们眼前时，我们却从来都觉察不到。你知道为什么？因为人们不相信财宝存在。”</p><p>万物讲很多种语言。</p><p>此前沙漠是一片广袤的天地，现在却变成了一道无法逾越的坚壁。</p><p>“如果你必死无疑，它们对你又有什么用处呢？”炼金术士回答说，“你的钱救了你，还能多活三天。钱能用来推迟死期，这种事并不多见。”</p><p>你不要陷入绝望而不能自拔，这样会使你无法和自己的新沟通。</p><p>风一向无所不知。</p><p>上帝的灵魂就是他自己的灵魂。</p><p>所有人都被这种魔法吓坏了，只有两个人脸上露出了微笑：一个是炼金术士，因为他找对了弟子；另一个是<span style="border:1px solid #000">指挥官</span>，因为他理解了上帝的荣耀。</p><p>夜幕降临，他们来到一座科普特人的修道院前。</p><p><span style="color:#195"><br>“这块金子给你，因为你对待路人十分慷慨。”<br>“我得到的报酬远胜于我的慷慨。”<span style="border:1px solid #000">修士</span>回答。<br>“永远别再这么说，生活会听在耳内，下一次就会少给你。”<br></span></p><p><span style="color:red">所有发生过一次的事，可能永远不会再发生；但所有发生过两次的事，肯定还会发生第三次</span>。</p><p>炼金术士准备策马离去。<br>“做什么并不重要，世界上的每个人都在历史中扮演着重要的角色，但通常懵然不知。”</p><p>一轮满月悬在中天，星光灿烂。</p><p>他终于到达了藏宝之地。只有目标实现了，一项事业才算圆满成功。</p><p>圣地亚哥在他圈定的地方挖了整整一夜，结果一无所获。</p><p>“你在这儿干什么？”<br>“我们是躲避战乱的难民。” 其中<span style="border:1px solid #000">一个人</span>说。</p><p>“我们走吧。”<span style="border:1px solid #000">领头的</span>说，然后转向男孩。“你不会死的。”他说，“你将活下去，还会明白人不能太愚蠢。<span style="color:red">差不多两年前，就在你待着的这个地方，我也重复做过同一个梦。我梦见自己应该到西班牙的田野上去，寻找一座残破的教堂，一个牧羊人经常待着羊群在那里过夜。圣器室所在的地方有一棵无花果树。如果我在无花果树下挖掘，一定能找到一笔宝藏。但是我可没有那么蠢，不会因为重复做了同一个梦就去穿越一大片沙漠。</span>”</p><p>说完，他扬长而去。</p><p>圣地亚哥吃力的爬起来，他对金字塔报以微笑，心中无比幸福。他已经找到自己的宝藏了。</p><div style="color:green; font-size:18px">※※  尾声  ※※</div><p>圣地亚哥在夜幕将至的时候，赶到了那座废弃的小教堂。</p><p>现在他又来到了这里，没有带着羊群，而是带了把铁锹。</p><p>“如果我事先告诉你，你就看不到金字塔了。它们很壮美，不是吗？”</p><p><span style="color:red">生活对追随自己天命的人真的很慷慨。</span></p><h4 id="第三部分-后记"><a href="#第三部分-后记" class="headerlink" title="第三部分 后记"></a>第三部分 后记</h4><p>“多美的故事啊！” 我读完之后发出了和炼金术士一样的感慨。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;无疑，这是一本非常牛B的📚，至少在我的阅读经验里如此。此时，我将写下一篇冗长的阅读笔记，记录我对它的感觉以及探索。在这篇文章里，我将以&lt;code&gt;基本故事&lt;/code&gt;、&lt;code&gt;奇幻之旅&lt;/code&gt;、&lt;code&gt;后记&lt;/code&gt;的结构来进
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://weibo.com/u/3800117445/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [05]-javaScript和JSON</title>
    <link href="https://weibo.com/u/3800117445/2018/04/16/javaScript%E7%B3%BB%E5%88%97%20%5B05%5D-javaScript%E5%92%8CJSON/"/>
    <id>https://weibo.com/u/3800117445/2018/04/16/javaScript系列 [05]-javaScript和JSON/</id>
    <published>2018-04-16T12:20:13.000Z</published>
    <updated>2018-05-18T06:28:20.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文输出和JSON有关的以下内容<br>❐  JSON和javaScript<br>❐  JSON的语法介绍<br>❐  JSON的数据类型<br>❐  JSON和XMLHTTPRequest<br>❐  JSON的序列化和反序列化处理</p></blockquote><h3 id="1-1-JSON和javaScript"><a href="#1-1-JSON和javaScript" class="headerlink" title="1.1 JSON和javaScript"></a>1.1 JSON和javaScript</h3><p><span style="color:red">JSON是一种数据交换格式。</span></p><p>JSON的全称是JavaScript Object Notation，翻译为JavaScript对象表示法。JSON的这个全称，无疑让很多人既兴奋又困惑，兴奋的人直接认为这就是JavaScript中的对象，困惑的人觉察出JSON数据和JavaScript对象好像有些不一样。接下来我们先谈一谈JSON数据和JavaScript的关系。</p><p>诚然，从JSON的全称可以看出JSON和JavaScript语言必定有种某种神秘关联，至少能够确定的是JSON的命名确实来源于JavaScript这门语言。</p><p>JSON基于JavaScript对象字面量，但JSON本身是一种数据交换格式，因此它是独立于语言的。JSON全称为JavaScript对象表示法，在理解的时候可以认为<span style="color:red">JSON ==&gt; JavaScript &amp;&amp; 对象 &amp;&amp; 表示法</span></p><p>JavaScript我们知道是一门动态脚本语言，那么<code>对象表示法</code>是什么？</p><p>对象是面向对象编程语言中一种常见的数据类型，表示键值对的集合，那么<code>表示法</code>是什么？</p><p><strong>表示法</strong>:是指一个可以表示诸如数字或单词等数据的字符系统。</p><p>JSON起源于JavaScript（灵感来源于JavaScript的对象语法），但真正重要的是具体的表示法本身。JSON不仅独立于语言，而且使用了一种在许多编程语言中能够找到共同元素的表达方式。基于这种简洁的表达方式，JSON迅速成为一种流行的数据交换格式。目前，客户端和服务器端在进行数据通信的时候，常见的数据格式就是JSON和XML。</p><h3 id="1-2-JSON的语法介绍"><a href="#1-2-JSON的语法介绍" class="headerlink" title="1.2 JSON的语法介绍"></a>1.2 JSON的语法介绍</h3><h4 id="1-2-1-JSON的语法"><a href="#1-2-1-JSON的语法" class="headerlink" title="1.2.1 JSON的语法"></a>1.2.1 JSON的语法</h4><p> JSON因为基于JavaScript的字面量，所以我们先来看下JavaScript字面量的样子，下面给出简单的代码示例，描述了一个书对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  book = &#123;</div><div class="line">      name:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">      price:<span class="number">42.00</span>,</div><div class="line">      author:<span class="string">"福柯"</span>,</div><div class="line">      press:<span class="string">"北京大学出版社"</span>,</div><div class="line">      read:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p>顺便贴出一个简短的JSON数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">      <span class="attr">"name"</span>:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">      <span class="attr">"price"</span>:<span class="number">42.00</span>,</div><div class="line">      <span class="attr">"author"</span>:<span class="string">"福柯"</span>,</div><div class="line">      <span class="attr">"press"</span>:<span class="string">"北京大学出版社"</span>,</div><div class="line">      <span class="attr">"content"</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="number">123</span>]</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p> 我们可以对比下上面的JavaScript对象和JSON数据，会发现它们的结构和语法形式很像，都是键值对的集合，接下来我们做更详细的说明。JSON数据在表达上和对象保持一致，但因为数据交换格式的核心是数据，所以<code>JSON并不会保存函数等信息</code>。JSON数据所基于的JavaScript对象字面量单纯指对象字面量以及其属性的语法表示。</p><p><strong>JSON的主要语法特点</strong></p><blockquote><p>① 以键值对的方式来保存数据<br>② 标准的JSON数据的key必须要使用双引号包裹<br>③ { } 用于表示和存放对象，[ ] 用于表示和存放数组数据</p></blockquote><p>JSON数据的读取，在读取JSON的时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; 表示开始读取对象，&#125; 表示对象读取结束</div><div class="line">[ 表示开始读取数组，] 表示数组读取结束</div><div class="line">：用于分隔键值对中的key和value</div><div class="line">, 用于分隔对象中的多个键值对或者是数组中的多个元素</div></pre></td></tr></table></figure></p><p><div class="tip"><br>JavaScript对象字面量中的key可以使用单引号，可以使用双引号，可以不必加上引号包裹，但是在JSON中，所有的key必须要加上双引号。</div></p><div><h4 id="1-2-2-JSON的验证和格式化工具"><a href="#1-2-2-JSON的验证和格式化工具" class="headerlink" title="1.2.2 JSON的验证和格式化工具"></a>1.2.2 JSON的验证和格式化工具</h4><p>下面列出一些能够对JSON数据进行校验和格式化的在线地址<br><a href="https://jsonlint.com/" target="_blank" rel="external">https://jsonlint.com/</a><br><a href="http://tool.oschina.net/codeformat/json" target="_blank" rel="external">http://tool.oschina.net/codeformat/json</a><br><a href="https://jsonformatter.curiousconcept.com/" target="_blank" rel="external">https://jsonformatter.curiousconcept.com/</a></p><h4 id="1-2-3-JSON文件和MIME类型"><a href="#1-2-3-JSON文件和MIME类型" class="headerlink" title="1.2.3 JSON文件和MIME类型"></a>1.2.3 JSON文件和MIME类型</h4><p>在开发中我们经常需要处理大量的JSON数据，JSON这种数据交换格式可以作为独立的文件存在于文件系统中，文件扩展名为    <code>.json</code></p><p>JSON的MIME类型是<code>application/json</code>, 详细信息请参考<a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">IANA官网维护的所有媒体类型列表</a>。</p><h3 id="1-3-JSON的数据类型"><a href="#1-3-JSON的数据类型" class="headerlink" title="1.3 JSON的数据类型"></a>1.3 JSON的数据类型</h3><p>JSON中（作为value值）的数据类型包括<code>对象、字符串、数字、布尔值、null和数组六种</code>。</p><p><code>① 字符串</code><br>JSON中的字符串可以由任何的Unicode字符构成，字符串的两边必须被双引号包裹。需要注意的是：<span style="color:#195">虽然在JavaScript语言中字符串可以使用单引号来包裹，但是在JSON中的字符串必须使用双引号包裹。</span></p><p>如果字符串中存在以下特殊字符，那么需要在它们的前面加上一个反斜线（\）来进行转义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- &quot;  双引号</div><div class="line">- \  反斜线</div><div class="line">- \/ 正斜线</div><div class="line">- \b 退格符</div><div class="line">- \f 换页符</div><div class="line">- \t 制表符</div><div class="line">- \n 换行符</div><div class="line">- \r 回车符</div><div class="line">- \u 后面跟16进制字符</div></pre></td></tr></table></figure></p><p><code>② 数字</code><br>JSON中的数字可以是整数、小数、负数或者是指数。</p><p><code>③ 布尔类型</code><br>JSON数据仅仅支持小写形式的布尔类型值：true 和 false。</p><p><code>④ null类型</code><br>JSON中没有undefined这种数据类型，它使用null表示空，并且必须小写。<br>在JavaScript语言中，var obj = null 表示把obj这个对象清空，它和undefined不太一样，null表示什么都没有，undefined表示未定义。</p><p><code>⑤ 对象类型</code><br>对象类型是使用逗号分隔的键值对的集合，使用大括号(<code>{}</code>)裹。</p><p><code>⑥ 数组类型</code><br>数组类型是元素的集合，每个元素都可以是字符串、数字、布尔值、对象或者数组中的任何一种。元素与元素之间使用逗号隔开，所有的元素被方括号（<code>[]</code>）包裹，建议数组中所有的元素都应该是相同数据类型的。</p><h3 id="1-4-JSON和XMLHTTPRequest"><a href="#1-4-JSON和XMLHTTPRequest" class="headerlink" title="1.4 JSON和XMLHTTPRequest"></a>1.4 JSON和XMLHTTPRequest</h3><p>在前端开发中有一种发送网络请求的技术Ajax，它可以实现异步处理网络通信而不刷新页面。</p><p>Ajax的全称为Asynchronous JavaScript and XML，即异步的JavaScript和XML。我们知道JSON的定位是轻量级的数据交互格式，客户端在和服务器端进行网络通信的时候，服务器端返回给我们的数据大多数是JSON或者是XML。也就是说JSON数据在Ajax网络通信中可能扮演重要的角色，<code>那什么Ajax不叫异步的JSON而叫做异步的XML呢？</code> 答案是：因为刚提出这种网络请求技术的时候，XML相比JSON更流行。</p><p>在Ajax网络请求中用到的核心对象XMLHTTPRequest也是如此，其实这个对象命名中包含XML也仅仅是因为对于当时而言，XML是网络请求中最常用的数据交换格式。如果放在今天，那么它们的名字应该叫做AjaJ(Asynchronous JavaScript and JSON)和JSONHTTPRequest更合适一些。</p><h3 id="1-5-JavaScript中JSON数据的序列化和反序列化处理"><a href="#1-5-JavaScript中JSON数据的序列化和反序列化处理" class="headerlink" title="1.5 JavaScript中JSON数据的序列化和反序列化处理"></a>1.5 JavaScript中JSON数据的序列化和反序列化处理</h3><p>在网络请求中，如果服务器返回给我们的数据是JSON数据，那么为了方便对数据的操作，通常我们在网络请求成功拿到JSON数据之后会先对JSON数据进行反序列化操作。<br>在前端开发中，早期的JSON解析基本上由eval函数来完成，ECMAScript5对解析JSON的行为进行了规范，定义了全局对象JSON。目前IE8+、FireFox 3.5+、Opera 10.5、Safari 4+和Chrome等浏览器均支持原生的JSON全局对象。</p><p><strong>JSON数据的处理主要涉及到两方面：<span style="color:#f55">序列化处理和反序列化处理</span></strong></p><h4 id="1-5-1-使用eavl函数来处理JSON数据"><a href="#1-5-1-使用eavl函数来处理JSON数据" class="headerlink" title="1.5.1 使用eavl函数来处理JSON数据"></a>1.5.1 使用eavl函数来处理JSON数据</h4><p><strong>eavl函数说明</strong></p><p>JavaScript语言中eavl函数可以把字符串转换为js的代码并且马上执行，使用情况和Function构造函数用法类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"var a = 123;"</span>);</div><div class="line"><span class="built_in">console</span>.log(a + <span class="number">1</span>);  <span class="comment">//输出结果为124</span></div></pre></td></tr></table></figure></p><p>因为从某种程度上来讲，json其实是JavaScript语言的严格子集，所以我们可以直接通过eval函数来对json数据进行解析。需要注意的是，使用eavl函数来对json数据结构求值存在风险，因为可能会执行一些恶意代码。</p><p><strong>eavl函数解析JSON</strong></p><p>服务器返回给前端的json数据可能是<code>{...}</code>形式的，也可能是<code>[...]</code>形式的，分别对应js中的对象和数组。如果是<code>{...}</code>形式的，那么在解析的时候，如果直接以eval(json)的方式处理会报错，因为js中不允许直接写{name:”zs”}类似的语句。遇到这种结构的json数据，通常我们有两种方式进行处理：<span style="color:#f22">① 包装成表达式 ② 赋值给变量。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//001 [...] 格式的json数据</span></div><div class="line"><span class="keyword">var</span> arrJson= <span class="string">'[&#123;"name":"zs","age":18&#125;,&#123;"name":"lisi","age":28&#125;]'</span>;</div><div class="line"><span class="keyword">var</span> jsonArr = <span class="built_in">eval</span>(arrJson);</div><div class="line"></div><div class="line"><span class="comment">//002 &#123;...&#125; 格式的json数据</span></div><div class="line"><span class="keyword">var</span> objJson = <span class="string">`&#123;"name":"wendingding","age":18,"contentAbout":["JavaScript","CSS","HTML"],"car":&#123;"number":"粤A6666","color":"red"&#125;&#125;`</span>;</div><div class="line"></div><div class="line"><span class="comment">//eval(json);  错误的演示：报错</span></div><div class="line"><span class="comment">//处理方式(1)：以拼接的方式赋值给变量</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"var jsonObj1 = "</span> + objJson);</div><div class="line"><span class="comment">//处理方式(2)：包装成表达式</span></div><div class="line"><span class="keyword">var</span> jsonObj2 = <span class="built_in">eval</span>(<span class="string">"("</span> + objJson +<span class="string">")"</span>);</div><div class="line"></div><div class="line"><span class="comment">//打印转换后得到的数组|对象</span></div><div class="line"><span class="built_in">console</span>.log(jsonArr);</div><div class="line"><span class="built_in">console</span>.log(jsonObj1);</div><div class="line"><span class="built_in">console</span>.log(jsonObj2);</div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_10.png?raw=true" height="250"></p><h4 id="1-5-2-使用JSON全局对象来处理JSON数据"><a href="#1-5-2-使用JSON全局对象来处理JSON数据" class="headerlink" title="1.5.2 使用JSON全局对象来处理JSON数据"></a>1.5.2 使用JSON全局对象来处理JSON数据</h4><p>JSON全局对象拥有两个方法：stringify()和parse()，其中parse方法用于把json数据反序列化为原生的js，stringify方法用于把js对象序列化为json字符串。</p><p><strong>parse方法的使用</strong><br><span style="color:#f55">语法：JSON.parse(jsonString,[fn])</span></p><p>参数说明</p><blockquote><p>第一个参数：jsonString为要解析的json字符串<br>第二个参数：fn是一个可选参数，该参数为函数类型，接收两个参数，分别是每个键值对的key和value。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//json字符串</span></div><div class="line"><span class="keyword">var</span> objJson = <span class="string">`&#123;"name":"wendingding","age":18,"contentAbout":["JavaScript","CSS","HTML"],"car":&#123;"number":"粤A6666","color":"red"&#125;&#125;`</span>;</div><div class="line"></div><div class="line"><span class="comment">//把json字符串转换为js数组</span></div><div class="line"><span class="keyword">var</span> arrJson= <span class="string">'[&#123;"name":"zs","age":18&#125;,&#123;"name":"lisi","age":28&#125;]'</span>;</div><div class="line"></div><div class="line"><span class="comment">//把json字符串转换为js对象</span></div><div class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">JSON</span>.parse(objJson);</div><div class="line"><span class="keyword">var</span> jsonArr = <span class="built_in">JSON</span>.parse(arrJson);</div><div class="line"><span class="built_in">console</span>.log(jsonObj);</div><div class="line"><span class="built_in">console</span>.log(jsonArr);</div><div class="line"></div><div class="line"><span class="comment">//演示parse方法中函数参数的使用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">"name"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="string">"++"</span>         <span class="comment">//在原有value值的基础上拼接++字符串</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"age"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>            <span class="comment">//如果返回undefined，则表示删除对应的键值对</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> value                <span class="comment">//正常返回对应的value值</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(objJson, fn));</div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_11.png?raw=true" height="250"></p><p><strong>stringify方法使用说明</strong><br><span style="color:#f55">语法：JSON.stringify(Obj,[fn|arr],[space])</span></p><p>参数说明</p><blockquote><p>第一个参数：Obj为要进行序列化操作的JavaScript对象<br>第二个参数：过滤器，可以是函数或者是一个数组<br>第三个参数：是否在生成的json字符串中保留缩进，用于控制缩进的字符</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js中的普通对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"zs"</span>,</div><div class="line">    age:<span class="number">18</span>,</div><div class="line">    friends:[<span class="string">"小霸王"</span>,<span class="string">"花仙子"</span>,<span class="string">"奥特曼"</span>],</div><div class="line">    other:<span class="literal">undefined</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//把js中的对象转换为json字符串</span></div><div class="line"><span class="comment">//注意：</span></div><div class="line"><span class="comment">//001 如果键值对中存在value值为undefined的数据，那么会被跳过</span></div><div class="line"><span class="comment">//002 对象中的方法以及该对象的原型成员数据在进行转换的时候，会被有意忽略</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj));</div><div class="line"></div><div class="line"><span class="comment">//控制缩进，该参数的值可以是数字也可以是字符串，自动换行</span></div><div class="line"><span class="comment">//001 如果是字符串那么会把对应的字符拼接在键值对前面，超过10个字符的省略</span></div><div class="line"><span class="comment">//002 如果是数字那么会设置对应的缩进，最多为10，超过则默认为10</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">4</span>));</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="string">"@@"</span>));</div><div class="line"></div><div class="line"><span class="comment">//过滤器（数组）：表示只处理key为name和age这两个键值对</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, [<span class="string">"name"</span>,<span class="string">"age"</span>]));</div><div class="line"></div><div class="line"><span class="comment">//过滤器（函数）：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">key,value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">"age"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="number">20</span>;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key === <span class="string">"name"</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;       <span class="comment">//过滤掉key为name这个键值对</span></div><div class="line">    &#125;<span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj,fn));</div></pre></td></tr></table></figure><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_12.png?raw=true" height="300" width="600"></p><p><strong>JSON数据总结</strong></p><blockquote><p>❐  JSON全称是JavaScript Object Notation基于JavaScript，是JavaScript的子集。<br>❐  JSON虽然是JavaScript的子集，但并不从属于JavaScript，它独立于语言。<br>❐  JSON是用来表示和传输数据的格式，比XML更轻量级，现已成为web数据交换的事实标准。<br>❐  JSON的优势在于其可以方便的把JSON字符串数据转换为对应的对象，比XML更方便且数据更小。<br>❐  JSON语法可以表示：字符串、数值、布尔值、null、对象和数组6种类型的值，不支持undefined。<br>❐  JSON中的”键”区别于JavaScript，必须要加上双引号。<br>❐  JSON解析可以使用传统的eval函数，或ECMAScript5推出的全局对象来处理。</p></blockquote><p><strong>参考资料</strong></p><p>JSON官网：<a href="http://json.org/" target="_blank" rel="external">http://json.org/</a><br>JSON维基百科：<a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">https://en.wikipedia.org/wiki/JSON</a><br>JSON作者简介：<a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="external">https://en.wikipedia.org/wiki/Douglas_Crockford</a><br>JSON必知必会:<a href="https://book.douban.com/subject/26789960/" target="_blank" rel="external">https://book.douban.com/subject/26789960/</a><br>JavaScript高级程序设计：<a href="https://book.douban.com/subject/10546125/" target="_blank" rel="external">https://book.douban.com/subject/10546125/</a></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文输出和JSON有关的以下内容&lt;br&gt;❐  JSON和javaScript&lt;br&gt;❐  JSON的语法介绍&lt;br&gt;❐  JSON的数据类型&lt;br&gt;❐  JSON和XMLHTTPRequest&lt;br&gt;❐  JSON的序列化和反序列化处理&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [04]-javaScript的原型链</title>
    <link href="https://weibo.com/u/3800117445/2018/04/15/javaScript%E7%B3%BB%E5%88%97%20%5B04%5D-javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://weibo.com/u/3800117445/2018/04/15/javaScript系列 [04]-javaScript的原型链/</id>
    <published>2018-04-14T17:20:13.000Z</published>
    <updated>2018-05-18T06:28:20.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。</p></blockquote><h4 id="1-1-理解原型链"><a href="#1-1-理解原型链" class="headerlink" title="1.1 理解原型链"></a>1.1 理解原型链</h4><p>JavaScript中几乎所有的东西都是对象，我们说数组是对象、DOM节点是对象、函数等也是对象，创建对象的Object也是对象（本身是构造函数），那么有一个重要的问题：<code>对象从哪里来？</code></p><p>这是一句废话，对象当然是通过一定方式创建出来的，根据实际类型不同，对象的创建方式也千差万别。比如函数，我们可以声明函数、使用Function构造函数创建等，比如数组，我们可以直接通过var arr  = [] 的方式创建空数组，也可以通过new Array的方式创建，比如普通的对象，我们可以字面量创建、使用内置构造函数创建等等，花样太多了，以至于我们学习的时候头昏脑涨、不得要领。</p><p><span style="color:red">其实，归根结底所有“类型”的对象都可以认为是由相应构造函数创建出来的。</span> 函数由Function构造函数实例化而来，普通对象由Object构造函数实例化而来，数组对象由Array构造函数实例化而来，至于Object | Array | Function等他们本身是函数，当然也有自己的构造函数。</p><p>理解了上面一点，那么接下来我们在理解原型链的时候就会容易得多。</p><blockquote><p>请看刺激的推导过程</p><p>前提 所有对象都由构造函数实例化而来，构造函数默认拥有与之相关联的原型对象<br>❒  ① 构造函数的原型对象也是对象，因此也有自己的构造函数<br>❒  ② 构造函数原型对象的构造函数，也有与之相关连的原型对象<br>❒  ③ 构造函数原型对象的原型对象（<code>__proto__</code>）也有自己的构造函数，其也拥有关联的原型对象<br>☞ 以上就形成了一种链式的访问结构，是为<code>原型链</code>。</p></blockquote><p><div class="tip"><br>其实构造函数也是对象，所以构造函数本身作为对象而言也有自己的构造函数，而这个构造函数也拥有与之相关联的原型对象，以此类推。那么，这就是另一条原型链了。综上，我们可以得出<code>原型链并不孤单</code>的结论。<div></div></div></p><h4 id="1-2-原型链结构"><a href="#1-2-原型链结构" class="headerlink" title="1.2 原型链结构"></a>1.2 原型链结构</h4><p>现在我们基本上把原型链的由来说清楚了，那么接下来通过具体的代码来分析原型链的整体结构。</p><p>示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 自定义构造函数Person和Animal</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();</div><div class="line"></div><div class="line"> <span class="comment">//03 创建数组对象</span></div><div class="line"><span class="keyword">var</span> arrM = [<span class="string">"demoA"</span>,<span class="string">"demoB"</span>];</div></pre></td></tr></table></figure></p><p>上面的代码非常简单，其中p1，p2和a它们是自定义构造函数的实例化对象。其次，我们采用快捷方式创建了arrM数组，arrM其实是内置构造函数Array的实例化对象。另外，Person和Animal这两个构造函数其实是Function构造函数的实例对象。理解以上几点后，我们就可以来看一下这几行代码对应的原型链结构图了。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_07.png?raw=true"></p><p>原型链结构图说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 因为复杂度关系，arrM对象的原型链结构图单独给出。</div><div class="line">② Object.prototype是所有原型链的顶端，终点为null。</div></pre></td></tr></table></figure></p><p>验证原型链相关的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证p1、p2的原型对象为Person.prototype</span></div><div class="line"><span class="comment">//    验证a    的原型对象为Animal.prototype</span></div><div class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p2.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a.__proto__ == Animal.prototype);  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 获取Person.prototype|Animal.prototype构造函数</span></div><div class="line"><span class="comment">//    验证Person.prototype|Animal.prototype原型对象为Object.prototype</span></div><div class="line"><span class="comment">//    先删除实例成员，通过原型成员访问</span></div><div class="line"><span class="keyword">delete</span>  Person.prototype.constructor;</div><div class="line"><span class="keyword">delete</span>  Animal.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[3] 验证Person和Animal的构造函数为Function</span></div><div class="line"><span class="comment">//    验证Person和Animal构造函数的原型对象为空函数</span></div><div class="line"><span class="built_in">console</span>.log(Person.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[4] 验证Function.prototype的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor == <span class="built_in">Function</span>);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[5] 验证Function和Object的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>);              <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[6] 验证Function.prototype的原型对象为Object.prototype而不是它自己</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[7] 获取原型链的终点</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);                    <span class="comment">//null</span></div></pre></td></tr></table></figure></p><p>下面贴出数组对象的原型链结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_08.png?raw=true"></p><p>验证数组对象原型链结构的代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证arrM的构造函数为Array</span></div><div class="line"><span class="comment">//方法1</span></div><div class="line"><span class="built_in">console</span>.log(arrM.constructor == <span class="built_in">Array</span>);                 <span class="comment">//true</span></div><div class="line"><span class="comment">//方法2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arrM));      <span class="comment">//[object Array]</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 验证Array的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>);             <span class="comment">//true</span></div><div class="line"><span class="comment">//[3] 验证Array构造函数的原型对象为Function.prototype(空函数)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype);     <span class="comment">//true</span></div><div class="line"><span class="comment">//[4] 验证Array.prototype的构造函数为Object,原型对象为Object.prototype</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">Array</span>.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor == <span class="built_in">Object</span>);         <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><h4 id="1-3-原型链的访问"><a href="#1-3-原型链的访问" class="headerlink" title="1.3 原型链的访问"></a>1.3 原型链的访问</h4><p><strong>原型链的访问规则</strong><br><span style="color"><br>对象在访问属性或方法的时候，先检查自己的实例成员，如果存在那么就直接使用，如果不存在那么找到该对象的原型对象，查找原型对象上面是否有对应的成员，如果有那么就直接使用，如果没有那么就顺着原型链一直向上查找，如果找到则使用，找不到就重复该过程直到原型链的顶端，此时如果访问的是属性就返回undefined，方法则报错。<br></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"wendingding"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    name:"自来熟",</div><div class="line">    showName:function () &#123;</div><div class="line">        <span class="keyword">this</span>.name.lastIndexOf()</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p.name);   <span class="comment">//访问的是实例成员上面的name属性：wendingding</span></div><div class="line">p.showName();          <span class="comment">//打印wendingding</span></div><div class="line"><span class="built_in">console</span>.log(p.age);    <span class="comment">//该属性原型链中并不存在，返回undefined</span></div><div class="line">p.showAge();           <span class="comment">//该属性原型链中并不存在，报错</span></div></pre></td></tr></table></figure><blockquote><p>概念和访问原则说明<br>❐ 实例成员：实例对象的属性或者是方法<br>❐ 原型成员：实例对象的原型对象的属性或者是方法<br>❐ 访问原则：就近原则</p></blockquote><h4 id="1-4-getPrototypeOf、isPrototypeOf和instanceof"><a href="#1-4-getPrototypeOf、isPrototypeOf和instanceof" class="headerlink" title="1.4 getPrototypeOf、isPrototypeOf和instanceof"></a>1.4 getPrototypeOf、isPrototypeOf和instanceof</h4><p><strong>Object.getPrototypeOf方法</strong>用于获取指定实例对象的原型对象，用法非常简单，只需要把实例对象作为参数传递，该方法就会把当前实例对象的原型对象返回给我们。说白了，Object的这个静态方法其作用就是<span style="color:red">返回实例对象<code>__proto__</code>属性指向的原型prototype。</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数F</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 使用构造函数F获取实例对象f</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</div><div class="line"></div><div class="line"><span class="comment">//03 测试getPrototypeOf方法的使用</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f));  <span class="comment">//打印的结果为一个对象，该对象是F相关联的原型对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype);  <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(f) === f.__proto__);  <span class="comment">//true</span></div></pre></td></tr></table></figure><p><strong>isPrototypeOf方法</strong>用于检查某对象是否在指定对象的原型链中，如果在，那么返回结果true，否则返回结果false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p)); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(p)); <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.isPrototypeOf(arr));    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(arr));   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(Person));<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>上述代码的原型链<br> ① p–&gt;Person.prototype –&gt;Object.prototype –&gt;null<br> ② arr–&gt;Array.prototype –&gt;Object.prototype –&gt;null<br>Object.prototype因处于所有原型链的顶端，故所有实例对象都继承于Object.prototype</p></blockquote><p><strong>instanceof运算符</strong>的作用跟isPrototypeOf方法类似，左操作数是待检测的实例对象，右操作数是用于检测的构造函数。<span style="color:red">如果右操作数指定构造函数的原型对象在左操作数实例对象的原型链上面，则返回结果true，否则返回结果false。</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//04 Object构造函数的原型对象在Function这个实例对象的原型链中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></div><div class="line"><span class="comment">//05 Function构造函数的原型对象在Object这个实例对象的原型链中</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p><div class="tip"><br>注意：不要错误的认为instanceof检查的是<code>该实例对象是否从当前构造函数实例化创建的</code>,其实它检查的是实例对象是否从当前指定构造函数的原型对象继承属性。</div></p><div><p>我们可以通过下面给出的代码示例来进一步理解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 获取实例化对象p</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line"><span class="comment">//03 测试isPrototypeOf的使用</span></div><div class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//04 替换Person默认的原型对象</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    showInfo:function () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"xxx"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//05 重置了构造函数原型对象之后，因为Person</span></div><div class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person); <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="comment">//06 在Person构造函数重置了原型对象后重新创建实例化对象</span></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p2 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//==&gt; 建议开发中，总是先设置构造函数的原型对象，之后在创建实例化对象</span></div></pre></td></tr></table></figure></p><p>贴出上面代码的原型链结构图（部分）<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_09.png?raw=true"></p><h4 id="1-5-原型链相关的继承"><a href="#1-5-原型链相关的继承" class="headerlink" title="1.5 原型链相关的继承"></a>1.5 原型链相关的继承</h4><p>继承是面向对象编程的基本特征之一，JavaScript支持面向对象编程，在实现继承的时候，有多种可行方案。接下来，我们分别来认识下<code>原型式继承、原型链继承以及在此基础上演变出来的组合继承</code>。</p><p><strong>原型式继承基本写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 提供超类型|父类型构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div></pre></td></tr></table></figure></p><p>贴出原型式继承结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/10.png?raw=true"></p><p><div class="tip">提示 该方式可以继承超类型中的原型成员，但是存在和超类型原型对象共享的问题<div></div></div></p><p><strong>原型链继承</strong></p><p>实现思想</p><blockquote><p>核心：把父类的实例对象设置为子类的原型对象 SubClass.prototype = new SuperClass();<br>问题：无法为父构造函数（SuperClass）传递参数</p></blockquote><p><strong>原型链继承基本写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line"><span class="keyword">var</span> sup = <span class="keyword">new</span> SuperClass();</div><div class="line">SubClass.prototype = sup;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line"><span class="built_in">console</span>.log(sub.name);          <span class="comment">//SuperClass的名称</span></div><div class="line"><span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">sub.showName();                 <span class="comment">//SuperClass的名称</span></div></pre></td></tr></table></figure></p><p>贴出原型链继承结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/11.png?raw=true"></p><p><strong>组合继承</strong></p><p>实现思想</p><blockquote><p>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例成员的继承，并且解决了父构造函数传参问题</p></blockquote><p><strong>组合继承基本写法</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 提供超类型|父类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 提供子类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    SuperClass.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//(1)获取父构造函数的实例成员  Person.call(this,name);</span></div><div class="line"><span class="comment">//(2)获取父构造函数的原型成员  SubClass.prototype = SuperClass.prototype;</span></div><div class="line">SubClass.prototype = SuperClass.prototype;</div><div class="line">SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line"><span class="keyword">var</span> sub_one = <span class="keyword">new</span> SubClass(<span class="string">"zhangsan"</span>);</div><div class="line"><span class="keyword">var</span> sub_two = <span class="keyword">new</span> SubClass(<span class="string">"lisi"</span>);</div><div class="line"><span class="built_in">console</span>.log(sub_one);</div><div class="line"><span class="built_in">console</span>.log(sub_two);</div></pre></td></tr></table></figure><p>最后，贴出实例对象sub_one和sub_two的打印结果<br><img src="https://github.com/flowerField/Source/blob/master/Blog/12.png?raw=true" height="200"></p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1-1-理解原型链&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [03]-javaScript原型对象</title>
    <link href="https://weibo.com/u/3800117445/2018/04/14/javaScript%E7%B3%BB%E5%88%97%20%5B03%5D-javaScript%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
    <id>https://weibo.com/u/3800117445/2018/04/14/javaScript系列 [03]-javaScript的原型对象/</id>
    <published>2018-04-14T13:05:13.000Z</published>
    <updated>2018-05-18T06:28:20.328Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>引用： javaScript是一门基于原型的语言，它允许对象通过原型链引用另一个对象来构建对象中的复杂性，JavaScript使用原型链这种机制来实现动态代理。当试图去引用某一个属性时，它会遍历整个原型链，直到最后的节点。<a href="https://book.douban.com/subject/26583722/" target="_blank" rel="external">JavaScript专家编程·P24</a></p></blockquote><h4 id="1-1-原型对象说明"><a href="#1-1-原型对象说明" class="headerlink" title="1.1  原型对象说明"></a>1.1  原型对象说明</h4><p>在JavaScript中除了基本数据类型外的其它数据都是对象类型，包括对象、函数、数组等,它们跟原型对象密不可分。</p><p>JavaScript语言中有一个非常重要的概念，叫做<code>原型对象</code>，理解原型对象是进一步理解这门语言的基础，因为它是一门基于原型的语言，也因为所有的代码几乎都和原型对象有关，接下来我们先了解下原型对象是什么。</p><p><strong>原型对象</strong></p><p>在上一篇文章<a href="http://wendingding.cn/2018/04/13/javaScript%E7%B3%BB%E5%88%97%20[02]-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/" target="_blank" rel="external">JavaScript系列 [02]-javaScript对象探析</a>中，我们介绍了使用自定义构造函数创建对象的方式，<span style="color:red">在构造函数被创建出来的时候，系统会默认帮构造函数创建并关联一个Object类型的新对象，我们称该对象就是这个构造函数的原型对象，构造函数的原型对象默认是一个空对象。</span></p><h4 id="1-2-原型对象的性质"><a href="#1-2-原型对象的性质" class="headerlink" title="1.2  原型对象的性质"></a>1.2  原型对象的性质</h4><p>构造函数相关联的原型对象的成员（属性和方法），可以被使用该构造函数创建出来的对象访问，即以自定义构造函数方式创建出来的所有实例对象，都自动拥有和共享该构造函数原型对象中的所有属性和方法(<code>想一想为什么空对象可以使用toString方法，所有的数组都可以使用push等方法</code>)。</p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 打印构造函数相关联的原型对象</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype);  <span class="comment">//Objec类型的空对象</span></div><div class="line"></div><div class="line"><span class="comment">//03 给构造函数原型对象添加方法</span></div><div class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p.showName();       <span class="comment">//文顶顶</span></div><div class="line"><span class="built_in">console</span>.log(p);</div></pre></td></tr></table></figure></p><p>代码说明</p><blockquote><p>☞ 上面的代码先提供了Person构造函数，该函数声明后，我们通过Person.prototype访问其原型对象打印得到一个Object类型的空对象，说明所有的构造函数创建后默认拥有prototype属性，即构造函数默认有一个相关联的原型对象（Object类型空对象）。</p><p>☞ 随后我们通过对象的动态特性给Person的原型对象添加了showName方法，通过打印结果可以验证构造函数的实例化对象(p)可以访问其原型对象上面的成员。</p></blockquote><p>通过对代码和其运行结果分析，我们不难得出构造函数（Person）、原型对象(Person.prototype)、实例对象（p）之间的关系图，如下。</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_05.png?raw=true"></p><p><code>代码说明</code></p><blockquote><p><strong>① 实例对象p由Person构造函数实例化而来。</strong></p><p><strong>② Person构造函数可以通过prototype属性访问其原型对象。</strong></p><p><strong>③ 实例对象p可以通过<strong>proto</strong>属性访问其构造函数的原型对象</strong>（可以简称为p的原型对象，我们在说原型对象的时候，应该先确定主语是构造函数还是实例对象，如果主语是构造函数，那么指的是构造函数.prototype，如果主语是实例对象，那么指的是创建该实例对象的构造函数相关联的原型对象，表示为实例对象.<strong>proto</strong>）。</p><p><strong>④ 原型对象（Person.prototype）可以通过constructor(构造器)属性来访问其关联的构造函数，无法访问实例对象。</strong></p></blockquote><p>下面贴出上面代码更详细的原型结构关系图。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_06.png?raw=true"></p><p><strong>原型对象的访问</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//获取原型对象的方式</span></div><div class="line"><span class="comment">//01 构造函数访问原型对象：构造函数.prototype</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype);</div><div class="line"><span class="comment">//02 构造函数的实例对象访问原型对象：实例对象.__proto__</span></div><div class="line"><span class="built_in">console</span>.log(p.__proto__);</div><div class="line"><span class="built_in">console</span>.log(p.__proto__ == Person.prototype);</div><div class="line"><span class="comment">//03 通过Object.getPrototypeOf方法传递实例对象作为参数访问</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(p));</div></pre></td></tr></table></figure></p><p>总结一下，原型对象的访问方式如下</p><pre style="color:red">① 构造函数.prototype② 实例对象.__proto__③ Object.getPrototypeOf(实例对象)</pre><p><strong>原型对象总结</strong></p><blockquote><p>❐  <strong>所有的对象都拥有<code>__proto__</code>属性，函数既拥有prototype属性又拥有<code>__proto__</code>属性。</strong><br>❐  对象的<code>__proto__</code>属性指向其构造函数相关联的原型对象（<code>函数的__proto__属性也一样，指向其构造函数Function相关的原型对象，是一个空函数</code>）。<br>❐  函数的prototype属性指向默认相关联的原型对象（函数和构造函数本质无差别）。</p></blockquote><p><div class="tip"><br> <code>__proto__</code>是一个非标准属性，即ECMAScript中并不包含该属性，这只是某些浏览器为了方便开发人员开发和调试而提供的一个属性，不具备通用性。建议在调试的时候可以使用该属性,但不能出现在正式的代码中，开发中可以使用Object.getPrototypeOf方法来替代。</div></p><div><h4 id="1-3-设置原型对象"><a href="#1-3-设置原型对象" class="headerlink" title="1.3  设置原型对象"></a>1.3  设置原型对象</h4><p>所谓设置原型对象就是给构造函数的原型对象添加成员（属性和方法），具体的方式有两种</p><blockquote><p>① 利用对象的动态特性设置<br>② 替换原有的原型对象</p></blockquote><p>代码示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 给构造函数原型对象添加方法</span></div><div class="line"><span class="comment">//设置原型对象的第一种方法</span></div><div class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"姓名 "</span>+<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line">Person.prototype.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄 "</span>+<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p1.showName();       <span class="comment">//姓名 文顶顶</span></div><div class="line">p1.showAge();        <span class="comment">//年龄 18</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"章飞一绝"</span>,<span class="number">99</span>);</div><div class="line">p2.showName();       <span class="comment">//姓名 章飞一绝</span></div><div class="line">p2.showAge();        <span class="comment">//年龄 99</span></div></pre></td></tr></table></figure><p>像上面代码这样直接利用对象的动态特性来设置原型对象，在原有原型对象的基础上添加属性和方法非常简单，但是如果要添加的方法或属性比较多，那么冗余代码会比较多，这种情况推荐直接替换原有的原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 声明构造函数Person</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 给构造函数原型对象添加方法</span></div><div class="line"><span class="comment">//设置原型对象的第二种方法：直接替换原先的原型对象</span></div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    showName:function () &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"姓名 "</span>+<span class="keyword">this</span>.name);</div><div class="line">    &#125;,</div><div class="line">    showAge:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"年龄 "</span>+<span class="keyword">this</span>.age);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//04 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"文顶顶"</span>);</div><div class="line">p.showName();       <span class="comment">//姓名 文顶顶</span></div><div class="line">p.showAge();        <span class="comment">//年龄 18</span></div><div class="line"><span class="built_in">console</span>.log(p.constructor); <span class="comment">//Person函数</span></div></pre></td></tr></table></figure><p><code>注意</code> 如果是直接替换原型对象，那么需要修正构造器属性，让constructor指向构造函数。<br><code>说明</code> 因为替换的时候其实是用字面量的方式重新创建了新的对象，该对象作为Object构造函数的原型对象，内部没有constructor属性。这个时候如果要通过实例对象（比如p）的构造器属性判断其类型，那么会先在p身上找，没有则查找原型对象发现也没有，最终得到的Object.prototype身上的构造器属性，结果为Object 。</p><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;引用： javaScript是一门基于原型的语言，它允许对象通过原型链引用另一个对象来构建对象中的复杂性，JavaScript使用原型链这种机制来实现动态代理。当试图去引用某一个属性时，它会遍历整个原型链，直到最后的节点。&lt;a href=&quot;http
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [02]-javaScript对象探析</title>
    <link href="https://weibo.com/u/3800117445/2018/04/13/javaScript%E7%B3%BB%E5%88%97%20%5B02%5D-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAjavaScript%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <id>https://weibo.com/u/3800117445/2018/04/13/javaScript系列 [02]-深入浅出javaScript中的对象/</id>
    <published>2018-04-13T06:05:13.000Z</published>
    <updated>2018-05-18T06:28:20.339Z</updated>
    
    <content type="html"><![CDATA[<p><div class="tip"><code>题记：</code>多年前，以非常偶然的方式关注了微信<code>公众号“面向对象”</code>，本以为这个公众号主要以分享面向对象编程的干货为主，不料其乃实实在在的猿圈相亲平台。通过查看公开资料，发现该公众号俨然是在以自己的方式来帮助广大单身程序猿们通往一条真真正正的面向对象编程之路，相对而言，编程和语言特性这些破事又算得了什么呢，先“找到对象”似乎才是更高层面的话题。这篇文章，我们不谈如何”面向对象”，只着力于JavaScript中对象特征、创建以及访问。<br>本文作为纯粹的技术文章，和“面向对象”公众号利益无关。</div></p><p><div></div></p><h4 id="1-1-javaScript中对象的个人档案"><a href="#1-1-javaScript中对象的个人档案" class="headerlink" title="1.1  javaScript中对象的个人档案"></a>1.1  javaScript中对象的个人档案</h4><p>javaScript是一门基于<code>弱类型、支持面向对象编程且基于原型继承的脚本语言</code>。</p><p><strong>对象说明</strong></p><p>在JavaScript语言中，对象是可变的键值对集合（或者称为属性的容器），通过对象我们可以方便的管理一组变量和函数。</p><p>用通俗的话来说，对象其实就是一堆变量和函数的集合。只是“定义”在对象中的变量，我们称为属性，“定义”在对象中的函数，我们称之为方法。</p><p><strong>数据类型和对象</strong></p><p>JavaScript中的数据类型可以分为<code>基本数据类型和复杂数据类型</code>。<br>其中基本数据类型有：数字(number)、字符串(string)、布尔值(boolean)、undefined值和null。</p><p>复杂数据类型可以简单理解为对象类型。在JavaScript中，数组是对象、函数是对象、正则表达式是对象，对象自然也是对象，它们在使用typeof 运算符时得到的结果为object，即对象类型。</p><p><div class="tip"><br>typeof对函数运算的结果为function，对null运算的结果为object，但这被认为是一个错误。</div></p><div><p><span style="red">JavaScript语言中的对象是无类型的</span>，对象可以拥有属性和方法，属性和方法都是以key-value的方式存储的。我们可以笼统的把方法和属性统一归类为属性（因为方法名其实和属性名没有任何本质的区别，属性和方法的分类方式只是对它们存储的内容进行人为区分），所以<code>对象其实就是键值对的集合</code>。</p><p><span style="red">对象通过引用来传递，它们永远不会被复制。</span></p><p><strong>对象的检查</strong></p><p>① 可以使用typeof来对对象类型进行简单的检查，但需要注意排除null的情况。</p><p>② 在开发中，经常会用到hasOwnProperty方法来过滤对象原型成员。</p><h4 id="1-2-javaScript中对象的获取方式"><a href="#1-2-javaScript中对象的获取方式" class="headerlink" title="1.2  javaScript中对象的获取方式"></a>1.2  javaScript中对象的获取方式</h4><p>JavaScript中对象的创建有多种方式，根据特定的应用场景，我们可以选择不同的更合适的方式来创建对象，简单可以归纳为以下情况：</p><blockquote><p>① 字面量的方式创建对象<br>② 内置构造函数创建对象<br>③ 封装工厂函数创建对象<br>④ 定义构造函数创建对象<br>⑤ 调用系统方法创建对象</p></blockquote><p>下面分别对上面列出的这些方式进行逐一介绍。</p><p><strong>字面量的方式创建对象</strong></p><p>基本写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  bookObj = &#123;</div><div class="line">       name:<span class="string">"声名狼藉者的生活"</span>,</div><div class="line">       price:<span class="number">42.00</span>,</div><div class="line">       author:<span class="string">"福柯"</span>,</div><div class="line">       press:<span class="string">"北京大学出版社"</span>,</div><div class="line">       read:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure></p><p>上面的代码中通过字面量的方式创建了bookObj对象，该对象拥有name、price、author和press属性，还拥有read方法。</p><p>对象字面量提供了一种非常方便的创建新对象的表示方法，一个对象就是包围在{}中的N(N&gt;=0)个键值对。对象字面量可以出现在任何允许表达式出现的地方。</p><p><strong>内置构造函数创建对象</strong></p><p>JavaScript中的内置构造函数主要有：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span></div><div class="line"><span class="built_in">Number</span></div><div class="line"><span class="built_in">Boolean</span></div><div class="line"><span class="built_in">Date</span></div><div class="line"><span class="built_in">Array</span></div><div class="line"><span class="built_in">Function</span></div><div class="line"><span class="built_in">Object</span></div><div class="line"><span class="built_in">RegExp</span></div></pre></td></tr></table></figure></p><p><div class="tip">注意：(String Number Boolean 是区别于string number boolean的基本包装类型)</div></p><div><p>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">   book.name = <span class="string">"声名狼藉者的生活"</span>;</div><div class="line">   book.price = <span class="number">42.00</span>;</div><div class="line">   book.author = <span class="string">"福柯"</span>;</div><div class="line">   book.press = <span class="string">"北京大学出版社"</span>;</div><div class="line">   book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="string">"我的书名为:声名狼藉者的的生活,作者为福柯...."</span>);</div><div class="line">   &#125;;</div></pre></td></tr></table></figure><p>这种写法相对字面量创建方式而言不够简洁和直观，而且本身的代码复用性不好，不推荐。</p><p><strong>工厂函数创建对象</strong></p><p>工厂函数方式创建对象其本质是对内置构造函数创建对象的过程进行了封装，适用于大规模“批量生产”同类型的对象。<br>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//提供工厂函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBookNew</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    book.name = name;</div><div class="line">    book.price = price;</div><div class="line">    book.author = author;</div><div class="line">    book.press = press;</div><div class="line">    book.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+book.name+<span class="string">",作者为"</span>+book.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> book;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用工厂函数来创建对象</span></div><div class="line"><span class="keyword">var</span> book1 = createBookNew(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book2 = createBookNew(<span class="string">"人性的枷锁"</span>,<span class="string">"49.00"</span>,<span class="string">"毛姆"</span>,<span class="string">"华东师范大学出版社"</span>);</div><div class="line"><span class="keyword">var</span> book3 = createBookNew(<span class="string">"悟空传"</span>,<span class="string">"28.00"</span>,<span class="string">"今何在"</span>,<span class="string">"湖南文艺出版社"</span>);</div><div class="line"></div><div class="line"><span class="comment">//打印对象的属性,调用对象的方法</span></div><div class="line"><span class="built_in">console</span>.log(book1.name);</div><div class="line"><span class="built_in">console</span>.log(book2.name);</div><div class="line"><span class="built_in">console</span>.log(book3.name);</div><div class="line"></div><div class="line">book1.read();</div><div class="line">book2.read();</div><div class="line">book3.read();</div></pre></td></tr></table></figure><p>总结工厂函数创建对象的实现过程</p><blockquote><p>① 提供一个创建对象的函数（参数）<br>② 在函数内使用new 关键字和构造器创建对象<br>③ 设置对象的属性和方法<br>④ 返回加工过的对象</p></blockquote><p><strong>自定义构造函数创建对象</strong></p><p>基本写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//提供构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateBook</span> (<span class="params">name,price,author,press</span>) </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//使用new调用该构造函数时,默认在内部会先创建Object类型的实例对象</span></div><div class="line">   <span class="comment">//并把该对象关联到当前构造函数的原型对象上，并把函数内的this绑定到该对象</span></div><div class="line">   <span class="comment">//通过this来给实例对象设置属性和方法</span></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.price = price;</div><div class="line">    <span class="keyword">this</span>.author = author;</div><div class="line">    <span class="keyword">this</span>.press = press;</div><div class="line">    <span class="keyword">this</span>.read = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"我的书名为:"</span>+<span class="keyword">this</span>.name+<span class="string">",作者为"</span>+<span class="keyword">this</span>.author+<span class="string">"...."</span>);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">  <span class="comment">//默认总是把新创建的实例对象返回</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用new + 函数名() 的方式来调用</span></div><div class="line"><span class="keyword">var</span> bookObj = <span class="keyword">new</span> CreateBook(<span class="string">"声名狼藉者的的生活"</span>,<span class="string">"42.00"</span>,<span class="string">"福柯"</span>,<span class="string">"北京大学出版社"</span>);</div></pre></td></tr></table></figure><p><div class="tip"><br>构造函数和普通函数没有本质区别，约定使用new调用的构造函数的首字母应该大写。<br>构造函数的作用在于完成对象的初始化，对象的创建等工作由new关键字完成，组合使用。</div></p><div><p><code>工厂函数和构造函数创建对象过程简单对象</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 函数的首字母大写(用于区别构造函数和普通函数)</div><div class="line">② 创建对象的过程是由new关键字实现</div><div class="line">③ 在构造函数内部会自动的创建新对象,并赋值给this指针</div><div class="line">④ 自动返回创建出来的对象</div></pre></td></tr></table></figure><p><code>构造函数调用方式的返回值</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">① 如果在构造函数中没有显示的return，则默认返回的是新创建出来的对象</div><div class="line">② 如果在构造函数中显示的return，则依照具体的情况处理</div><div class="line">❐ return 的是对象类型数据，则直接返回该对象</div><div class="line">❐ return 的是null或其他基本数据类型数据，则返回新创建的对象（即this）</div></pre></td></tr></table></figure></p><p><span style="color:red">提示 </span>在开发中我们通过把自定义构造函数和原型对象结合在一起使用，这样可以充分的利用JavaScript原型链继承的特性并解决方法的共享问题。下面给出基本的代码示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//（1）提供Person构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</div><div class="line"><span class="comment">//（2）替换Person默认的原型对象</span></div><div class="line">Person.prototype =&#123;</div><div class="line">    <span class="comment">//修正构造器属性 Object --&gt; Person</span></div><div class="line">    <span class="keyword">constructor</span>:Person,</div><div class="line">    //提供实例对象的初始化方法</div><div class="line">    init:function(name,age)&#123;</div><div class="line">        <span class="keyword">this</span>.name = name || <span class="string">"默认的姓名"</span>;</div><div class="line">        <span class="keyword">this</span>.age = age || <span class="number">18</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//所有实例对象都需要访问的原型方法</span></div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//（3）使用new来调用构造函数以创建实例对</span></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//（4）调用init方法对实例对象进行初始化操作</span></div><div class="line">p.init(<span class="string">"文顶顶"</span>,<span class="number">20</span>);</div></pre></td></tr></table></figure></p><p><strong>使用Object.create方法创建对象</strong></p><p>ES5提供了Object.create法来创建一个新对象，该方法在使用的时候会把传入的指定对象连接为新对象的原型对象。</p><p><code>语法</code><br><code>Object.create(proto, [propertiesObject])</code></p><p>参数说明<br>第一个参数proto：新创建对象的原型对象。<br>第二个参数propertiesObject：可选的参数，如果没有指定为 undefined，则表示要添加到新创建对象的可枚举属性信息，存放对象的属性描述符以及相应的属性名称。</p><blockquote><p>如果传入的参数为null，则创建出来的空对象不会继承Object原型成员，没有基础方法。<br>如果传入的参数为Object.prototype，那么创建出来的对象等同于{}空对象。</p></blockquote><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 字面量方式创建对象obj</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"wendingding"</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//02 使用Object.create方法来创建新对象</span></div><div class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(obj);</div><div class="line"><span class="comment">//o是一个空对象，o.__proto__指向obj对象</span></div><div class="line"><span class="built_in">console</span>.log(o);</div><div class="line"><span class="comment">//wendingding 访问原型对象obj上面的name属性</span></div><div class="line"><span class="built_in">console</span>.log(o.name);</div><div class="line"></div><div class="line"><span class="comment">//03 测试传入null的情况</span></div><div class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">//打印结果为空对象，No properties 该对象身上没有任何成员</span></div><div class="line"><span class="built_in">console</span>.log(o1);</div><div class="line"></div><div class="line"><span class="comment">//04 测试传入Object.prototype的情况</span></div><div class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</div><div class="line"><span class="comment">//o2 是空对象，等价于&#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(o2);</div></pre></td></tr></table></figure></p><h4 id="1-3-javaScript中对象的操作"><a href="#1-3-javaScript中对象的操作" class="headerlink" title="1.3  javaScript中对象的操作"></a>1.3  javaScript中对象的操作</h4><p>我们知道对象可以简单理解为键值对的集合，通过前面的阅读我们已经了解到如何创建对象，接下来我们接着探讨对象内部键值对的相关操作。</p><p>对象属性和方法的访问方式：点语法或者是[]语法。<br>对象属性和方法的操作方式：对象的操作方式和数据的操作方式保持一致，可以简单总结为<code>增删改查和遍历</code>操作。</p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//00 提供obj对象</span></div><div class="line"><span class="comment">//通过字面量方式创建obj对象，该对象现在拥有name属性和showName方法</span></div><div class="line"><span class="comment">//因使用字面量方式创建，所有obj的原型对象(__proto__)指向object.prototype</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name:<span class="string">"wendingding"</span>,</div><div class="line">    showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//01 添加属性或方法</span></div><div class="line"><span class="comment">//a 使用点语法来为obj对象添加age属性和showAge方法</span></div><div class="line">obj.age = <span class="number">18</span>;</div><div class="line">obj.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//b 使用中括号语法来为obj对象添加age属性和showAge方法</span></div><div class="line">obj[<span class="string">"class-name"</span>] = <span class="number">41</span>;</div><div class="line">obj[<span class="string">"showClassName"</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>[<span class="string">"class-name"</span>]);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//02 修改属性或方法</span></div><div class="line"><span class="comment">//如果对象的属性已经存在，那么设置该属性的时候表示修改</span></div><div class="line">obj.age = <span class="number">20</span>;</div><div class="line">obj.showAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄"</span> + <span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 查询属性或者调用方法</span></div><div class="line"><span class="built_in">console</span>.log(obj.name);      <span class="comment">//wendingding</span></div><div class="line"><span class="built_in">console</span>.log(obj[<span class="string">"age"</span>]);    <span class="comment">//20</span></div><div class="line">obj.showName();             <span class="comment">//wendingding</span></div><div class="line">obj[<span class="string">"showName"</span>]();          <span class="comment">//注意，不推荐使用这种方法</span></div><div class="line"></div><div class="line"><span class="comment">//04 删除对象中的属性或方法</span></div><div class="line"><span class="comment">//语法形式：delete 对象.属性 | delete 对象[属性]</span></div><div class="line"><span class="keyword">delete</span> obj.name;</div><div class="line"><span class="keyword">delete</span> obj[<span class="string">"showName"</span>];</div><div class="line"><span class="built_in">console</span>.log(obj);</div><div class="line"></div><div class="line"><span class="comment">//05 对象的遍历</span></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> obj)</div><div class="line">&#123;</div><div class="line">     <span class="built_in">console</span>.log(key, obj[<span class="string">"key"</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>delete关键字说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">01 具体使用:</div><div class="line">        (1) 可以用来删除对象中指定的属性</div><div class="line">        (2) 用来删除没有使用var关键字声明的变量  delete 变量名|window.变量</div><div class="line">02 使用注意点</div><div class="line">        (1) 关键字在使用的时候有返回值,true|false 删除成功返回true</div><div class="line">        (2) 删除对象中不存在的属性,返回true</div><div class="line">        (3) 使用var声明的变量不能被直接删除</div><div class="line">        (4) 不能删除使用var声明的全局变量但是可以删除直接添加在window上面的属性</div><div class="line">        (5) 如果删除数组中的元素（数组也是对象）则数组中对应的元素内容被替换为undefined，索引保留。</div></pre></td></tr></table></figure></p><p><strong>对象属性说明</strong></p><blockquote><p>❐ 对象的属性名可以是任意字符串，包括空字符。<br>❐ 对象的属性名如果是合法的JavaScript标识符，则不必强制要求使用双引号括住属性名。<br>❐ 属性值可以是任何值（包括undefined）。<br>❐ 如果对象的属性名并非合法标识符，则建议使用[]语法来访问对象。<br>❐ 标识符规范：字母开头，后面跟1个或多个下划线、数字或字母。</p></blockquote><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;div class=&quot;tip&quot;&gt;&lt;code&gt;题记：&lt;/code&gt;多年前，以非常偶然的方式关注了微信&lt;code&gt;公众号“面向对象”&lt;/code&gt;，本以为这个公众号主要以分享面向对象编程的干货为主，不料其乃实实在在的猿圈相亲平台。通过查看公开资料，发现该公众号俨然是在以自己的
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>javaScript系列 [01]-javaScript函数基础</title>
    <link href="https://weibo.com/u/3800117445/2018/04/11/javaScript%E7%B3%BB%E5%88%97%20%5B01%5D-javaScript%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC/"/>
    <id>https://weibo.com/u/3800117445/2018/04/11/javaScript系列 [01]-javaScript函数基本/</id>
    <published>2018-04-11T14:05:13.000Z</published>
    <updated>2018-05-18T06:28:20.349Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-函数的创建和结构"><a href="#1-1-函数的创建和结构" class="headerlink" title="1.1  函数的创建和结构"></a>1.1  函数的创建和结构</h4><p><strong>函数的定义</strong>：函数是JavaScript的基础模块单元，包含一组语句，用于代码复用、信息隐蔽和组合调用。</p><p><strong>函数的创建</strong>：在javaScript语言中，可以说函数是其最重要也最成功的设计。我们可以通过三种方式来创建函数。</p><p><code>① 函数声明</code><br><code>② 字面量方式创建</code><br><code>③ 使用Function构造函数创建</code></p><p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 函数声明</span></div><div class="line"><span class="comment">//函数名称为：f1,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 字面量创建函数</span></div><div class="line"><span class="comment">//使用字面量创建匿名函数并赋值给f2,可以通过f2来调用,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 构造函数创建</span></div><div class="line"><span class="comment">//f3函数为Function这个构造函数的实例化对象，如果不传递参数，那么创建出来的函数没有任何用处。</span></div><div class="line"><span class="comment">//在创建实例对象的时候我们可以通过参数列表的方式来指定f3的结构。</span></div><div class="line"><span class="comment">//构造函数的参数中最后一个参数为函数体的内容，其余均为函数的形参。</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数的调用</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f2(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div></pre></td></tr></table></figure></p><p><strong>函数的结构</strong><br>函数的一般表现形式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1,n2</span>) </span>&#123;</div><div class="line">    <span class="comment">//函数体的内容</span></div><div class="line">    <span class="keyword">return</span> n1 + n2; <span class="comment">//返回值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通常，函数包括四个部分：<br>（1）保留字，function。<br>（2）函数名，这里为fn。<br>（3）圆括号以及包围在圆括号中的一组参数。<br>（4）包括在花括号中的一组语句。</p><blockquote><p>❐ 函数名可以被省略（称为匿名函数），函数名可用于函数调用或者是递归调用，另外函数名可以被调试器和开发工具识别。</p><p>❐ 函数声明时的参数为形参，可以有多个，多个参数之间使用逗号进行分隔。<code>形参将在函数调用的时候被定义为函数中的局部变量，[注意]形参并不会像普通变量一样被初始化为undefined，它们的值根据函数调用时传入的实际参数值设置。</code>另外，函数调用的时候并不会对实参的类型进行检查。</p><p>❐ 函数体是一组语句，它们在函数<code>被调用</code>的时候执行。函数执行完毕后，会返回一个值。</p></blockquote><p> <strong>函数的调用</strong>：函数声明后可以通过（）运算符来进行调用，JavaScript语言中，只有函数可以被调用。当函数被调用的时候，如果存在参数传递，那么会把实参的值传递给形参，并按照从上到下的顺序逐条执行函数体内部的代码。</p><h4 id="1-2-函数和对象的关系"><a href="#1-2-函数和对象的关系" class="headerlink" title="1.2  函数和对象的关系"></a>1.2  函数和对象的关系</h4><p>JavaScript中的函数本质上就是对象。<br>在使用typeof 关键字对数据进行类型检查的时候，得到的结果可能会让我们产生错觉。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">   <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);      <span class="comment">//object</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);      <span class="comment">//function</span></div></pre></td></tr></table></figure></p><p>实际上，函数和对象没有质的区别，函数是特殊的对象。</p><blockquote><p>函数的特殊性<br>① 函数可以被（）运算符调用[最重要]。<br>② 函数可以创建独立的作用域空间。<br>③ 函数拥有标配的prototype属性。</p></blockquote><p>因为函数本身就是对象，所以在代码中函数可以像对象一样被使用，凡是对象可以出现的地方函数都可以出现。</p><blockquote><p>❐ 函数可以拥有属性和方法。<br>❐ 函数可以保存在变量、对象和数组中。<br>❐ 函数可以作为其它函数的参数（称为函数回调）。<br>❐ 函数可以作为函数的返回值进行返回。</p></blockquote><p><strong>函数和对象的原型链结构</strong><br>我们可以通过下面列出的简单示例代码来分析对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//字面量方式创建普通的对象</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">age</span>:<span class="string">"18"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//关于普通对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印o对象\n"</span>,o);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印o.__proto__\n"</span>,o.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印o.__proto__ === Object.prototype\n"</span>,o.__proto__ === <span class="built_in">Object</span>.prototype)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印o.constructor\n"</span>,o.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印o.constructor === Object\n"</span>,o.constructor === <span class="built_in">Object</span>);</div></pre></td></tr></table></figure></p><p>通过对该代码的运行和打印分析，可以得到下面的图示。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_01.png?raw=true"></p><p>我们也可以使用同样的方式来分析函数对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//使用构造函数Function 来创建函数(对象)</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"><span class="comment">//调用函数，证明该函数是合法可用的</span></div><div class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">//得到打印结果5</span></div><div class="line"></div><div class="line"><span class="comment">//关于函数对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印函数对象\n"</span>,f);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印f.__proto__\n"</span>,f.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印f.__proto__===Function.prototype\n"</span>,f.__proto__===<span class="built_in">Function</span>.prototype);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印f.constructor\n"</span>,f.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印f.constructor === Function\n"</span>,f.constructor === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意</span></div><div class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">"constructor"</span>));   <span class="comment">//检查constructor是否为函数f的实例成员(false)</span></div><div class="line"><span class="built_in">console</span>.log(f.__proto__.hasOwnProperty(<span class="string">"constructor"</span>)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>顺便贴出研究Function原型结构的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//说明：下面三行代码表明Function的原型对象指向一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);  <span class="comment">//ƒ () &#123; [native code] &#125;  是一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Function</span>.prototype));  <span class="comment">//[object Function]</span></div><div class="line"></div><div class="line"><span class="comment">//检查Function.prototype的原型链结构</span></div><div class="line"><span class="comment">//Function.prototype是一个空函数，是一个对象，而对象均由构造函数实例化产生</span></div><div class="line"><span class="comment">//检查Function.prototype的构造函数以及原型对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor  === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意：按照一般逻辑实例对象的__proto__(原型对象)应该指向创建该实例对象的构造函数的原型对象</span></div><div class="line"><span class="comment">//即此处应该表现为Function.prototype.__proto__---&gt;Function.prototype.constructor.prototype</span></div><div class="line"><span class="comment">//似乎可以得出推论：Function.prototype.__proto__ === Function.prototype == 空函数 但这是错误的</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</div></pre></td></tr></table></figure></p><p>通过对函数对象原型结构的代码探索，可以得到下图的原型链结构图（<code>注</code>：原型链并不完整）</p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_02.png?raw=true"></p><p><strong>函数的其它隐藏细节</strong></p><p><span style="color:#ff3333">① 函数天生的prototype属性<span></span></span></p><p>每个函数对象在创建的时候会随配一个prototype属性，即每个函数在创建之后就天生拥有一个与之相关联的原型对象，这个关联的原型对象中拥有一个constructor属性，该属性指向这个函数。<br>简单描述下就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function f()&#123; //......&#125;  //声明函数</div><div class="line">//函数声明被创建后，默认拥有prototype属性---&gt;原型对象（空对象）</div></pre></td></tr></table></figure></p><p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_03.png?raw=true"></p><p><div class="tip"><br>这里需要注意的是，很多人容易被自己的经验误导，认为新创建的函数对象身上除prototype实例属性外，还拥有constructor这个实例属性，因为我们经常看到<code>f.constructor类似的代码</code>，其实这里使用的constructor属性是从原型链中获取的，其实是f构造函数关联原型对象上面的属性，即Function.prototype.constructor。</div></p><div><p style="border: 1px solid #666;">备注：在<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-13.2" target="_blank" rel="external">ECMAScript标准中函数创建相关章节</a>有这样一句话：NOTE A prototype property is automatically created for every function, to allow for the possibility that the function will be used as a constructor.解释了给新创建函数添加prototype属性的意义在于便于该函数作为构造函数使用。</p><p><span style="color:#ff3333">② 函数何以能够被调用<span></span></span></p><p>我们已经理解了函数本身就是对象，但又区别于普通对象，最大的区别在于函数可以被调用，（）被称为调用运算符。</p><blockquote><p>❗️ 函数可以被调用的原因在于JavaScript创建一个函数对象时，会给该对象设置一个“调用”属性。当JavaScript调用一个函数时，可以理解为调用该函数的“调用”属性。</p></blockquote><h4 id="1-3-函数的调用和this参数"><a href="#1-3-函数的调用和this参数" class="headerlink" title="1.3  函数的调用和this参数"></a>1.3  函数的调用和this参数</h4><p>函数名后面跟上（）表明这是一个函数调用。<br><code>调用运算符：</code>是跟在任何产生一个函数值的表达式之后的一对圆括号。圆括号内可以包含N（N&gt;=0）个用逗号分隔开的表达式，每个表达式产生一个参数值。每个参数值被赋予函数声明时定义的形式参数名。</p><p><strong>函数的调用</strong><br>JavaScript中有四种调用函数的模式</p><p><code>① 对象方法调用模式</code><br><code>② 普通函数调用模式</code><br><code>③ 构造函数调用模式</code><br><code>③ 上下文的调用模式</code></p><p>除了声明函数时定义的形参外，每个函数还接收两个附加的参数，分别是this和arguments。其中arguments用于存储函数调用时接收到的实际参数，this的值则取决于函数的调用模式，下面分别讲解。</p><p><strong>普通函数调用模式</strong></p><p>当函数并不作为其他对象的属性，直接使用调用运算符来调用时，我们认为它使用<code>普通函数调用模式</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="comment">//01 声明函数fn</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//02 以普通函数调用模式来调用fn函数</span></div><div class="line">    fn(); <span class="comment">//this被绑定到全局对象window</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><p style="border: 1px solid #666;">备注：在我们看来上面的调用方式非常简单清楚，而且this的指向也没有任何问题。但<a href="http://json.org/" target="_blank" rel="external">JSON</a>的作者<a href="https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9" target="_blank" rel="external">Douglas Crockford</a>指出这是JavaScript语言设计上的一个错误。因为把this直接绑定给全局变量的方式没有考虑到函数作为内部函数（在其它函数内部声明的函数）使用过程中需要共享外部对象访问权的问题。<br>他指出正确的语言设计应该是，<code>当内部函数被调用时，函数内的this应该和外部函数的this保持一致，即这个this应该被绑定到外部函数的this变量。</code>无疑，这值得思考和讨论。</p><p><strong>对象方法调用模式</strong></p><p>对象是键值对的集合，对象可以拥有属性和方法。<br>当函数被保存为对象的属性时，我们称之为方法。<br>对象的方法需要通过<code>对象.方法（）</code>或者是<code>对象[方法]（）</code>的方式进行调用。<br>以对象方法的模式来对函数进行调用，函数内部的this被绑定给该对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 字面量的方式创建对象</span></div><div class="line">   <span class="comment">//02 o对象中拥有name属性和showName方法</span></div><div class="line">   <span class="keyword">var</span> o = &#123;</div><div class="line">       name:<span class="string">"文顶顶"</span>,</div><div class="line">       showName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);   <span class="comment">//文顶顶</span></div><div class="line">       &#125;&#125;;</div><div class="line"></div><div class="line">   <span class="comment">//03 以对象方法调用模式来调用showName函数</span></div><div class="line">   o.showName(); <span class="comment">//this被绑定到o对象</span></div></pre></td></tr></table></figure></p><p>❗️ this到对象的绑定发生在方法调用的时候。</p><p><strong>构造函数调用模式</strong></p><p><code>构造函数：</code>如果一个函数创建出来之后，我们总是希望使用new 前缀来调用它，那这种类型的函数就被称为构造函数。构造函数和普通函数本质上没有任何区别，开发者总是约定以函数名首字母大写的方式来人为进行区分。</p><p>如果以构造函数的方式来调用函数，那么在调用时，默认会创建一个连接到该构造函数原型对象上面的新对象，同时让this绑定到该新对象上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 声明构造函数Person</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//02 以构造函数的方式来调用Person</span></div><div class="line">   <span class="keyword">new</span> Person();  <span class="comment">//this被绑定到Person的实例化对象</span></div></pre></td></tr></table></figure><p>❗️ 构造函数调用方式也会改变函数中return语句的行为，如果显示的return语句后面跟着的不是对象类型的数据，那么默认返回this绑定的新对象。</p><p><strong>上下文的调用模式</strong></p><p>上下文的调用模式，即使用apply或则call方法来调用函数。<br>因为JavaScrip是一门函数式的面向对象编程语言，所有JavaScript中的函数本质上是对象，也因此函数也可以拥有方法。使用上下文模式对函数进行调用的时候，函数内部的this根据参数传递的情况进行绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明函数f</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(a, b, a+b);</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>);       <span class="comment">//使用上下文模式调用时，this被绑定给o对象</span></div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">//wendingding</span></div><div class="line">   &#125;</div><div class="line">   <span class="comment">//字面量的方式创建对象</span></div><div class="line">   <span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"wendingding"</span>&#125;;</div><div class="line"></div><div class="line">   <span class="comment">//使用apply和call方法来调用函数</span></div><div class="line">   f.apply(o, [<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line">   f.call(o,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">"apply"</span>));                 <span class="comment">//false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.hasOwnProperty(<span class="string">"apply"</span>));<span class="comment">//true</span></div></pre></td></tr></table></figure><blockquote><p>❐  apply和call方法调用函数，函数内部的this绑定给第一个参数。<br>❐  apply和call方法定义于Function的原型对象上，所以所有的函数都可访问。<br>❐  apply和call方法作用基本相同，参数传递的形式有所差别。</p></blockquote><h4 id="1-4-函数的参数（arguments）"><a href="#1-4-函数的参数（arguments）" class="headerlink" title="1.4  函数的参数（arguments）"></a>1.4  函数的参数（arguments）</h4><p>函数调用时，会完成实际参数对形式参数的赋值工作。<br>当实际参数的个数和形式参数的个数不匹配时，并不会导致运行错误。</p><blockquote><p>如果实际参数的数量过多，那么超出的那些参数会被忽略。<br>如果实际参数的数量不足，那么缺失的那些参数会被设置为undefined。<br>JavaScript在进行函数调用时不会对参数进行任何的类型检查。</p></blockquote><p>在函数的内部，我们总是可以获得一个免费配送的arguments参数。<br>arguments用于接收函数调用时传入的实际参数，它被设计成一个类似于数组的结构，拥有length属性，但因为它不是一个真正的数组所以不能使用任何数组对应的方法。</p><p>arguments参数的存在，使得我们可以编写一些无须指定形参个数的函数。<br>下面提供一份示例代码用于对传入的所有参数进行累加计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">var</span> count = <span class="built_in">arguments</span>.length;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            sum += <span class="built_in">arguments</span>[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">89</span>));   <span class="comment">//125</span></div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure></p><h4 id="1-5-函数的返回值"><a href="#1-5-函数的返回值" class="headerlink" title="1.5  函数的返回值"></a>1.5  函数的返回值</h4><p><strong>函数的调用</strong>：调用一个函数会暂停当前代码的执行，把控制权和参数传递给正被调用的函数。当一个函数被调用的时候，它会先根据实际参数来对函数的形式参数进行初始化，然后从函数体中的第一个语句开始执行并遇到关闭函数体的 } 时结束。然后把控制权交还给调用该函数的上下文。</p><p><strong>函数的返回值</strong>：函数体中return语句可以用来让函数提前返回。当retun语句被执行时，函数会立即返回而不再执行余下的语句，return语句后面跟上返回的具体数据，可以是任意类型（包括函数）。</p><blockquote><p>❐ 函数总是会有一个返回值，如果没有使用return语句指定，那么将总是返回<code>undefined</code>。</p><p>❐ 函数的返回值还和它的调用方式有关系，如果使用new也就是也构造函数的方式来调用，若函数体中没有通过return语句显示的返回一个对象类型的数据，则<code>默认返回this（新创建的实例对象）</code>。</p><p>❗️ JavaScript不允许在return关键字和表达式之间换行。</p></blockquote><hr><ul><li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.com" target="_blank" rel="external">文顶顶的个人博客_花田半亩</a></li><li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li><li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li></ul><p><img src="https://github.com/flowerField/Source/blob/master/Blog/zanshang.jpeg?raw=true" width="180" height="180"></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-1-函数的创建和结构&quot;&gt;&lt;a href=&quot;#1-1-函数的创建和结构&quot; class=&quot;headerlink&quot; title=&quot;1.1  函数的创建和结构&quot;&gt;&lt;/a&gt;1.1  函数的创建和结构&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;函数的定义&lt;/strong&gt;：函数是Ja
      
    
    </summary>
    
    
      <category term="javaScript系列" scheme="https://weibo.com/u/3800117445/tags/javaScript%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
