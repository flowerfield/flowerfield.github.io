<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>  · 花田半亩</title><meta name="description" content=" - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/鲸鱼.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶的BLOG</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">标签</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place" target="_blank" class="nav-list-link">微博</a></li><li class="nav-list-item"><a href="http://blog.sina.com.cn/u/1910914290" target="_blank" class="nav-list-link">花田半亩</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title"></h1><div class="post-info">Oct 12, 2018<span class="post-count"></span> ✧ 字数统计:2,466(字) &nbsp;&nbsp; ♨︎ 阅读时长:11(分钟)</div><div class="post-content"><p>//  jQuery中的插件处理机制<br>//    给jQuery添加extend扩展方法，即jQuery.extend()<br>//    给jQuery的原型对象添加extend扩展方法,即jQuery.prototype.extend()<br>//    这两个的方法的作用简单来说就是把传入参数(对象类型)中所有的方法都添加到jQuery或者是jQuery原型对象上面<br>//  这里给出一个简陋的实现版本,内部使用了this根据当前上下文的不同，指代的可能是jQuery或者是jQuery.prototype<br>//     jQuery.extend = jQuery.fn.extend = function (objT) {<br>//         for (var key in objT)<br>//         {<br>//             if (Object.hasOwnProperty(key))<br>//             {<br>//                 this[key] = objT[key];<br>//             }<br>//         }<br>//     };</p>
<p>jQuery.extend = jQuery.fn.extend = function() {<br>    //声明一堆的变量length 为实参的个数<br>    var options, name, src, copy, copyIsArray, clone,<br>        target = arguments[ 0 ] || {},<br>        i = 1,<br>        length = arguments.length,<br>        deep = false;</p>
<pre><code>// Handle a deep copy situation
if ( typeof target === &quot;boolean&quot; ) {
    deep = target;

    // Skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
}

// Handle case when target is a string or something (possible in deep copy)
if ( typeof target !== &quot;object&quot; &amp;&amp; !isFunction( target ) ) {
    target = {};
}

// Extend jQuery itself if only one argument is passed
if ( i === length ) {
    target = this;
    i--;
}

for ( ; i &lt; length; i++ ) {

    // Only deal with non-null/undefined values
    if ( ( options = arguments[ i ] ) != null ) {

        // Extend the base object
        for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
                continue;
            }

            // Recurse if we&apos;re merging plain objects or arrays
            if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||
                ( copyIsArray = Array.isArray( copy ) ) ) ) {

                if ( copyIsArray ) {
                    copyIsArray = false;
                    clone = src &amp;&amp; Array.isArray( src ) ? src : [];

                } else {
                    clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {};
                }

                // Never move original objects, clone them
                target[ name ] = jQuery.extend( deep, clone, copy );

            // Don&apos;t bring in undefined values
            } else if ( copy !== undefined ) {
                target[ name ] = copy;
            }
        }
    }
}

// Return the modified object
return target;
</code></pre><p>};</p>
<p>//为jQuery添加一堆工具方法,对象参数中所有的成员都将直接添加在jQuery函数身上成为jQuery的静态方法<br>jQuery.extend( {</p>
<pre><code>// Unique for each copy of jQuery on the page
// 简单测试下得到的结果是：jQuery33104605303773584173
// 确保页面中的jQuery副本是唯一的，（jQuery + 版本号 + 随机数） =&gt; 格式处理
expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

// Assume jQuery is ready without the ready module
// 是否已经准备就绪
isReady: true,
//错误处理方法：根据传入的消息创建一个错误对象并抛出异常
error: function( msg ) {
    throw new Error( msg );
},
//空函数
noop: function() {},

//用于判断指定参数是否是一个纯粹的对象
//所谓&quot;纯粹的对象&quot;，就是该对象是通过&quot;{}&quot;或&quot;new Object&quot;创建的 .排除了数组、自定义构造函数创建的对象以及函数等类型
isPlainObject: function( obj ) {
    var proto, Ctor;

    // Detect obvious negatives
    // Use toString instead of jQuery.type to catch host objects

    //如果参数为null | undefined 或者在调用Object.prototype.toString.call(参数)的时候得到的结果不是[object Object]则直接返回false
    if ( !obj || toString.call( obj ) !== &quot;[object Object]&quot; ) {
        return false;
    }

    //获取当前对象的原型对象，其实是调用了Object.getPrototypeOf(参数) 方法
    proto = getProto( obj );

    // Objects with no prototype (e.g., `Object.create( null )`) are plain
    //监测 没有原型对象的最纯净的对象 例如使用Object.create( null )创建的对象

    if ( !proto ) {
        return true;
    }

    // Objects with prototype are plain iff they were constructed by a global Object function
    //如果原型对象上拥有constructor属性(前一句的结果为true) 那么就返回proto.constructor的值
    //如果原型对象是Object.prototype 那么Object.prototype.constructor ==&gt; ƒ Object() { [native code] }
    Ctor = hasOwn.call( proto, &quot;constructor&quot; ) &amp;&amp; proto.constructor;

    //检查Ctor是否是函数 且函数字符串是否全等于function Object() { [native code] }
    return typeof Ctor === &quot;function&quot; &amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString;
},

//用于判断指定参数是否是一个空对象
//所谓&quot;空对象&quot;，即不包括任何可枚举(自定义)的属性。简而言之，就是该对象没有属性可以通过for...in迭代。
isEmptyObject: function( obj ) {

    /* eslint-disable no-unused-vars */
    // See https://github.com/eslint/eslint/issues/6125
    var name;

    for ( name in obj ) {
        return false;
    }
    return true;
},

// Evaluates a script in a global context
//用于全局性地执行一段JavaScript代码,内部调用DOMEval方法实现
//其作用与常规的JavaScript eval()函数相似。区别自傲与jQuery.globalEval()执行代码的作用域为全局作用域。
//使用示例：$.globalEval( &quot;var a =1&quot; ); 该行代码将在全局作用域中定义变量a
globalEval: function( code ) {
    DOMEval( code );
},

//常用的迭代方法，可以用来遍历数组|对象|jQ实例对象(伪数组)
//该方法同$(&quot;xxx&quot;).each() 方法保持一致
//第一个参数：要遍历的对象| 数组 | jQ实例对象
each: function( obj, callback ) {
    var length, i = 0;

    //如果参数是伪数组那么使用普通的for循环来进行遍历
    if ( isArrayLike( obj ) ) {
        length = obj.length;
        for ( ; i &lt; length; i++ ) {
            //调用回到函数，把当前的value值绑定给函数的this [each方法的回调函数中this--&gt; value值]
            //把当前循环的key和value值(这里是i和obj[i])作为参数传递给callback回调函数
            //检查回调函数的返回值，如果返回的是false，那么就退出循环
            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
            }
        }
    } else {
        //如果是普通的对象那么使用for..in循环来进行遍历
        for ( i in obj ) {
            //同上面的代码保持一致
            if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
                break;
            }
        }
    }

    //把遍历的对象返回,链式编程的代码风格
    return obj;
},

// Support: Android &lt;=4.0 only
// 工具方法，用于清空字符串前面或者是后面的N个空格
// 在ES5中js提供了原生的trim方法来清除字符串前后的1个或多个空格
// 这里主要是通过正则表达式去进行匹配，把匹配到的内容替换为空字符串&quot;&quot;
trim: function( text ) {
    return text == null ?
        &quot;&quot; :
        ( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
},

// results is for internal usage only
// 结果仅共内部使用
// 该函数用于将一个类数组对象(伪数组)转换为真正的数组对象
// 所谓&quot;类数组对象&quot;就是一个常规的Object对象，但它和数组对象非常相似：具备length属性，并以0、1、2、3……等数字作为属性名。
makeArray: function( arr, results ) {
    // 初始化ret为空数组
    var ret = results || [];

    if ( arr != null ) {
        //检查传入的参数是否是伪数组
        if ( isArrayLike( Object( arr ) ) ) {
            //如果是伪数组，那么合并ret和arr 并返回
            //如果arr是字符串那么jQuery.merge(ret,[arr]) ，否则jQuery.merge(ret,arr)
            jQuery.merge( ret,
                typeof arr === &quot;string&quot; ?
                [ arr ] : arr
            );
        } else {
            //如果参数不是伪数组，那么直接把arr中的每个数据都添加到新的数组中
            //push.call( ret, arr ) 就是是 [].push.call(ret,arr) =&gt; [].push(arr)
            push.call( ret, arr );
        }
    }
    //返回处理完的数组对象
    return ret;
},

// 该方法用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。
// 第一个参数 用于查找的值
// 第二个参数 指定被查找的数组
// 第三个参数 指定从数组的指定索引位置开始查找，默认为 0
// 如果数组中存在多个相同的值，则以查找到的第一个值的索引为准
// 使用示例：$.inArray(&quot;文顶顶&quot;,[&quot;demoA&quot;,&quot;demoB&quot;,&quot;wendingding.com&quot;,&quot;文顶顶&quot;,&quot;demoC&quot;,&quot;end&quot;],4)
// 上面的代码表示从数组中索引为4的位置开始查找&quot;文顶顶&quot;这个元素项，返回的结果为-1，最后一个参数不传递则返回3
inArray: function( elem, arr, i ) {
    //如果参数是null或undefined那么直接返回-1
    //否则通过调用indexOf方法实现 indexOf.call( arr, elem, i ) =&gt; arr.indexOf(elem,i)
    return arr == null ? -1 : indexOf.call( arr, elem, i );
},

// Support: Android &lt;=4.0 only, PhantomJS 1 only
// push.apply(_, arraylike) throws on ancient WebKit
//该方法用于合并两个数组
merge: function( first, second ) {
    var len = +second.length,
        j = 0,
        i = first.length;

    for ( ; j &lt; len; j++ ) {
        //通过普通的for循环来遍历第二个数组
        //把第二个数组的元素依次追加在第一个数组的后面
        first[ i++ ] = second[ j ];
    }

    //更新数组的长度值
    first.length = i;

    return first;
},

// 过滤函数用于过滤数组
// 参数1 待过滤的数组
// 参数2 过滤数组的具体函数
// 参数3 布尔类型的值
//         为true则函数返回数组中由过滤函数返回 true 的元素
//      为false则函数返回数组中由过滤函数返回false的元素
grep: function( elems, callback, invert ) {

    //初始化一堆的变量
    var callbackInverse,
        matches = [],   //空数组
        i = 0,            //索引值为0
        length = elems.length,    //待过滤数组的长度
        callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i &lt; length; i++ ) {
        //每循环一次就把当前的元素和对应的索引传递给回调函数，并保存回调函数的返回值取反
        callbackInverse = !callback( elems[ i ], i );
        if ( callbackInverse !== callbackExpect ) {
            //把过滤后的元素收集保存到新的数组中
            matches.push( elems[ i ] );
        }
    }

    //返回过滤后得到的数据，是一个新的数组
    return matches;
},

// arg is for internal usage only
// arg仅用于内部使用的情况
// 数组映射方法( 将一个数组中的元素转换到另一个数组中 )
// 参数1 ：待处理的数组
// 参数2 : 具体的处理函数
// 参数3 : arg
map: function( elems, callback, arg ) {

    //初始化一堆的变量
    var length, value,
        i = 0,            //索引值为0
        ret = [];        //ret为空的数组

    // Go through the array, translating each of the items to their new values
    // 遍历数组把数组中的每一项都转换为一个新的值

    //检查是否是伪数组
    if ( isArrayLike( elems ) ) {
        length = elems.length;        //获取待处理的伪数组的长度
        for ( ; i &lt; length; i++ ) {
            //循环，每循环一次就调用处理函数并把当前的key和value值作为参数传递进去
            //收集回调函数的返回值
            value = callback( elems[ i ], i, arg );

            //如果回调函数的范返回值不为空，那么就把该返回值添加到数组中并最终返回
            if ( value != null ) {
                ret.push( value );
            }
        }

    // Go through every key on the object,
    //    如果是普通的对象，那么就使用for...in循环来进行遍历
    } else {
        for ( i in elems ) {
            value = callback( elems[ i ], i, arg );

            if ( value != null ) {
                ret.push( value );
            }
        }
    }

    // Flatten any nested arrays
    // 等价于 [].concat(ret) 问题：为什么不直接范湖ret数组呢？
    return concat.apply( [], ret );
},

// A global GUID counter for objects
// 全局的GUID计数器
guid: 1,

// jQuery.support is not used in Core but other projects attach their
// properties to it so it needs to exist.
// 就是个空对象 {} 不在核心中使用，但其他项目将它们的属性附加到它，因此它需要存在。
support: support
</code></pre><p>} );</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/10/09/jQuery系列 [11]-jQuery框架源码解读[插件]/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://weibo.com/u/3800117445">文顶顶</a> &nbsp;☁ 全站字数统计201.7k(字)</p><!--p © #{year} #[a(href=config.url)!= config.author], powered by #[a(href=hexoURL, target="_blank") Hexo] and #[a(href=apolloURL, target="_blank") hexo-theme-apollo].--></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>