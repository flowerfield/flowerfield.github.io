<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javaScript系列 [01]-javaScript函数基础 · 花田半亩</title><meta name="description" content="javaScript系列 [01]-javaScript函数基础 - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/白菜.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶的BLOG</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://blog.sina.com.cn/u/1910914290" target="_blank" class="nav-list-link">花田半亩</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">javaScript系列 [01]-javaScript函数基础</h1><div class="post-info">Apr 11, 2018</div><div class="post-content"><h4 id="1-1-函数的创建和结构"><a href="#1-1-函数的创建和结构" class="headerlink" title="1.1  函数的创建和结构"></a>1.1  函数的创建和结构</h4><p><strong>函数的定义</strong>：函数是JavaScript的基础模块单元，包含一组语句，用于代码复用、信息隐蔽和组合调用。</p>
<p><strong>函数的创建</strong>：在javaScript语言中，可以说函数是其最重要也最成功的设计。我们可以通过三种方式来创建函数。</p>
<p><code>① 函数声明</code><br><code>② 字面量方式创建</code><br><code>③ 使用Function构造函数创建</code></p>
<p>代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 函数声明</span></div><div class="line"><span class="comment">//函数名称为：f1,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 字面量创建函数</span></div><div class="line"><span class="comment">//使用字面量创建匿名函数并赋值给f2,可以通过f2来调用,a和b为该函数的形式参数（形参）</span></div><div class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//03 构造函数创建</span></div><div class="line"><span class="comment">//f3函数为Function这个构造函数的实例化对象，如果不传递参数，那么创建出来的函数没有任何用处。</span></div><div class="line"><span class="comment">//在创建实例对象的时候我们可以通过参数列表的方式来指定f3的结构。</span></div><div class="line"><span class="comment">//构造函数的参数中最后一个参数为函数体的内容，其余均为函数的形参。</span></div><div class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"></div><div class="line"><span class="comment">//函数的调用</span></div><div class="line"><span class="built_in">console</span>.log(f1(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f2(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div><div class="line"><span class="built_in">console</span>.log(f3(<span class="number">1</span>,<span class="number">2</span>));    <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p><strong>函数的结构</strong><br>函数的一般表现形式为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数声明</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n1,n2</span>) </span>&#123;</div><div class="line">    <span class="comment">//函数体的内容</span></div><div class="line">    <span class="keyword">return</span> n1 + n2; <span class="comment">//返回值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通常，函数包括四个部分：<br>（1）保留字，function。<br>（2）函数名，这里为fn。<br>（3）圆括号以及包围在圆括号中的一组参数。<br>（4）包括在花括号中的一组语句。</p>
<blockquote>
<p>❐ 函数名可以被省略（称为匿名函数），函数名可用于函数调用或者是递归调用，另外函数名可以被调试器和开发工具识别。</p>
<p>❐ 函数声明时的参数为形参，可以有多个，多个参数之间使用逗号进行分隔。<code>形参将在函数调用的时候被定义为函数中的局部变量，[注意]形参并不会像普通变量一样被初始化为undefined，它们的值根据函数调用时传入的实际参数值设置。</code>另外，函数调用的时候并不会对实参的类型进行检查。</p>
<p>❐ 函数体是一组语句，它们在函数<code>被调用</code>的时候执行。函数执行完毕后，会返回一个值。</p>
</blockquote>
<p> <strong>函数的调用</strong>：函数声明后可以通过（）运算符来进行调用，JavaScript语言中，只有函数可以被调用。当函数被调用的时候，如果存在参数传递，那么会把实参的值传递给形参，并按照从上到下的顺序逐条执行函数体内部的代码。</p>
<h4 id="1-2-函数和对象的关系"><a href="#1-2-函数和对象的关系" class="headerlink" title="1.2  函数和对象的关系"></a>1.2  函数和对象的关系</h4><p>JavaScript中的函数本质上就是对象。<br>在使用typeof 关键字对数据进行类型检查的时候，得到的结果可能会让我们产生错觉。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">   <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> o);      <span class="comment">//object</span></div><div class="line">   <span class="built_in">console</span>.log(<span class="keyword">typeof</span> f);      <span class="comment">//function</span></div></pre></td></tr></table></figure></p>
<p>实际上，函数和对象没有质的区别，函数是特殊的对象。</p>
<blockquote>
<p>函数的特殊性<br>① 函数可以被（）运算符调用[最重要]。<br>② 函数可以创建独立的作用域空间。<br>③ 函数拥有标配的prototype属性。</p>
</blockquote>
<p>因为函数本身就是对象，所以在代码中函数可以像对象一样被使用，凡是对象可以出现的地方函数都可以出现。</p>
<blockquote>
<p>❐ 函数可以拥有属性和方法。<br>❐ 函数可以保存在变量、对象和数组中。<br>❐ 函数可以作为其它函数的参数（称为函数回调）。<br>❐ 函数可以作为函数的返回值进行返回。</p>
</blockquote>
<p><strong>函数和对象的原型链结构</strong><br>我们可以通过下面列出的简单示例代码来分析对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//字面量方式创建普通的对象</span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">name</span>:<span class="string">"文顶顶"</span>,<span class="attr">age</span>:<span class="string">"18"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//关于普通对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印o对象\n"</span>,o);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印o.__proto__\n"</span>,o.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印o.__proto__ === Object.prototype\n"</span>,o.__proto__ === <span class="built_in">Object</span>.prototype)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印o.constructor\n"</span>,o.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印o.constructor === Object\n"</span>,o.constructor === <span class="built_in">Object</span>);</div></pre></td></tr></table></figure></p>
<p>通过对该代码的运行和打印分析，可以得到下面的图示。<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_01.png?raw=true"></p>
<p>我们也可以使用同样的方式来分析函数对象的原型链结构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//使用构造函数Function 来创建函数(对象)</span></div><div class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"return a + b"</span>);</div><div class="line"><span class="comment">//调用函数，证明该函数是合法可用的</span></div><div class="line"><span class="built_in">console</span>.log(f(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">//得到打印结果5</span></div><div class="line"></div><div class="line"><span class="comment">//关于函数对象的结构研究</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"① 打印函数对象\n"</span>,f);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"② 打印f.__proto__\n"</span>,f.__proto__);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"③ 打印f.__proto__===Function.prototype\n"</span>,f.__proto__===<span class="built_in">Function</span>.prototype);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"④ 打印f.constructor\n"</span>,f.constructor);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"⑤ 打印f.constructor === Function\n"</span>,f.constructor === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意</span></div><div class="line"><span class="built_in">console</span>.log(f.hasOwnProperty(<span class="string">"constructor"</span>));   <span class="comment">//检查constructor是否为函数f的实例成员(false)</span></div><div class="line"><span class="built_in">console</span>.log(f.__proto__.hasOwnProperty(<span class="string">"constructor"</span>)); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>顺便贴出研究Function原型结构的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//说明：下面三行代码表明Function的原型对象指向一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);  <span class="comment">//ƒ () &#123; [native code] &#125;  是一个空函数</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">//function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Function</span>.prototype));  <span class="comment">//[object Function]</span></div><div class="line"></div><div class="line"><span class="comment">//检查Function.prototype的原型链结构</span></div><div class="line"><span class="comment">//Function.prototype是一个空函数，是一个对象，而对象均由构造函数实例化产生</span></div><div class="line"><span class="comment">//检查Function.prototype的构造函数以及原型对象</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor  === <span class="built_in">Function</span>);</div><div class="line"></div><div class="line"><span class="comment">//注意：按照一般逻辑实例对象的__proto__(原型对象)应该指向创建该实例对象的构造函数的原型对象</span></div><div class="line"><span class="comment">//即此处应该表现为Function.prototype.__proto__---&gt;Function.prototype.constructor.prototype</span></div><div class="line"><span class="comment">//似乎可以得出推论：Function.prototype.__proto__ === Function.prototype == 空函数 但这是错误的</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype);</div></pre></td></tr></table></figure></p>
<p>通过对函数对象原型结构的代码探索，可以得到下图的原型链结构图（<code>注</code>：原型链并不完整）</p>
<p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_02.png?raw=true"></p>
<p><strong>函数的其它隐藏细节</strong></p>
<p><span style="color:#ff3333">① 函数天生的prototype属性<span></span></span></p>
<p>每个函数对象在创建的时候会随配一个prototype属性，即每个函数在创建之后就天生拥有一个与之相关联的原型对象，这个关联的原型对象中拥有一个constructor属性，该属性指向这个函数。<br>简单描述下就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function f()&#123; //......&#125;  //声明函数</div><div class="line">//函数声明被创建后，默认拥有prototype属性---&gt;原型对象（空对象）</div></pre></td></tr></table></figure></p>
<p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_03.png?raw=true"></p>
<p><div class="tip"><br>这里需要注意的是，很多人容易被自己的经验误导，认为新创建的函数对象身上除prototype实例属性外，还拥有constructor这个实例属性，因为我们经常看到<code>f.constructor类似的代码</code>，其实这里使用的constructor属性是从原型链中获取的，其实是f构造函数关联原型对象上面的属性，即Function.prototype.constructor。</div></p>
<div>

<p style="border: 1px solid #666;">备注：在<a href="https://www.ecma-international.org/ecma-262/5.1/#sec-13.2" target="_blank" rel="external">ECMAScript标准中函数创建相关章节</a>有这样一句话：NOTE A prototype property is automatically created for every function, to allow for the possibility that the function will be used as a constructor.解释了给新创建函数添加prototype属性的意义在于便于该函数作为构造函数使用。</p>

<p><span style="color:#ff3333">② 函数何以能够被调用<span></span></span></p>
<p>我们已经理解了函数本身就是对象，但又区别于普通对象，最大的区别在于函数可以被调用，（）被称为调用运算符。</p>
<blockquote>
<p>❗️ 函数可以被调用的原因在于JavaScript创建一个函数对象时，会给该对象设置一个“调用”属性。当JavaScript调用一个函数时，可以理解为调用该函数的“调用”属性。</p>
</blockquote>
<h4 id="1-5-函数的返回值"><a href="#1-5-函数的返回值" class="headerlink" title="1.5  函数的返回值"></a>1.5  函数的返回值</h4><p><strong>函数的调用</strong>：调用一个函数会暂停当前代码的执行，把控制权和参数传递给正被调用的函数。当一个函数被调用的时候，它会先根据实际参数来对函数的形式参数进行初始化，然后从函数体中的第一个语句开始执行并遇到关闭函数体的 } 时结束。然后把控制权交还给调用该函数的上下文。</p>
<p><strong>函数的返回值</strong>：函数体中return语句可以用来让函数提前返回。当retun语句被执行时，函数会立即返回而不再执行余下的语句，return语句后面跟上返回的具体数据，可以是任意类型（包括函数）。</p>
<blockquote>
<p>❐ 函数总是会有一个返回值，如果没有使用return语句指定，那么将总是返回<code>undefined</code>。</p>
<p>❐ 函数的返回值还和它的调用方式有关系，如果使用new也就是也构造函数的方式来调用，若函数体中没有通过return语句显示的返回一个对象类型的数据，则<code>默认返回this（新创建的实例对象）</code>。</p>
<p>❗️ JavaScript不允许在return关键字和表达式之间换行。</p>
</blockquote>
<hr>
<ul>
<li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.cn" target="_blank" rel="external">花田半亩</a></li>
<li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶_iOS</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li>
</ul>
</div></div></article></div></main><footer><div class="paginator"><a href="/2018/04/11/Mac系统Tree的使用/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://weibo.com/u/3800117445">文顶顶</a></p><!--p © #{year} #[a(href=config.url)!= config.author], powered by #[a(href=hexoURL, target="_blank") Hexo] and #[a(href=apolloURL, target="_blank") hexo-theme-apollo].--></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>