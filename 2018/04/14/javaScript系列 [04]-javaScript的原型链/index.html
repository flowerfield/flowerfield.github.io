<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> javaScript系列 [04]-javaScript的原型链 · 花田半亩</title><meta name="description" content="javaScript系列 [04]-javaScript的原型链 - 文顶顶"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/logo.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://weibo.com/u/3800117445/atom.xml" title="花田半亩"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/白菜.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">文顶顶的BLOG</a></li><li class="nav-list-item"><a href="https://www.cnblogs.com/wendingding/" target="_blank" class="nav-list-link">博客园</a></li><li class="nav-list-item"><a href="https://github.com/flowerField" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://blog.sina.com.cn/u/1910914290" target="_blank" class="nav-list-link">花田半亩</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">javaScript系列 [04]-javaScript的原型链</h1><div class="post-info">Apr 14, 2018</div><div class="post-content"><blockquote>
<p>本文旨在花很少的篇幅讲清楚JavaScript语言中的原型链结构，很多朋友认为JavaScript中的原型链复杂难懂，其实不然，它们就像树上的一串猴子。</p>
</blockquote>
<h4 id="1-1-理解原型链"><a href="#1-1-理解原型链" class="headerlink" title="1.1 理解原型链"></a>1.1 理解原型链</h4><p>JavaScript中几乎所有的东西都是对象，我们说数组是对象、DOM节点是对象、函数等也是对象，创建对象的Object也是对象（本身是构造函数），那么有一个重要的问题：<code>对象从哪里来？</code></p>
<p>这是一句废话，对象当然是通过一定方式创建出来的，根据实际类型不同，对象的创建方式也千差万别。</p>
<p>比如函数，我们可以声明函数、使用Function构造函数创建等，比如数组，我们可以直接通过var arr  = [] 的方式创建空数组，也可以通过new Array的方式创建，比如普通的对象，我们可以字面量创建、使用内置构造函数创建等等，花样太多了，以至于我们学习的时候头昏脑涨、不得要领。<span style="color:red">其实，归根结底所有“类型”的对象都可以认为是由相应构造函数创建出来的。</span> 函数由Function构造函数实例化而来，普通对象由Object构造函数实例化而来，数组对象由Array构造函数实例化而来，至于Object | Array | Function等他们本身是函数，当然也有自己的构造函数。</p>
<p>理解了上面一点，那么接下来我们在理解原型链的时候就会容易得多。</p>
<blockquote>
<p>请看刺激的推导过程</p>
<p>前提 所有对象都由构造函数实例化而来，构造函数默认拥有与之相关联的原型对象<br>❒  ① 构造函数的原型对象也是对象，因此也有自己的构造函数<br>❒  ② 构造函数原型对象的构造函数，也有与之相关连的原型对象<br>❒  ③ 构造函数原型对象的原型对象（<code>__proto__</code>）也有自己的构造函数，其也拥有关联的原型对象<br>☞ 以上就形成了一种链式的访问结构，是为<code>原型链</code>。</p>
</blockquote>
<p><div class="tip"><br>其实构造函数也是对象，所以构造函数本身作为对象而言也有自己的构造函数，而这个构造函数也拥有与之相关联的原型对象，以此类推。那么，这就是另一条原型链了。综上，我们可以得出<code>原型链并不孤单</code>的结论。<div></div></div></p>
<h4 id="1-2-原型链结构"><a href="#1-2-原型链结构" class="headerlink" title="1.2 原型链结构"></a>1.2 原型链结构</h4><p>现在我们基本上把原型链的由来说清楚了，那么接下来通过具体的代码来分析原型链的整体结构。</p>
<p>示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//01 自定义构造函数Person和Animal</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//02 使用构造函数创建实例对象</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal();</div><div class="line"></div><div class="line"> <span class="comment">//03 创建数组对象</span></div><div class="line"><span class="keyword">var</span> arrM = [<span class="string">"demoA"</span>,<span class="string">"demoB"</span>];</div></pre></td></tr></table></figure></p>
<p>上面的代码非常简单，其中p1，p2和a它们是自定义构造函数的实例化对象。其次，我们采用快捷方式创建了arrM数组，arrM其实是内置构造函数Array的实例化对象。另外，Person和Animal这两个构造函数其实是Function构造函数的实例对象。理解以上几点后，我们就可以来看一下这几行代码对应的原型链结构图了。</p>
<p><img src="https://github.com/flowerField/Source/blob/master/Blog/js_07.png?raw=true"></p>
<p>原型链结构图说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">① 因为复杂度关系，arrM对象的原型链结构图单独给出。</div><div class="line">② Object.prototype是所有原型链的顶端，终点为null。</div></pre></td></tr></table></figure></p>
<p>验证原型链相关的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证p1、p2的原型对象为Person.prototype</span></div><div class="line"><span class="comment">//    验证a    的原型对象为Animal.prototype</span></div><div class="line"><span class="built_in">console</span>.log(p1.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(p2.__proto__ == Person.prototype); <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(a.__proto__ == Animal.prototype);  <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 获取Person.prototype|Animal.prototype构造函数</span></div><div class="line"><span class="comment">//    验证Person.prototype|Animal.prototype原型对象为Object.prototype</span></div><div class="line"><span class="comment">//    先删除实例成员，通过原型成员访问</span></div><div class="line"><span class="keyword">delete</span>  Person.prototype.constructor;</div><div class="line"><span class="keyword">delete</span>  Animal.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(Person.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == <span class="built_in">Object</span>);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.prototype.__proto__ == <span class="built_in">Object</span>.prototype);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[3] 验证Person和Animal的构造函数为Function</span></div><div class="line"><span class="comment">//    验证Person和Animal构造函数的原型对象为空函数</span></div><div class="line"><span class="built_in">console</span>.log(Person.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Person.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(Animal.__proto__ == <span class="built_in">Function</span>.prototype);        <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[4] 验证Function.prototype的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.constructor == <span class="built_in">Function</span>);    <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[5] 验证Function和Object的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>);              <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>);                <span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[6] 验证Function.prototype的原型对象为Object.prototype而不是它自己</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//[7] 获取原型链的终点</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);                    <span class="comment">//null</span></div></pre></td></tr></table></figure></p>
<p>下面贴出数组对象的原型链结构图<br><img src="https://github.com/flowerField/Source/blob/master/Blog/js_08.png?raw=true"></p>
<p>验证数组对象原型链结构的代码示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//[1] 验证arrM的构造函数为Array</span></div><div class="line"><span class="comment">//方法1</span></div><div class="line"><span class="built_in">console</span>.log(arrM.constructor == <span class="built_in">Array</span>);                 <span class="comment">//true</span></div><div class="line"><span class="comment">//方法2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arrM));      <span class="comment">//[object Array]</span></div><div class="line"></div><div class="line"><span class="comment">//[2] 验证Array的构造函数为Function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>);             <span class="comment">//true</span></div><div class="line"><span class="comment">//[3] 验证Array构造函数的原型对象为Function.prototype(空函数)</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype);     <span class="comment">//true</span></div><div class="line"><span class="comment">//[4] 验证Array.prototype的构造函数为Object,原型对象为Object.prototype</span></div><div class="line"><span class="keyword">delete</span> <span class="built_in">Array</span>.prototype.constructor;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.constructor == <span class="built_in">Object</span>);         <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h4 id="1-2-原型链的访问"><a href="#1-2-原型链的访问" class="headerlink" title="1.2 原型链的访问"></a>1.2 原型链的访问</h4><p><strong>原型链的访问规则</strong><br><span style="color"><br>对象在访问属性或方法的时候，先检查自己的实例成员，如果存在那么就直接使用，如果不存在那么找到该对象的原型对象，查找原型对象上面是否有对应的成员，如果有那么就直接使用，如果没有那么就顺着原型链一直向上查找，如果找到则使用，找不到就重复该过程直到原型链的顶端，此时如果访问的是属性就返回undefined，方法则报错。<br></span></p>
<p>示例代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = <span class="string">"wendingding"</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   Person.prototype = &#123;</div><div class="line">       <span class="keyword">constructor</span>:Person,</div><div class="line">       name:"自来熟",</div><div class="line">       showName:function () &#123;</div><div class="line">           <span class="keyword">this</span>.name.lastIndexOf()</div><div class="line">       &#125;</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line">   <span class="built_in">console</span>.log(p.name);  <span class="comment">//访问的是实例成员上面的name属性：wendingding</span></div><div class="line">   p.showName();          <span class="comment">//打印wendingding</span></div><div class="line">   <span class="built_in">console</span>.log(p.age);    <span class="comment">//该属性原型链中并不存在，返回undefined</span></div><div class="line">   p.showAge();           <span class="comment">//该属性原型链中并不存在，报错</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>实例成员：实例对象的属性或者是方法<br>原型成员：实例对象的原型对象的属性或者是方法<br>访问原则：就近原则</p>
</blockquote>
<h4 id="1-3-原型继承"><a href="#1-3-原型继承" class="headerlink" title="1.3 原型继承"></a>1.3 原型继承</h4><p>继承是面向对象编程的基本特征之一，JavaScript支持面向对象编程，在实现继承的时候，有多种可行方案。接下来，我们分别来认识下原型式继承和在此基础上演变出来的组合继承。</p>
<p><strong>原型式继承基本写法</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//01 提供超类型|父类型构造函数</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">this</span>.name = <span class="string">'SuperClass的名称'</span>;</div><div class="line">       <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">//02 设置父类型的原型属性和原型方法</span></div><div class="line">   SuperClass.prototype.info = <span class="string">'SuperClass的信息'</span>;</div><div class="line">   SuperClass.prototype.showInfo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="built_in">console</span>.log(<span class="keyword">this</span>.info);</div><div class="line">   &#125;;</div><div class="line"></div><div class="line">   <span class="comment">//03 提供子类型</span></div><div class="line">   <span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"></div><div class="line">   <span class="comment">//04 设置继承(原型对象继承)</span></div><div class="line">   SubClass.prototype = SuperClass.prototype;</div><div class="line">   SubClass.prototype.constructor = SubClass;</div><div class="line"></div><div class="line">   <span class="keyword">var</span> sub = <span class="keyword">new</span> SubClass();</div><div class="line">   <span class="built_in">console</span>.log(sub.name);          <span class="comment">//undefined</span></div><div class="line">   <span class="built_in">console</span>.log(sub.info);          <span class="comment">//SuperClass的信息</span></div><div class="line">   sub.showInfo();                 <span class="comment">//SuperClass的信息</span></div><div class="line">   sub.showName();                 <span class="comment">//sub.showName is not a function</span></div></pre></td></tr></table></figure></p>
<p><div class="tip">提示 原型式继承的方式可以实现继承超类型中的原型成员，但是无法继承实例属性和实例方法<div></div></div></p>
<p><strong>原型链继承</strong></p>
<p><strong>组合继承</strong></p>
<p>实现思想</p>
<blockquote>
<p>① 使用原型链实现对原型属性和方法的继承<br>② 通过伪造(冒充)构造函数来实现对实例属性的继承</p>
</blockquote>
<p><strong>组合继承基本写法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">      <span class="keyword">this</span>.name = name;</div><div class="line">      <span class="keyword">this</span>.age = <span class="number">23</span>;</div><div class="line">  &#125;</div><div class="line">  Person.prototype.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"让我掉下眼里的,不止昨夜的酒"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Boy</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      Person.call(<span class="keyword">this</span>,name);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//原型式继承:</span></div><div class="line">  <span class="comment">//(1)获取父构造函数的实例成员 Person.call(this,name);</span></div><div class="line">  <span class="comment">//(2)获取父构造函数的原型成员  Boy.prototype = Person.prototype;</span></div><div class="line">  Boy.prototype = Person.prototype;    <span class="comment">//原型式继承</span></div><div class="line">  <span class="comment">//Boy.prototype = new Person();      //原型链继承</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> b1 = <span class="keyword">new</span> Boy(<span class="string">"张三"</span>);</div><div class="line">  <span class="keyword">var</span> b2 = <span class="keyword">new</span> Boy(<span class="string">"李四"</span>);</div><div class="line">  <span class="built_in">console</span>.log(b1);</div><div class="line">  <span class="built_in">console</span>.log(b2);</div><div class="line">  b1.showName();</div></pre></td></tr></table></figure>
<hr>
<ul>
<li>Posted by 博客园·<a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a> ~ <a href="http://wendingding.cn" target="_blank" rel="external">花田半亩</a></li>
<li>联系作者 简书·<a href="http://www.jianshu.com/users/c5703017b9f5/latest_articleshttp://www.jianshu.com/users/c5703017b9f5/latest_articles" target="_blank" rel="external">文顶顶</a> 新浪微博·<a href="http://weibo.com/p/1005053800117445/home?from=page_100505&amp;mod=TAB#place">文顶顶</a></li>
<li>原创文章，版权声明：自由转载-非商用-非衍生-保持署名 | <a href="http://www.cnblogs.com/wendingding/" target="_blank" rel="external">文顶顶</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/14/javaScript系列 [03]-javaScript的原型链/" class="prev">上一篇</a><a href="/2018/04/13/javaScript系列 [02]-深入浅出javaScript中的对象/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://weibo.com/u/3800117445">文顶顶</a></p><!--p © #{year} #[a(href=config.url)!= config.author], powered by #[a(href=hexoURL, target="_blank") Hexo] and #[a(href=apolloURL, target="_blank") hexo-theme-apollo].--></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>